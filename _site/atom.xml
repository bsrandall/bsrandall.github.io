<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>No Excuses CCIE</title>
 <link href="http://bsrandall.github.io/atom.xml" rel="self"/>
 <link href="http://bsrandall.github.io/"/>
 <updated>2017-04-02T23:48:54-04:00</updated>
 <id>http://bsrandall.github.io</id>
 <author>
   <name>Brian Scott Randall</name>
   <email></email>
 </author>

 
 <entry>
   <title>Longest Match Routing</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/02/Longest-Match-Routing/"/>
   <updated>2017-04-02T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/02/Longest-Match-Routing</id>
   <content type="html">&lt;p&gt;Longest Match Routing is the idea that a packet will follow the most specific route entry that it matches. So if there was a host route (/32) that existed for the destination, the host route would have precedence over any shorter prefix such as a /24.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>IPv4 Addressing</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/02/IPv4-Addressing/"/>
   <updated>2017-04-02T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/02/IPv4-Addressing</id>
   <content type="html">&lt;p&gt;IP is a logical addressing method as compared to MAC layer physical addresses. It operates at the Network Layer (Layer 3) of the OSI model.&lt;/p&gt;

&lt;p&gt;An address mask is used to identify the network and host portions of the address.  It is 32-bits long, the same length as an IPv4 address. In general, an address mask is assigned to a network or an organization. The organization then subnets that address mask into per data-link subnet masks for assignment.&lt;/p&gt;

&lt;p&gt;The number of available subnets under a major address mask and the number of hosts on each subnet are both calculated with the same formula 2^n-2.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Administrative Distance</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/02/Administrative-Distance/"/>
   <updated>2017-04-02T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/02/Administrative-Distance</id>
   <content type="html">&lt;p&gt;Administrative Distance is used to determine which route should be installed into the IP routing table when there is a tie between different sources for the route (static vs EIGRP vs OSPF, etc). Administrative Distance is sometimes called the trustworthiness of the source. When a decision has to be made, the table containing Administrative Distance is consulted to choose the best route, with lower being better. Administrative Distance is only local and can be different for each router.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;distance&lt;/code&gt; command is used with the different routing protocols to change its Administrative Distance. Here is a list&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Routing Protocol&lt;/td&gt;
      &lt;td&gt;AD&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;————————-&lt;/td&gt;
      &lt;td&gt;——&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Directly connected&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Static route&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EIGRP Summary&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;External BGP&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EIGRP&lt;/td&gt;
      &lt;td&gt;90&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IGRP&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OSPF&lt;/td&gt;
      &lt;td&gt;110&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IS-IS&lt;/td&gt;
      &lt;td&gt;115&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RIP&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ODR&lt;/td&gt;
      &lt;td&gt;160&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;External EIGRP&lt;/td&gt;
      &lt;td&gt;170&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Internal BGP&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Unknown&lt;/td&gt;
      &lt;td&gt;255&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</content>
 </entry>
 
 <entry>
   <title>IPv4 ARP</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/02/ARP/"/>
   <updated>2017-04-02T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/02/ARP</id>
   <content type="html">&lt;p&gt;Address Resolution Protocol (ARP) is used to determine the data-link identifier (MAC address) of a host with a known IPv4 address. The ARP request packet contains the IPV4 address of the device in question (the target), as well as the IPv4 and MAC address of the device making the request (the sender). The ARP packet is then encapsulated in a frame with the sender’s MAC address as the source and a broadcast address for the destination. The target will send an ARP Reply to the source address, supplying its MAC address. The ARP reply will lest the target as the original sender.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1# show arp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`The command above will display the ARP table on a Cisco router.&lt;/p&gt;

&lt;p&gt;Cisco routers hold ARP entries for 4 hours by default. It can be changed on a per-interface basis with the &lt;code class=&quot;highlighter-rouge&quot;&gt;arp timeout seconds&lt;/code&gt; interface subcommand.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clear arp-cache&lt;/code&gt; can be used to delete all dynamic entries from the ARP table. It will also clear the fast-switching cache as well as the IP route cache.&lt;/p&gt;

&lt;p&gt;Proxy ARP is a variation of ARP that is sometimes called promiscuous ARP. This is the method of how router’s will replay to an ARP request if they have a route to a host on another subnet. The router will send it’s own MAC address as a reply to the ARP request to trick the host into thinking it is the actual host in question. Proxy ARP is enabled by default in Cisco IOS and can be disabled on a per-interface basis with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;no ip proxy-arp&lt;/code&gt;.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>PPPoE</title>
   <link href="http://bsrandall.github.io/layer%202%20wan/2017/04/01/PPPoE/"/>
   <updated>2017-04-01T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202%20wan/2017/04/01/PPPoE</id>
   <content type="html">&lt;p&gt;PPPoE allows us to establish a PPP link over an Ethernet connection. ISPs were the main ones to use this as it gave them authentication capabilities over Ethernet, in a manner that was familiar to them from their dial-up days. There are two sides to the configuration, both a client and a server. We will start with the server side first.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`Server(config)# bba-group pope global
Server(config-bba-group)# virtual-template 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`The BBA group (Broadband Access) above is only needed if you want to run more than one PPPoE session.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`Server(config)# interface virtual-template 1
Server(config-if)# ip address 192.168.12.2 255.255.255.0
Server(config-if)# mtu 1492
Server(config-if)# peer default address pool CLIENT
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`Notice we have to reduce the MTU by 8 bytes due to the PPPoe overhead. Next we create the CLIENT IP address pool:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`Server(config)# ip local pool CLIENT 192.168.12.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`Finally, we just need to activate the BBA group on the interface.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`Server(config)# interface FastEthernet0/0
Server(config-if)# pppoe enable group global
Server(config-if)# exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
Now we move on to the Client:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`Client(config)# interface dialer 1
Client(config-if)# mtu 1492
Client(config-if)# encapsulation ppp
Client(config-if)# ip address negotiated
Client(config-if)# dialer persistent
Client(config-if)# dialer pool 1

Client(config)# interface FastEthernet0/0
Client(config-if)# pppoe-client dial-pool-number 1
Client(config-if)# exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`The dialer persistent command nails the connection up.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PPP</title>
   <link href="http://bsrandall.github.io/layer%202%20wan/2017/04/01/PPP/"/>
   <updated>2017-04-01T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202%20wan/2017/04/01/PPP</id>
   <content type="html">&lt;p&gt;PPP stands for point-to-point protocol - it is  a very popular method for establishing a serial connection over which to pass IP traffic. PPP is composed of Link Control Protocol (LCP) as well as a family of NCPs used to establish network-layer links for various protocols (such as IPv4) after LCP has established the basic link. The steps to enable PPP on a Cisco router are shown below.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# interface serial0/0
R1(config-if)# encapsulation ppp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>PPP Authentication</title>
   <link href="http://bsrandall.github.io/layer%202%20wan/2017/04/01/PPP-Authentication/"/>
   <updated>2017-04-01T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202%20wan/2017/04/01/PPP-Authentication</id>
   <content type="html">&lt;p&gt;There are two forms of authentication available for PPP, PAP and CHAP. It is important to remember that these technologies are one way in nature, and therefore do not need to be configured bidirectionally. You really should think of this as a Client / Server model.&lt;/p&gt;

&lt;p&gt;With PAP authentication, a two-way handshake is used to establish identity. After the PPP link establishment is complete, a username and password pair is repeatedly sent by the remote node (in clear text) until authentication is acknowledged, or the connection is terminated. PPP is not secure as passwords are sent across the link in clear text.&lt;/p&gt;

&lt;p&gt;PAP supports either unidirectional or bidirectional authentication. This is the configuration for unidirectional, where R1 is the called device and R2 is the calling device:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# username ROUTER2 password cisco
R1(config)# interface serial0/0
R1(config-if)# encapsulation ppp
R1(config-if)# ppp authentication pap
R1(config-if)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`And here is the configuration for R2, the client:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R2(config)# interface serial0/0
R2(config-if)# encapsulation ppp
R2(config-if)# ppp pap sent-username ROUTER2 password cisco
R2(config-if)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
CHAP identifies peers by use of a three-way handshake. The general steps are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;After the LCP phase is complete, and CHAP is established as the authentication protocol between devices, the authenticator sends a challenge message to the peer&lt;/li&gt;
  &lt;li&gt;The peer responds with a value calculated through a one-way hash function (MD5)&lt;/li&gt;
  &lt;li&gt;The authenticator checks the response against its own calculation of the expected hash value. If the values match, the authentication is successful, otherwise the connection is terminated.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Like PAP, authentication is one-way but can be configured bidirectionally. In this example, R1 is the CHAP server and R2 is the CHAP client.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# username ROUTER2 password cisco
R1(config)# interface serial0/0
R1(config-if)# encapsulation ppp
R1(config-if)# ppp authenticate chap
R1(config-if)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`And now,  R2 (the client) configuration:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R2(config)# username ROUTER1 password cisco
R2(config)# interface serial0/0
R2(config-if)# encapsulation ppp
R2(config-if)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PPP Multilink</title>
   <link href="http://bsrandall.github.io/layer%202%20wan/2017/04/01/Multilink-PPP/"/>
   <updated>2017-04-01T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202%20wan/2017/04/01/Multilink-PPP</id>
   <content type="html">&lt;p&gt;Multilink PPP is a method used to aggregate multiple single PPP links and utilize them as one. It is not that dissimilar from EtherChannel used with Ethernet. PPP frames can be fragmented, sent down different links, and then reassembled in order on the far side of the link. Multilink PPP uses a 2 or 4 byte sequencing header in each packet, and the remote MLPPP recover is tasked with reconstructing the frames in the correct order. The configuration is pretty straightforward.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`interface Serial0/1
  description Link to R1
  no ip address
  encapsulation ppp
  ppp multilink
  ppp multilink group 1
  serial restart-delay 0
end

interface Serial1/1
  description Link to R1
  no ip address
  encapsulation ppp
  ppp multilink
  ppp multilink group 1
  serial restart-delay 0
end

interface Multilink 1
  ip address 192.168.12.2 255.255.255.0
  ppp multilink
  ppp multilink group 1
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
Some optional parameters include &lt;/code&gt;ppp multilink interleave&lt;code class=&quot;highlighter-rouge&quot;&gt;. Interleaving allows large packets to be multilink encapsulated and fragmented into a small enough size to satisfy the delay requirements of real-time traffic. The interleaving feature also provides a special transmit queue for the smaller, delay-sensitive packets, enabling them to be sent earlier than other flows. &lt;/code&gt;ppp multilink fragement delay 10` is the command that determines the maximum delay - MLPPP will then chose a fragment size based on the configured delay.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>HDLC</title>
   <link href="http://bsrandall.github.io/layer%202%20wan/2017/04/01/HDLC/"/>
   <updated>2017-04-01T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202%20wan/2017/04/01/HDLC</id>
   <content type="html">&lt;p&gt;HDLC is a Layer 2 protocol - the Cisco version is a slight tweak from the original ISO version, so Cisco HDLC will not operate with HDLC implementations from other vendors. It is used on serial interfaces to make direct connections between routers. It is actually the default point-to-point serial protocol for Cisco routers, but PPP is more commonly used.&lt;/p&gt;

&lt;p&gt;You must always remember when connecting two serial interfaces, the DCE side must set a clock rate.&lt;/p&gt;

&lt;p&gt;If you are changing back from PPP to HDLC, the following shows how you would accomplish it.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# interface serial0/0
R1(config-if)# encapsulation hdlc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Voice VLAN</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/30/Voice-VLAN/"/>
   <updated>2017-03-30T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/30/Voice-VLAN</id>
   <content type="html">&lt;p&gt;On Cisco switch’s, you can configure a particular VLAN known as the voice VLAN. It is a special VLAN that Cisco developed that is meant to lead from the switch the the 3 port switch on the back of an IP Phone. The traffic from the computer will be sent untagged, regardless of whether the access VLAN for that port is the default VLAN. All traffic from the phone gets tagged to its assigned voice VLAN. It behaves in many way like a trunk, but from an operational perspective it is still a port in access mode. The configuration looks like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface GigabitEthernet0/1
SW1(config-if)# switchport mode access
SW1(config-if)# switchport access vlan 100
SW1(config-if)# switchport voice vlan 101
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;If you you show commands, you will not find the interface to be in trunk operational mode, but remember it works like a rudimentary trunk.&lt;/p&gt;

&lt;p&gt;As soon as you apply the &lt;code class=&quot;highlighter-rouge&quot;&gt;switchport voice vlan&lt;/code&gt; command, Portfast is enabled on the interface, though you will not see it in the running-config.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Storm Control</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/30/Storm-Control/"/>
   <updated>2017-03-30T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/30/Storm-Control</id>
   <content type="html">&lt;p&gt;Broadcast storms can create havoc on a Layer 2 network, quickly bringing the network to an unusable state. Software solutions to storm control are inefficient, because by the time the software has identified the storm, the hardware resources are at max utilization and there is no resources available to abate the storm.&lt;/p&gt;

&lt;p&gt;Cisco has a storm control feature built into its switches. It is a hardware based solution that allows us to set a threshold on interfaces to limit the amount of broadcast, multicast, or unknown unicast traffic an interface receives. It also allows us to select a couple of actions to take when that threshold is met.&lt;/p&gt;

&lt;p&gt;Let’s jump right into a configuration example.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface GigabitEthernet0/1
SW1(config-if)# storm-control broadcast level 30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The ’30’ in the example above designates the rising threshold. When broadcast traffic exceeds 30% of the interface bandwidth, storm control will kick in and take action. The default action is to drop exceeding traffic.&lt;/p&gt;

&lt;p&gt;You can also specify bps as below. Adding k, m, or g identifies the value as Kbps, Mbps, or Gbps respectively. The example below would limit broadcast traffic to 30 Mbps on the Gigabit interface.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface GigabitEthernet0/1
SW1(config-if)# storm-control broadcast level bps 30m
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can also designate a falling threshold. The falling threshold sets a value to which the traffic has to fall before that type of traffic is allowed again.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface GigabitEthernet0/1
SW1(config-if)# storm-control broadcast level bps 30m 20m
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;In the example above the broadcast traffic would have to drop below 20 Mbps before any broadcast traffic would be allowed into the port.&lt;/p&gt;

&lt;p&gt;We can also control the action. &lt;code class=&quot;highlighter-rouge&quot;&gt;storm-control action shutdown&lt;/code&gt; shuts the interface down in case the level is exceeded. &lt;code class=&quot;highlighter-rouge&quot;&gt;storm-control action trap&lt;/code&gt; sends an SNMP trap if the level is exceeded.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;show storm-control [unicast | multicast | broadcast]&lt;/code&gt; is used to see the configuration as well as the current amount of traffic passing through the port.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Static MAC Address Entries</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/30/Static-MAC-Address/"/>
   <updated>2017-03-30T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/30/Static-MAC-Address</id>
   <content type="html">&lt;p&gt;Sometimes you may need to add static MAC address entries to the CAM table. This is easily achieved with the following global configuration command:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(cone)# mac address-table static 0022.5627.1fc1 vlan 10 interface GigabitEthernet0/1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;You can also force traffic to a particular MAC address to be dropped, by either specifying an unused interface or with the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(conf)# mac address-table static 0022.5627.1fc1 vlan 10 drop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Smartport Macros</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/30/Smartport-Macros/"/>
   <updated>2017-03-30T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/30/Smartport-Macros</id>
   <content type="html">&lt;p&gt;Smartport Macros are used to define a well-known template of configuration onto multiple interfaces. Several Smartport Macros come predefined in the switch. To see them, use &lt;code class=&quot;highlighter-rouge&quot;&gt;show parser macro&lt;/code&gt;. To expand one of the macros use &lt;code class=&quot;highlighter-rouge&quot;&gt;show parser macro name ___________&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is the old style of configuring switchport macros:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(conf)# macro name VLAN146
Enter macro commands one per line. End with the character '@'.
switchport mode access
switchport access vlan 146
spanning-tree bpdufilter enable
@
SW1(conf)\#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The # symbol can be used at the beginning of a line to designate comments. Then to apply the macro to an interface or interface range:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(conf)# interface range gig0/1-2
SW1(conf-if-range)# macro apply VLAN146
SW1(conf-if-range)# exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The modern style to define a switchport macro is here:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(conf)# define interface-range VLAN146 gig0/1-2
SW1(conf)# interface range macro VLAN146
SW1(conf-if-range)# switchport mode access
SW1(conf-if-range)# switchport access vlan 146
SW1(conf-if-range)# spanning-tree bpdufilter enable
SW1(conf-if-range)# exit
SW1(conf)# 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Private VLANs</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/30/Private-VLANs/"/>
   <updated>2017-03-30T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/30/Private-VLANs</id>
   <content type="html">&lt;p&gt;Protect Ports (discussed earlier) are a nice security feature of Cisco switches. When two ports are protected, they are not allowed to have direct communication with each other. But one limitation of protected ports is that they are only locally significant, so there is no way for protected ports to exist on different switches and follow the protection rules.&lt;/p&gt;

&lt;p&gt;The Private VLAN feature was created to solve this limitation. Private VLANs are more complex and can span multiple physical switches. Private VLANs split what would normally be a single broadcast domain defined by a single VLAN into multiple isolated broadcast subdomains, that are defined by a primary VLAN and its secondary VLANs. In essence it allows us to create VLANs inside VLANs, and is not un-similar to the concept of Confederations in BGP.&lt;/p&gt;

&lt;p&gt;Private VLANs are used to increase security. We most often see them in a shared color facility. This allows the color provider to have the customers exist on the same VLAN (and thus the same subnet), without allowing the different customers to communicate directly with each other.&lt;/p&gt;

&lt;p&gt;One pitfall you have to remember with Private VLANs is that it requires VTP to either be in Transparent mode or to be off.&lt;/p&gt;

&lt;p&gt;There is some terminology to remember when dealing with Private VLANs:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Promiscuous ports&lt;/em&gt; are allowed to talk to all other ports within the primary VLAN&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Isolated ports&lt;/em&gt; are only allowed to talk with promiscuous ports&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Community ports&lt;/em&gt; are allowed to talk with other ports in their own community as well as any promiscuous ports,  but they are not allowed to talk to ports in other communities&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The configuration steps are a little unnatural as well. The port roles are defined by the interface’s association to a primary VLAN and one or more secondary VLANs. First the secondary VLANs are created and defined as either community or isolated. Then the primary VLAN is defined, and the secondary VLANs are associated with the primary VLAN.&lt;/p&gt;

&lt;p&gt;Here is an example configuration with VLAN 500 as the primary VLAN, 501 a secondary community VLAN, and VLAN 502 a secondary isolated VLAN. Ports FastEthernet0/1 and FastEthernet0/2 are associated to VLAN 501, while FastEthernet03 and FastEthernet0/4 are associated with the secondary isolated VLAN 502.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# vtp mode transparent
SW1(config)# vlan 501
SW1(config-vlan)# private-vlan community
SW1(config-vlan)# vlan 500
SW1(config-vlan)# private-vlan primary
SW1(config-vlan)# private-vlan association add 501
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, let’s go ahead and associate FastEthernet0/1 and FastEthernet0/2 to the 501 Secondary Community we just created:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface range fa0/1-2
SW1(config-if-range)# switchport mode private-vlan host
SW1(config-if-range)# switchport private-vlan host-association 500 501
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now, we can go ahead and configure FastEthernet0/24 as a promiscuous port.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface fa0/24
SW1(config-if)# switchport mode private-vlan promiscuous
SW1(config-if)# switchport private-vlan mapping 500 501
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now we turn our attention to the creation of the isolated VLAN, VLAN 502.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# vlan 502
SW1(config-vlan)# private-vlan isolated
SW1(config-vlan)# vlan 500
SW1(config-vlan)# private-vlan primary
SW1(config-vlan)# private-vlan association add 502
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now we must associate our interfaces:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface range fa0/3-4
SW1(config-if-range)# switchport mode private-vlan host
SW1(config-if-range)# switchport private-vlan host-association 500 502
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And finally, we must add another association for our promiscuous port:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface fa0/24
SW1(config-if)# switchport mode private-vlan promiscuous
SW1(config-if)# switchport private-vlan mapping 500 502
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;One great way to test your Private VLAN setup is to send a single ping to the broadcast address with &lt;code class=&quot;highlighter-rouge&quot;&gt;ping 255.255.255.255 repeat 1&lt;/code&gt;.  The replies will only be from the hosts in your broadcast domain.&lt;/p&gt;

&lt;p&gt;One other thing to note. If you are configuring a Primary VLAN SVI to operate with secondary private VLANs, you need to map the secondary VLANs onto the SVI as in the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`SW1(config)# interface Vlan 100
SW1(config-if)# private-vlan mapping 1000,2000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree Loop Guard</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/29/STP-Loop-Guard/"/>
   <updated>2017-03-29T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/29/STP-Loop-Guard</id>
   <content type="html">&lt;p&gt;Loop Guard is a Spanning Tree feature that was added to prevent loops from forming due to hardware issues or STP software problems. A Spanning Tree loop occurs when a port that was previously in the blocking state is erroneously  transitioned to the Forwarding state.&lt;/p&gt;

&lt;p&gt;When a non-designated port stops receiving BPDUs, it will eventually transition itself to a designated port and begin forwarding BPDUs. Loop Guard works by preventing that non-designated port from transitioning to a forwarding state. Instead, it transitions the port to STP loop-inconsistent blocking state. So Loop Guard prevents a non-designated port from becoming a designated port, while Root Guard prevents a designated port from transitioning to a Root Port.&lt;/p&gt;

&lt;p&gt;Loop Guard is very similar to UDLD, but Loop Guard uses STP BPDUs to determine if there is a loop.&lt;/p&gt;

&lt;p&gt;Loop Guard is enabled on a per-port basis with the interface subcommand &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree guard loop&lt;/code&gt;. To be completely effective, Loop Guard should be enabled on &lt;em&gt;all&lt;/em&gt; non-designated ports, including root ports and alternate ports. Loop Guard can also be enabled globally with the &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree loopguard default&lt;/code&gt; global configuration command. You can then disable Loop Guard on a per-port basis with &lt;code class=&quot;highlighter-rouge&quot;&gt;no spanning-tree guard loop&lt;/code&gt;.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Protected Port (PVLAN)</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/29/Protected-Port/"/>
   <updated>2017-03-29T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/29/Protected-Port</id>
   <content type="html">&lt;p&gt;The protected port, also known as PVLAN edge, is a security feature used to prevent traffic from being directly exchanged at Layer 2 between two or more hosts that are within the same VLAN. Protected ports only have local switch significance. A protected port does not forward any traffic (unicast, multicast, or broadcast) to any other protected port in the same switch. If you need to pass traffic between protected ports, the only possible way is through a L3 device.&lt;/p&gt;

&lt;p&gt;By default, all switch ports are unprotected. The configuration is as simple as below:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface gig0/1
SW1(config-if)# switchport protected
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree Root Guard</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-Root-Guard/"/>
   <updated>2017-03-28T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-Root-Guard</id>
   <content type="html">&lt;p&gt;Root Guard is an enhancement to STP developed by Cisco. One issue with standard STP is that there is no way to ensure root bridge placement within the network. Even if you set a switch’s bridge priority to 0, another switch can come behind it with a priority of 0 and a lower MAC address and immediately take over the Root Bridge role.&lt;/p&gt;

&lt;p&gt;Root Guard is enabled on a per port basis. Root Guard ensures that the port on which it is configured remains a designated port. If the bridge receives superior BPDUs on that designated port, Root Guard moves the port to root-inconsistent state, which is effectively equivalent to the STP listening state so no frames are forwarded.&lt;/p&gt;

&lt;p&gt;The difference between BPDU Guard and Root Guard is that Root Guard allows the port to participate in STP, so long as the port does not receive a &lt;em&gt;superior&lt;/em&gt; BPDU. With BPDU Guard, &lt;em&gt;any&lt;/em&gt; BPDU will put the port into an err-disabled state.&lt;/p&gt;

&lt;p&gt;Again, Root Guard is enabled on a per interface basis as below.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface gig0/1
SW!(config-if)# spanning-tree rootguard
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The Cisco explanation is located &lt;a href=&quot;http://www.cisco.com/c/en/us/support/docs/lan-switching/spanning-tree-protocol/10588-74.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Spanning Tree BPDU Guard</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-BPDU-Guard/"/>
   <updated>2017-03-28T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-BPDU-Guard</id>
   <content type="html">&lt;p&gt;BPDU Guard is a STP PortFast safety enhancement. It works by disabling a port any time the interface hears a BPDU. PortFast by itself will not do that, so if you have PortFast enabled on an interface, and an end user plugs a switch into that link, all kinds of events can happen (including the plugged in switch becoming the Root Bridge!). BPDU Guard ensures that unauthorized switches cannot be plugged into the network. A sample configuration is below.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface gig0/1
  spanning-tree bpduguard enable

errdisable recovery cause bpduguard
errdisable recovery interval 120
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The errdisable section enables the port after 120 seconds, in case the port is placed into err disabled state to due BPDU Guard.&lt;/p&gt;

&lt;p&gt;Optionally, you can set BPDU Guard as the default configuration on all interfaces with the following global commands:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;spanning-tree portfast bpduguard default
spanning-tree portfast default
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree BPDU Filter</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-BPDU-Filter/"/>
   <updated>2017-03-28T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-BPDU-Filter</id>
   <content type="html">&lt;p&gt;BPDU Filter is another optional feature of STP. It is similar to BPDU Guard, in that it is used to terminate the STP domain. Like BPDU Guard, it can be enabled globally or per interface, but unlike BPDU Guard, BGPU filter behaves differently depending on how it is enabled.&lt;/p&gt;

&lt;p&gt;If BPDU Filter is enabled at the interface level, it silently drops all received inbound BPDUs and does not send outbound BPDUs. Unlike BPDU Guard, there is no err-disabled option for BPDU Filter. Here is an example of BPDU Filter enabled at the interface level:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config-if)# switchport mode access
SW1(config-if)# switchport access vlan 10
SW1(config-if)# spanning-tree bpdufilter enable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When BPDU Filter is enabled globally, it will only affect PortFast enabled ports. The switch will send out exactly 11 BPDUs, and inbound BPDUs are not filtered. The reason 11 BPDUs are sent is the default Hello timer is 2 seconds and the default Max Age timer is 20 seconds. If the switch receives inbound BPDUs, the port loses its PortFast status and STP is negotiated normally on that port. For this reason, you can say that BPDU Filter enabled globally is a safer option than BPDU enabled at the interface level, as STP loops cannot form.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>STP UplinkFast</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-UplinkFast/"/>
   <updated>2017-03-27T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-UplinkFast</id>
   <content type="html">&lt;p&gt;UplinkFast provides fast convergence in case the link on which the root port is connected suffers a failure. It does this with the use of an uplink group. An uplink group is a set of Layer 2 interfaces, of which only one is forwarding at a particular time. If the root port (forwarding port) goes down, then a successor root port is chosen which immediately goes into Forwarding state, bypassing the Listening and Learning phases.&lt;/p&gt;

&lt;p&gt;UplinkFast functionality is built into RSTP, so UplinkFast is only applicable with legacy IEEE 802.1D.&lt;/p&gt;

&lt;p&gt;When UplinkFast is enabled on a switch, that switch’s bridge priority will automatically be increased to 49152 and its port cost will be increased to 3000. This is to ensure that the switch does not become a transit switch.&lt;/p&gt;

&lt;p&gt;To enable UplinkFast, go to the switch on which you want it to run and run &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree uplinkfast&lt;/code&gt; in global configuration mode.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>STP PortFast</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-Portfast/"/>
   <updated>2017-03-27T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-Portfast</id>
   <content type="html">&lt;p&gt;PortFast is used in Spanning Tree to avoid the lengthy delay of the Listening and Learning phases during STP convergence. When PortFast is enabled on an interface, the interface skips the Listening and Learning phases and goes straight into the Forwarding state. PortFast should be used on access switches on ports where you know end devices will be plugged in.&lt;/p&gt;

&lt;p&gt;To enable PortFast on an interface, in interface sub configuration mode use &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree portfast&lt;/code&gt;. If it is a trunk you must append the &lt;code class=&quot;highlighter-rouge&quot;&gt;trunk&lt;/code&gt; keyword after the command, and if it is an access port you should use the &lt;code class=&quot;highlighter-rouge&quot;&gt;edge&lt;/code&gt; keyword.&lt;/p&gt;

&lt;p&gt;Another way to enable PortFast for access ports is to use &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree portfast default&lt;/code&gt; in global configuration mode. Once enabled, all access ports will automatically have PortFast enabled.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree BackboneFast</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-BackboneFast/"/>
   <updated>2017-03-27T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-BackboneFast</id>
   <content type="html">&lt;p&gt;BackboneFast enables fast reconvergence due to indirect link failures. The key operation happens when a switch begins receiving inferior BPDUs.  When a switch loses the link off its Root Port, it immediately starts sending BPDUs announcing itself as the new Root. Usually, when a switch receives inferior BPDUs, it will wait for its Max Age timer to expire before beginning STP convergence. Once its Max Age timer expires, the inferior BPDU ages out and the switch will then forward its superior BPDU to the neighbor switch who was sending the inferior BPDU.&lt;/p&gt;

&lt;p&gt;When BackboneFast is enabled, as soon as a switch receives an inferior BPDU, it will send RLQ (Root Link Query) messages out all it’s non-designated ports. The RLQ asks other switches if the current Root Bridge is accessible via that switch. Note it doesn’t wait for its Max Age timer to expire - it begins sending RLQ messages immediately. The RLQ is a new type of PDU defined within the BackboneFast specification. The RLQ is essentially a proactive way to age out ports compared to just waiting on the Max Age timer to expire.&lt;/p&gt;

&lt;p&gt;Based on the received RLQ responses, the switch will update its root ports and designated ports accordingly.. However all ports still transition through the regular IEEE 802.1D STP port states - listening, learning, and forwarding/blocking.&lt;/p&gt;

&lt;p&gt;To enable BackboneFast use the command &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree backbonefast&lt;/code&gt; on all switches in the Layer 2 domain. The easiest way to verify that BackboneFast is enabled is to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;show spanning-tree summary&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;This is a great Cisco article describing the operation: &lt;a href=&quot;http://www.cisco.com/c/en/us/support/docs/lan-switching/spanning-tree-protocol/12014-18.html&quot;&gt;BackboneFast&lt;/a&gt;.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Debugging Spanning Tree Events</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/27/Debugging-STP/"/>
   <updated>2017-03-27T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/27/Debugging-STP</id>
   <content type="html">&lt;p&gt;Here is a configuration for debugging Spanning Tree events:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# debug spanning-tree events
SW1# debug condition vlan 2
SW1# config t
SW1(config)# service timestamps debug datetime msec
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>STP Convergence Timers</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/26/STP-Timers/"/>
   <updated>2017-03-26T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/26/STP-Timers</id>
   <content type="html">&lt;p&gt;There are 3 timers we need to be concerned with in Spanning Tree: the Hello Time, the Forward Delay, and the Max-Age Time.&lt;/p&gt;

&lt;p&gt;The Hello Time is the frequency with which BPDUs are transmitted from the root bridge. It can be adjusted with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree vlan 1-4094 hello-time 3&lt;/code&gt; where 3 is in seconds. The default is 2 seconds, but in can be adjusted between 1 and 10 seconds. Non-root bridges will never generate BPDUs, but only relay BPDUs they receive on their root port.&lt;/p&gt;

&lt;p&gt;The Forward Delay is the time that is spent in the listening and learning states. Its value is 15 seconds by default, but it can be adjusted to anywhere between 4 and 30 seconds.&lt;/p&gt;

&lt;p&gt;The Max Age timer controls the maximum length of time that passes before a bridge port saves its configuration BPDU. This time is 20 seconds by default, but it can be tuned to be anytime between 6 and 40 seconds.&lt;/p&gt;

&lt;p&gt;There is another item that is not a timer but is related. This is the &lt;em&gt;message age&lt;/em&gt;. The root bridge sends all of its BPDUs with a message age of 0. Each downstream switch then adds 1 to this message age value. The actual age out time of the downstream switches is then (max age - message age).&lt;/p&gt;

&lt;p&gt;Here is a good article that describes the Max Age timer as it relates to superior BPDUs:  &lt;a href=&quot;https://packetmagnifier.wordpress.com/2013/09/09/understanding-stp-max-age/&quot;&gt;Max Age&lt;/a&gt;. If a switch’s root port goes down, there is no need for it to go through the Max Age timer process - if there are no better BPDUs received, the switch will immediately start announcing itself as root and begin sending BPDUs. In the scenario in the article, the switch that went down is sending inferior BPDUs, but yet the receiving switch goes through the Max Age process before it transforms its non-designated port to a Designated Port and begins sending the superior BPDUs towards the switch that suffered the down link.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>STP Path Selection with Port Cost</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/21/STP-Port-Cost/"/>
   <updated>2017-03-21T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/21/STP-Port-Cost</id>
   <content type="html">&lt;p&gt;There are two ways we can alter STP Path selection. We can alter the cost of a port, or we can change the priority of a port.&lt;/p&gt;

&lt;p&gt;When a switch receives a BPDU, that BPDU contains the root path cost from the previous switch. The receiving switch then adds the cost of the link between it and the sending switch from which it received the BPDU. That is very important - it is the receiving switch that adds the cost associated with its interface to the Root Path Cost it received from the sending switch.&lt;/p&gt;

&lt;p&gt;Cost is used for the selection of the root port to the upstream switch.&lt;/p&gt;

&lt;p&gt;Priority is used for influencing the root port of the downstream switch, and as such, it is set up on a port in Designated state. Cost has a higher precedence than priority. You will see priority on the local switch &lt;code class=&quot;highlighter-rouge&quot;&gt;show spanning-tree vlan 2&lt;/code&gt; but it will actually affect the forwarding decision on the downstream connected switch.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>STP Root Bridge Election</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/20/STP-Root-Bridge-Election/"/>
   <updated>2017-03-20T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/20/STP-Root-Bridge-Election</id>
   <content type="html">&lt;p&gt;STP Root Bridge Election is based on the Bridge ID of the switches in the active Layer 2 domain. The Bridge ID is made up of the 4-bit bridge priority, a 12-bit Systems ID, and the 48-bit MAC address. The bridge priority is configurable from 0 to 61440. The default is 32768. The System ID is taken from the VLAN number (IEEE 802.1t).&lt;/p&gt;

&lt;p&gt;The election process is very simple. Each bridge starts off assuming it is the Root Bridge and sends BPDUs out advertising itself as such. If it receives a superior BPDU (a BPDU that has a Bridge ID lower than its current root bridge Bridge ID), it ceases advertising that Root Bridge and begins advertising the new Root Bridge with the lower Bridge ID. This process continues until all switches in the domain agree to the same Root Bridge.&lt;/p&gt;

&lt;p&gt;Note that since MAC addresses are guaranteed to be unique, there will always be 1 Root Bridge elected. If all switches are set to the default priority, then the switch with the lowest MAC Address will become the Root Bridge. this is a bad idea for many reasons. One, you typically want your distribution layer switch to be the Root Bridge. Second, older switches will have lower MAC addresses, so your switch with the least resources ends up having a heavier load along with a higher chance for failure&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>STP Root Bridge Election</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/20/STP-Port-Election/"/>
   <updated>2017-03-20T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/20/STP-Port-Election</id>
   <content type="html">&lt;p&gt;After the election of the STP Root Bridge, all ports in the Layer 2 Switch topology will need to be assigned a state. The steps can be listed as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;All ports on the Root Bridge become Designated Ports&lt;/li&gt;
  &lt;li&gt;On each non-root switch, exactly ONE port is elected as the &lt;em&gt;Root Port&lt;/em&gt; which is the port having the lowest path-cost to the Root Bridge.&lt;/li&gt;
  &lt;li&gt;Each segment between switches will have one Designated Port which is the port on the segment that has the lowest path-cost to reach the root bridge.&lt;/li&gt;
  &lt;li&gt;The Root and Designated Ports are placed into a Forwarding State.&lt;/li&gt;
  &lt;li&gt;The ports that are not Root ports or Designated Ports will be placed in the Blocking State. These are displayed in show commands with an A for Alternate.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is helpful to remember that Designated Ports lead away from the Root Bridge, while Root Ports lead toward the Root Bridge.&lt;/p&gt;

&lt;p&gt;What are the tiebreakers for Root Ports and Designated Ports?&lt;/p&gt;

&lt;p&gt;The tiebreaker for Spanning Tree decisions is as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Lowest root bridge ID (used for root bridge election)&lt;/li&gt;
  &lt;li&gt;Lowest path cost to root bridge&lt;/li&gt;
  &lt;li&gt;Lowest sender bridge ID (used when a switch is connected to two switches through which it has equal cost to reach the root bridge)&lt;/li&gt;
  &lt;li&gt;Lowest sender port ID (when the switch has two interfaces connecting to the same switch and the cost to reach the root bridge is the same through either interface, it will use the interface with the lowest number as the root port (or designated port).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is helpful to keep in mind for elections that there is only one bridge that originates BPDUs - the root bridge. Other bridges update some fields (such as Sending Bridge ID, Message Age, etc) when retransmitting out their designated ports.&lt;/p&gt;

&lt;p&gt;The access ports will be designated ports typically and will send BPDUs toward the host, unless BPDU Filter is set.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree Types</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/17/Spanning-Tree-Types/"/>
   <updated>2017-03-17T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/17/Spanning-Tree-Types</id>
   <content type="html">&lt;p&gt;There are several different versions of the Spanning Tree Protocol that we will come across. We will review them in chronological order today.&lt;/p&gt;

&lt;p&gt;The original spanning tree is Common Spanning Tree, or CST. It was defined with IEEE 802.1D. The basic premise is to create a logical loop free topology for Ethernet networks by building a spanning tree of connected layer-2 bridges. The links that are not part of the spanning tree are disabled, leaving a single active path between any two network nodes.&lt;/p&gt;

&lt;p&gt;PVST and PVST+ are both Cisco proprietary protocols. Cisco developed them as they believed we may need different spanning-trees on a per-VLAN basis for  the best path flow. PVST only ran over ISL trunks, but with PVST+ compatibility with 802.1q trunks arrived. The + version also added new features such as UplinkFast, BackboneFast, and PortFast.&lt;/p&gt;

&lt;p&gt;RSTP is the IEEE’s answer to Cisco’s PVST+ implementation. RSTP took many of the added features of PVST+ and standardized them into IEEE 802.1w. RSTP added new bridge port roles and port states.&lt;/p&gt;

&lt;p&gt;Cisco then responded to the IEEE 802.1w Rapid Spanning Tree Protocol with RPVST+, which is just RSTP with per-vlan support. RPVST+ supports both ISL and 802.1Q trunks.&lt;/p&gt;

&lt;p&gt;When the concept of VLANs finally hit home when VoIP hit the LAN, everyone finally agreed that we needed VLAN support for STP. However, it was also determined that there are usually on three paths needed to support redundancy with Spanning Tree designs. But yet with Spanning Trees based on a per-VLAN approach, we may end up with way more than 3 instances of Spanning Tree running on the router.&lt;/p&gt;

&lt;p&gt;This led to the introduction of Multiple Spanning Tree Protocol. It was originally defined with 802.1s and was later merged into IEEE 802.1Q-2005. MSTP creates on common Spanning Tree for the entire Layer 2 network. If a network contains multiple VLANs, we can create multiple Spanning Trees and then assign specific VLANs to specific Spanning Tree instances. Since most networks will need a maximum of two Spanning Tree instances, MSTP greatly reduces the overhead on the router compared to RPVST which needed a separate instance per VLAN.&lt;/p&gt;

&lt;p&gt;Cisco MST supports both 802.1Q and ISL trunks.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Virtual Switch System</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/13/VSS/"/>
   <updated>2017-03-13T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/13/VSS</id>
   <content type="html">&lt;p&gt;VSS, or Virtual Switch System, exists in Cisco Catalyst 6500 and 4500 switches running IOS-XE. VSS simplifies the network by reducing the number of network elements. VSS can combine multiple Catalyst Switches into a single logical device. VSS logically combines a pair of switches into a single network element.&lt;/p&gt;

&lt;p&gt;The two switches in the pair negotiate their roles - one will assume the role of the active switch while the other assumes the role of the standby switch. The VSS active switch controls the VSS, running the Layer 2 and Layer 3 protocols for both switches. Both switches perform packet forwarding as needed, but the standby switch sends all control traffic to the VSS active switch for processing.&lt;/p&gt;

&lt;p&gt;The virtual switch link (VSL) is the link which ties the active and standby switches together. It is typically implemented as an EtherChannel, and therefore can support up to 8 links in the bundle. The attached devices (such as access switches) can then connect to the VSS using Multichassis EtherChannel. Unlike normal EtherChannel witch connects multiple links between two switches, MultiChassis EtherChannel can connect one switch over multiple links to two switches. In total, a VSS can support up to 256 EtherChannels in a combination of regular EtherChannels and MultiChassis EtherChannels (MEC).&lt;/p&gt;

&lt;h4 id=&quot;configuration&quot;&gt;Configuration&lt;/h4&gt;

&lt;p&gt;Both switches in a VSS pair need to belong to the same VSS domain. This domain is a number between 1 and 255. After creating the domain, you must configure one switch to be switch number 1 and the other switch to be switch number 2.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# switch virtual domain 10
SW1(config-vs-domain)# switch 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2(config)# switch virtual domain 10
SW2(config-vs-domain)# switch 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next you should create the VSL between the two VSS switches.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface port-channel 5
SW1(config-if)# switchport
SW1(config-if)# switch virtual link 1
SW1(config-if)# no shutdown
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2(config)# interface port-channel 10
SW2(config-if)# switchport
SW2(config-if)# switch virtual link 2
SW2(config-if)# no shutdown
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, you have to put the physical interfaces into the appropriate port-channels created for the VSL.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# int range gig1/0-3
SW1(config-if-range)# switchport mode trunk
SW1(config-if-range)# channel-group 5 mode on
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# int range gig1/0-3
SW1(config-if-range)# switchport mode trunk
SW1(config-if-range)# channel-group 10 mode on
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, to complete the switch conversion process you need to run the following command on each switch:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# switch convert mode virtual
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2# switch convert mode virtual
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The switch will reload and when they come back up they will now be part of the VSS domain.&lt;/p&gt;

&lt;p&gt;Some sample show commands are:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# show switch virtual

SW1# show switch virtual role

SW1# show switch virtual link

SW1# show switch virtual link port-channel
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>SPAN Configuration</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/11/SPAN-Configuration/"/>
   <updated>2017-03-11T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/11/SPAN-Configuration</id>
   <content type="html">&lt;p&gt;Basic SPAN Configuration:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# monitor session 1 source interface fa0/12
SW1(config)# monitor session 1 destination interface fa0/24
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Here is an example where we will only monitor respective traffic from fa0/18 and only monitor sent traffic from interface fa0/19. Additionally we will filter (remove) VLANs 1 through 3. Finally, we will preserve the encapsulation from the sources:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# monitor session 1 source interface fa0/18 rx
SW1(config)# monitor session 1 source interface fa0/19 tx
SW1(config)# monitor session 1 filter vlan 1-3
SW1(config)# monitor session 1 destination interface fa0/24 encapsulation replicate
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next we have a RSPAN sample configuration. We will monitor all traffic on VLANs 66-68 on SW1 and send it to VLAN 199, which will then be delivered to port fa0/24 on SW2:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# vlan 199
SW1(config-vlan)# remote span
SW1(config-vlan)# exit
SW1(config)# monitor session 1 source vlan 66-68
SW1(config)# monitor session 1 destination remote van 199
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2(config)# vlan 199
SW2(config-vlan)# remote span
SW2(config-vlan)# exit
SW2(config)# monitor session 2 source remote vlan 199
SW2(config)# monitor session 2 destination interface fa0/24
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notice above that the monitor session numbers do not have to match on each switch.&lt;/p&gt;

&lt;p&gt;Finally, we have a ERSPAN example. We will configure R1 to capture received traffic and send it to SW1 gig2/1.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1(config)# monitor session 1 type erspan-source
R1(config-mon-erspan-src)# source interface gig1/1 rx
R1(config-mon-erspan-src)# no shutdown
R1(config-mon-erspan-src)# destination
R1(config-mon-erspan-src-dst)# erspan-id 101
R1(config-mon-erspan-src-dst)# ip address 10.1.1.1
R1(config-mon-erspan-src-dst)# origin ip address 172.16.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# monitor session 2 type erspan-destination
SW1(config-mon-erspan-dst)# destination interface gig2/1
SW1(config-mon-erspan-dst)# no shutdown
SW1(config-mon-erspan-dst)# source
SW1(config-mon-erspan-dst-src)# erspan-id 101
SW1(config-mon-erspan-dst)# ip address 10.1.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A couple of configuration notes. First, you must make sure the destination port is not in a shutdown state or else the SPAN session will not come up.&lt;/p&gt;

&lt;p&gt;If you want to leave the original encapsulation of the frames intact, use the &lt;code class=&quot;highlighter-rouge&quot;&gt;encapsulation replicate&lt;/code&gt; option on the monitor session destination command.&lt;/p&gt;

&lt;p&gt;One confusing option is the &lt;code class=&quot;highlighter-rouge&quot;&gt;ingress dot1q vlan 10&lt;/code&gt; option on the destination interface. This is actually telling the switch to accept incoming frames on the &lt;em&gt;destination&lt;/em&gt; monitor switch and place the frames in VLAN 10. This would let you use the destination port like a normal access port. Seems kind of silly to me as to why you would want to do that, but I am sure there is a reason.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`monitor session 1 destination interface gig0/24 ingress dot1q vlan 146
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`The above accepts inbound packets with 802.1Q encapsulation with the given VLAN as the default VLAN. Compare that to the example below, which accepts incoming packets with untagged encapsulation type with the specified VLAN as the default VLAN.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`monitor session 1 destination interface gig0/24 ingress vlan 146
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
To view the session, simply use &lt;/code&gt;show monitor session 1`.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>SPAN</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/09/SPAN/"/>
   <updated>2017-03-09T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/09/SPAN</id>
   <content type="html">&lt;p&gt;SPAN stands for Switch Port Analyzer. It is a way to direct all traffic from a source port or source VLAN to a single port. Some uses include IDS/IPS, VoIP Call recording, or troubleshooting / analysis.&lt;/p&gt;

&lt;p&gt;If the destination port is on the local switch, we say it is in SPAN operation mode. The destination port could also be mapped to a port on a remote switch, in which case we call it Remote SPAN or RSPAN. In RSPAN, a specific VLAN must be configured across the entire switching path from the source port or VLAN to the RSPAN destination port. So the source is still at least one port or at least one VLAN,  but the destination is always the RSPAN VLAN. At the switch where the RSPAN destination port exists, the RSPAN VLAN is delivered to the RSPAN port.&lt;/p&gt;

&lt;p&gt;Encapsulated Remote SPAN (ERSPAN) is a variant of RSPAN in which we are encapsulating the Remote SPAN information. ERSPAN creates a GRE tunnel for all captured traffic and allows it to be extended across Layer 3 domains. This became an option with IOS-XE.&lt;/p&gt;

&lt;p&gt;Regardless of the type of SPAN we are running, the source port can be any type of port including EtherChannel, trunk port, routed port, etc. When using a VLAN as the source, all active ports in that VLAN are monitored, and the monitored ports are updated dynamically as membership to that VLAN changes. A port configured as a SPAN destination cannot be part of a SPAN source VLAN.&lt;/p&gt;

&lt;p&gt;It is important to understand that when you configure a SPAN destination port, the existing configuration is removed but is restored if you later remove the SPAN configuration. The destination port does not support any security, nor does it support any Layer 2 protocols such as CDP, VTP, etc. If the destination port was part of an EtherChannel, it will be removed from the EtherChannel once the SPAN configuration is applied.&lt;/p&gt;

&lt;p&gt;There are a number of restrictions with SPAN including:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the source can be one or more ports or a VLAN, but not both&lt;/li&gt;
  &lt;li&gt;up to 64 destination ports can be configured on a switch&lt;/li&gt;
  &lt;li&gt;you must be careful not to overload the destination port, especially if a VLAN is being monitored.&lt;/li&gt;
  &lt;li&gt;within a single SPAN session, you cannot deliver traffic to a destination port when it is sourced by a mix of SPAN, RSPAN, or ERSPAN source ports or VLANs. This usually comes into play when you want to mirror source traffic to both a local port on a switch (SPAN mode) and a remote port on another switch (RSPAN mode).&lt;/li&gt;
  &lt;li&gt;only one SPAN/RSPAN/ERSPAN session can send traffic to a single destination port&lt;/li&gt;
  &lt;li&gt;if you use a trunk port as a SPAN or RSPAN source, then by default all VLANs on the trunk are monitored by default&lt;/li&gt;
  &lt;li&gt;traffic that is routed from another VLAN to a source VLAN cannot be monitored with SPAN&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, SPAN, RSPAN, and ERSPAN support three types of traffic: transmitted, received, and both (default). If you set a SPAN to monitor just receive or just transmit, some conditions apply:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;for Receive (RX) the goal is to deliver all traffic that is received by the SPAN source. As a result, each frame that is received by the source port or VLAN is copied to the destination port or VLAN &lt;em&gt;before&lt;/em&gt; any modifications are made to the frame (such as ACL filtering, QoS, etc)&lt;/li&gt;
  &lt;li&gt;for Transmit (TX), all relevant filtering or modification to the frame is done before the switch forwards the traffic to the SPAN or RSPAN destination.&lt;/li&gt;
  &lt;li&gt;SPAN usually ignores certain Layer 2 frames like CDP, BPDUs, etc. However, SPAN can be configured to forward that traffic to the destination port/VLAN with the &lt;code class=&quot;highlighter-rouge&quot;&gt;encapsulation replicate&lt;/code&gt; command&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree Intro</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/08/Spanning-Tree-Intro/"/>
   <updated>2017-03-08T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/08/Spanning-Tree-Intro</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;https://networklessons.com/wp-content/uploads/2013/01/switches-redundant-cable-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Imagine in the above diagram that H1 sends out an ARP request, which is a broadcast frame. SW1 will forward this broadcast frame on ports Fa0/0 and Fa1/0 toward SW2.&lt;/p&gt;

&lt;p&gt;SW2 will forward the broadcast frame it received on Fa0/0 out Fa1/0 and the interface connected to H2. This cycle will continue and continue. By introducing redundancy, we have created an environment that is friendly to Layer 2 loops. And since Ethernet frames do not have a TTL, they will loop around forever.&lt;/p&gt;

&lt;p&gt;Spanning Tree is a Layer 2 protocol that was created to deal with the possible loop creation that is introduced with redundant Layer 2 loops. Spanning Tree takes over the Layer 2 forwarding decisions, and places certain ports in a blocking state to prevent the possibility of these loops occurring.&lt;/p&gt;

&lt;p&gt;When Spanning Tree is enabled, switches send out a special frame called a BPDU (Bridge Protocol Data Unit). Included in this BPDU is the Switch’s Priority and MAC Address, which concatenated equals the Bridge Id. Among connected Switch’s, the Switch with the lowest Bridge Id becomes the Root Bridge.&lt;/p&gt;

&lt;p&gt;A Root Bridge marks all of its ports as Designated, which are placed in a forwarding state. Designated ports lead away from the Root bridge.&lt;/p&gt;

&lt;p&gt;For the remaining switches, we have to elect one root port on each switch. The root port will be the port whose path has the lowest cost to the root bridge&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Common Spanning Tree</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/08/CST/"/>
   <updated>2017-03-08T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/08/CST</id>
   <content type="html">&lt;p&gt;Common Spanning-Tree (CST) assumes one spanning-tree instance for the entire bridged network, regardless of the number of VLANs. Running only one instance reduces CPU load. All CST BPDUs are sent over trunks using the native VLAN with untagged frames.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>UDLD</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/07/UDLD/"/>
   <updated>2017-03-07T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/07/UDLD</id>
   <content type="html">&lt;p&gt;UDLD, or Unidirectional Link Detection, is a Cisco proprietary, Layer 2 protocol that helps detects if either the transmit or the receive fails on a link. It’s purpose is similar to LoopGuard, but it is completely independent of Spanning Tree. The operation of UDLD is fairly simple. A switch sends UDLD Hellos and if it receives echoes of those Hellos back it knows the link is an active two way link. As soon as it quits receiving the UDLD Hellos, it knows there must be a unidirectional link failure. UDLD operates at the physical port level, compared to say STP LoopGuard which works at the logical port level (EtherChannel). Also UDLD functions at linkup, while LoopGuard does not. It is recommended to enable both UDLD and LoopGuard.&lt;/p&gt;

&lt;p&gt;UDLD is mainly used on fiber connections, but it can also be useful on Ethernet connections that have dumb devices in the middle such as media converters.&lt;/p&gt;

&lt;p&gt;The default advertisement timer is 15 seconds and the hold time is 5 seconds. Upon detecting the loss of a UDLD neighbor, UDLD will send seven additional advertisements (one per second). If no reply is received, the link’s bidirectional status transitions to unknown.&lt;/p&gt;

&lt;p&gt;To set up UDLD globally, use &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1(config)# udld enable&lt;/code&gt; and use the &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1(config-if)# udld port enable&lt;/code&gt; command to enable per interface. Use &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1(config)# udld enable aggressive&lt;/code&gt; if you want the ports to be shut down upon UDLD neighbor failure.&lt;/p&gt;

&lt;p&gt;In order to reset an interface that was shut down by UDLD, use &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# udld reset&lt;/code&gt;, or the typical shut / no shut commands.&lt;/p&gt;

&lt;p&gt;You could also enable auto recovery of the interface if desired. It would look like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# errdisable recovery cause idled
SW1(config)# errdisable recovery interval 30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>LLDP</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/06/LLDP/"/>
   <updated>2017-03-06T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/06/LLDP</id>
   <content type="html">&lt;p&gt;LLDP is the IEEE equivalent of CDP. It’s development was due to Cisco’s deployment of CDP, so the IEEE sought to make a universal version. It is very similar to CDP and many of the Cisco commands for LLDP are the same commands as those for CDP, just substituting lldp for cdp. Like CDP, LLDP is a link layer protocol, but unlike CDP it is specifically for Ethernet networks. LLDP is described under IEEE 802.1AB LLDP.&lt;/p&gt;

&lt;p&gt;LLDP, like CDP, also uses TLVs to describe neighbor devices and capabilities.&lt;/p&gt;

&lt;p&gt;One additional feature LLDP includes is that LLDP has a TLV for an interface description, so if you set a description with &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1#(config-if) description LINK_SW1_SW2&lt;/code&gt;, that description would show up under Switch 2 LLDP like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2# show lldp neighbors detail

Chasis id: 0019.569d.571a
Port id: Fa0/24
Port Description: LINK_SW1_SW2
System Name: SW1.cisco.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;An enhancement was made to LLDP that allows you to use LLDP for VLAN assignment or POE requirements. This enhanced version is known as LLDP-MED (Media Endpoint Discovery).&lt;/p&gt;

&lt;p&gt;One difference between CDP and LLDP is that with LLDP the Hello timer is set to 30 seconds by default and the hold time is set to 4 times the Hello time. CDP is 60 seconds and the hold timer is 3 times the Hello time, as a reminder. Another difference is that LLDP has a reinitialization delay (default 2 seconds).  This is the time that an LLDP port waits before reinitializing LLDP transmission. The command to set the reinitialization period is &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1#(config) lldp reinit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can also set LLDP up to only transmit and not receive LLDP packets. This is done by using the &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1#(config) no lldp receive&lt;/code&gt; command. You can also do this on a per-interface basis. Likewise, you can also disallow sending LLDP packets with the &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1#(config) no lldp transmit&lt;/code&gt; command, which can also be done at the interface level.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CDP Configuration</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/06/CDP-Configuration/"/>
   <updated>2017-03-06T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/06/CDP-Configuration</id>
   <content type="html">&lt;p&gt;To enable CDP globally we use &lt;code class=&quot;highlighter-rouge&quot;&gt;cdp run&lt;/code&gt;. To enable CDP on a per-interface basis, use &lt;code class=&quot;highlighter-rouge&quot;&gt;cdp enable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) cdp timer seconds&lt;/code&gt;  specifies the frequency of CDP update transmissions.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) cdp holdtime seconds&lt;/code&gt; specifies the amount of time a receiving device should hold the information sent by your device before discarding it.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) no cdp adertise-v2&lt;/code&gt; disables the advertisement of CDPv2 advertisements if for some crazy reason you need to.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) clear cdp counters&lt;/code&gt; resets the traffic counters to zero.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) clear cdp table&lt;/code&gt; deletes the CDP table of information about neighbors&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) show cdp&lt;/code&gt; displays the interval between CDP transmissions, the number of seconds a CDP advertisement is valid for a given port, and the version of the advertisement&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) show cdp interface [type number]&lt;/code&gt; displays information about interfaces on which CDP is enabled&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) show cdp entry device-name&lt;/code&gt; displays information about a specific neighbor&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>CDP Basics</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/06/CDP-Basics/"/>
   <updated>2017-03-06T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/06/CDP-Basics</id>
   <content type="html">&lt;p&gt;CDP is a layer 2, Cisco proprietary device discovery protocol. Even though it is a Layer 2 protocol, it provides information about Layer 3 protocols (such as IP address). CDP operates by its member devices sending multicasts to the link-local multicast address 01:00:0c:cc:cc:cc (same as VTP). The member devices listen for multicasts at that address, process them accordingly, and store the information in a local table. The announcements are sent out every 60 seconds by default.&lt;/p&gt;

&lt;p&gt;SNAP (Subnetwork Access Protocol) is required to run CDP, so effectively CDP can run on any data-link protocol that supports SNAP. Ethernet, Frame Relay, and ATM are example medias that support SNAP and thus CDP.&lt;/p&gt;

&lt;p&gt;CDP relays the information about devices by Type-Length-Value (TLV) fields in the CDP packets. The &lt;em&gt;Length&lt;/em&gt; is the length (in bytes) of the Type-Value-Length fields. The Type and Value fields are described below.&lt;/p&gt;

&lt;h4 id=&quot;type&quot;&gt;Type&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Device ID - 0x0001&lt;/li&gt;
  &lt;li&gt;Address - 0x0002&lt;/li&gt;
  &lt;li&gt;Port ID - 0x0003&lt;/li&gt;
  &lt;li&gt;Capabilities - 0x0004&lt;/li&gt;
  &lt;li&gt;Version - 0x0005&lt;/li&gt;
  &lt;li&gt;Platform - 0x0006&lt;/li&gt;
  &lt;li&gt;IP Prefix - 0x0007&lt;/li&gt;
  &lt;li&gt;VTP Management Domain - 0x0009 {: .red}&lt;/li&gt;
  &lt;li&gt;Native VLAN - 0x000a {: .red}&lt;/li&gt;
  &lt;li&gt;Duplex Status - 0x000b {: .red}&lt;/li&gt;
  &lt;li&gt;Appliance ID - 0x000c {: .red}&lt;/li&gt;
  &lt;li&gt;Power consumption - 0x0010 {: .red}&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;value&quot;&gt;Value&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Device ID - MAC address in ASCII or the FQDN&lt;/li&gt;
  &lt;li&gt;Address&lt;/li&gt;
  &lt;li&gt;Port ID - ASCII string that names the port from which the message was sent&lt;/li&gt;
  &lt;li&gt;Capabilities - has a value describing the device capabilities:
    &lt;ul&gt;
      &lt;li&gt;0x01 - level 3 routing&lt;/li&gt;
      &lt;li&gt;0x02 - level 2 transparent bridging&lt;/li&gt;
      &lt;li&gt;0x04 - level 2 source-route bridging&lt;/li&gt;
      &lt;li&gt;0x08 - level 2 switching not running Spanning Tree&lt;/li&gt;
      &lt;li&gt;0x10 - sends and receives packets for a network layer protocol&lt;/li&gt;
      &lt;li&gt;0x20 - the device does not forward IGMP reports&lt;/li&gt;
      &lt;li&gt;0x40 - level 1 function&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Version - software version running the device&lt;/li&gt;
  &lt;li&gt;Platform - ASCII string describing the device (e.g. Cisco 7000)&lt;/li&gt;
  &lt;li&gt;IP Prefix - a set of 0 or more IP Prefixes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Switches see the MAC multicast address used by CDP as a special address and will not forward it out of other interfaces on a switch. Routers do not forward layer 2 frames out of their interfaces ever, so therefore only directly connected neighbors receive the CDP advertisement.&lt;/p&gt;

&lt;p&gt;The beauty of CDP is that if you walk into a network and you do not know the topology, you can use CDP to quickly learn the entire layout of the network (as long as all the devices are Cisco!).&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>MultiChassis EtherChannel</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/27/EtherChannel-MultiChassis/"/>
   <updated>2017-02-27T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/27/EtherChannel-MultiChassis</id>
   <content type="html">&lt;p&gt;A LAG bundle to the same access switch results in Fate Sharing for the links in the bundle. The alternative is to break the links out of the LAG, and have the NICs of a server connect to two different access switches. But by breaking the LAG, we now have half the available bandwidth for the server.&lt;/p&gt;

&lt;p&gt;With MultiChassis EtherChannel, we trick the server into running LAG between two different access switches. There are multiple ways to do this using different protocols made by different vendors. We generically call it MLAG.&lt;/p&gt;

&lt;p&gt;The protocol must take a physical triangle as seen below, and make it into a logical point-to-point. Many problems arise that the protocol must deal with. If NIC A sends traffic to Switch A, Switch A must know not to send that to Switch B, or else a loop might form.
&lt;img src=&quot;http://www.cisco.com/c/dam/en/us/td/i/200001-300000/220001-230000/226001-227000/226936.eps/_jcr_content/renditions/226936.jpg&quot; alt=&quot;&quot; /&gt;
The protocols are so customized, that different platforms from the same vendor cannot even run MLAG. The control place has to be identical. Cisco therefore has a couple of implementations.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Stackwise Cross-Stack EtherChannel&lt;/em&gt; has control plane over dedicated stacking cables. These stack cables create a bidirectional closed loop as seen below. One control plane is shared amongst members as well as one management plane. So if you were to log into one switch, you are actually viewing the configuration for the stack. This is used on the Access Platforms such as Catalyst 3750/3850. StackWise can have more than 2 members, up to the stack limit
&lt;img src=&quot;https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcRguQ7GRPRoSYAmPfJ4MCMN2r160qFDougT6yyluxFXu6n42Foxgg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Virtual Switching System (VSS)&lt;/em&gt; is used on the aggregation platforms such as Catalyst 4500/6500/6800. VSS is similar to Stackwise as there is one management plane and one control plane shared between connected switches. Typically with VSL, the links are going to be 2x10G LAG. VSS switches are udeployed in pairs and will usually have 1 active supervisor and 3 standby supervisors.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Virtual Port Channel (vPC)&lt;/em&gt; is very similar to VSS but it runs on the Data Center platforms such as Nexus 5000/7000/9000. The control plane is synchronized over a vPC Peer Link, which are typically 2x10GigE LAG. The biggest difference between vPC and VSS, is that vPC has &lt;em&gt;2&lt;/em&gt; independent control planes and &lt;em&gt;2&lt;/em&gt; independent management planes. vPC like VSS is deployed in pairs.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>EtherChannel PaGP</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/26/EtherChannel-PAgP/"/>
   <updated>2017-02-26T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/26/EtherChannel-PAgP</id>
   <content type="html">&lt;p&gt;Port Aggregation Protocol (PAgP) is a Cisco proprietary protocol that is only supported on Cisco switches.&lt;/p&gt;

&lt;p&gt;The two modes of PAgP are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;auto: places a port into a passive negotiating state&lt;/li&gt;
  &lt;li&gt;desirable: places a port into active negotiating state&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For Layer 2 EtherChannels, the first port that comes up lends its MAC address to the EtherChannel.&lt;/p&gt;

&lt;p&gt;PAgP supports up to 8 Ethernet ports of the same type.&lt;/p&gt;

&lt;p&gt;For all EtherChannels (including on and PAgP), when a group is first created, all ports follow the parameters set for the first port to be added to the group. If you change the configuration of any of these parameters, you must also make changes to all ports in the group:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Allowed-VLAN list&lt;/li&gt;
  &lt;li&gt;Spanning-tree path cost for each VLAN&lt;/li&gt;
  &lt;li&gt;Spanning-tree port priority for each VLAN&lt;/li&gt;
  &lt;li&gt;Spanning-tree Port Fast setting&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For all Layer 2 EtherChannels, if the ports are access ports they must all be in the same VLAN.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>EtherChannel Load-Balancing</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/26/EtherChannel-Load-Balancing/"/>
   <updated>2017-02-26T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/26/EtherChannel-Load-Balancing</id>
   <content type="html">&lt;p&gt;The balancing method is locally significant and outbound. So it is OK for one side of a LAG to be src-MAC and the other side to be dest-IP.&lt;/p&gt;

&lt;p&gt;To configure the load-balancing method by using the&lt;code class=&quot;highlighter-rouge&quot;&gt;port-channel load-balance&lt;/code&gt; global configuration command. EtherChannel load-balancing can use MAC Address or IP address, source or destination address, or both source and destination address.&lt;/p&gt;

&lt;p&gt;The selected load balancing mode applies to all ether channels on a switch.&lt;/p&gt;

&lt;p&gt;With source-MAC address forwarding, packets are distributed across the ports based on the source-MAC of the &lt;em&gt;incoming&lt;/em&gt; packet. So packets from the same host use the same port in the channel.&lt;/p&gt;

&lt;p&gt;With destination-MAC address forwarding, packets are distributed across the ports of the channel based on the destination-MAC of the incoming packet. So packets destined to the same host use the same port in the channel.&lt;/p&gt;

&lt;p&gt;With source-and-destination MAC address forwarding, packets are distributed across the ports in a channel based on both the source and the destination MAC address. This is often used if it is not clear whether source-MAC or destination-MAC would be more appropriate.&lt;/p&gt;

&lt;p&gt;IP based forwarding has the same principles as the MAC based forwarding outlined above.&lt;/p&gt;

&lt;p&gt;To chose the appropriate load-balancing method, you must analyze the position of the EtherChannel in the network. For example, if you have 4 hosts going towards one router, you would be much better load-balancing based on source-MAC  than destination-MAC from the switch. On the router, you will be better off using destination-MAC.&lt;/p&gt;

&lt;p&gt;To configure EtherChannel load-balancing, in global config use the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`port-channel load-balance {dst-ip | dst-mac | src-dst-ip | src-dst-mac | src-ip | src-mac}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
The default is src-mac.&lt;/p&gt;

&lt;p&gt;One negative of EtherChannel is that flows cannot exceed the bandwidth of an individual link. EtherChannel adds lanes to the highway but it doesn’t increase the speed limit.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>EtherChannel LACP</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/24/EtherChannel-LACP/"/>
   <updated>2017-02-24T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/24/EtherChannel-LACP</id>
   <content type="html">&lt;p&gt;LACP is the IEEE standard for establishing a single logical channel out of several physical ports. It is popular as it can be used in mixed-vendor switch environments. LACP ensures that when an EtherChannel is created, all physical members all have the same speed, duplex, link-type, and VLAN information. LACP is a control protocol for LAG. The official name is IEEE 802.3ad Link Aggregation (LAG).&lt;/p&gt;

&lt;p&gt;LACP supports up to 16 Ethernet ports of the same type. Up to eight ports can be active, and up to eight ports can be in standby mode.&lt;/p&gt;

&lt;p&gt;LACP assigns system priority, port priority, and and an administrative key.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;System priority&lt;/em&gt; and the MAC address form the System ID. Between two LACP neighbors, the switch with the lowest System ID will be the decision maker using the LACP Port Priority&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Port priority&lt;/em&gt; and the port number form the port identifier. The switch uses the port identifier to decide which ports to put in standby mode when a hardware limitation prevents all ports from aggregating. Port priority is also used when more than 8 physical ports are put into a channel group. Port priority will decide which 8 ports will be the active ports in the etherchannel.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Administrative key&lt;/em&gt; defines the capabilities of a port to aggregate with other ports, based on the port’s physical characteristics.&lt;/p&gt;

&lt;p&gt;Sample Configuration:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# interface range GigabitEthernet0/1-2
SW1# channel-group 1 mode active
SW1# exit
SW1# interface port-channel 1
SW1# switchport trunk encapsulation dot1q
SW1# switchport mode trunk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2# interface range GigabitEthernet0/1-2
SW2# channel-group 1 mode active
SW2# exit
SW2# interface port-channel 1
SW2# switchport trunk encapsulation dot1q
SW2# switchport mode trunk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can also start with the &lt;code class=&quot;highlighter-rouge&quot;&gt;interface port-channel 1&lt;/code&gt; command and then define the channel group. For Layer 3 ether channel, you would want to define the port-channel first and then issue the &lt;code class=&quot;highlighter-rouge&quot;&gt;no switchport&lt;/code&gt; interface command.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;interface port-channel 1&lt;/code&gt; is the logical interface. The channel-group command binds the logical interface to a physical port. The port-channel interface (numbered 1 - 48) correspond to the one specified with the channel-group interface configuration command.&lt;/p&gt;

&lt;p&gt;A successful Layer 2 EtherChannel will show SU with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;show etherchannel summary&lt;/code&gt;. An unsuccessful layer 2 will show SD.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MST IST-CIST</title>
   <link href="http://bsrandall.github.io/mst/2017/02/23/MST-IST-CIST/"/>
   <updated>2017-02-23T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/mst/2017/02/23/MST-IST-CIST</id>
   <content type="html">&lt;p&gt;IST is the Internal Spanning Tree, also known as instance 0. This instance is designated to carry all STP information, including information from other instances. MSTP does not send BPDUs for ever instance separately - these are all contained within the IST BPDU.&lt;/p&gt;

&lt;p&gt;To accommodate, the other instances information is carried within the IST BPDU using special M-Record fields - one for every active MSTI. These fields carry carry MSTP information such as bridge priority, root path cost, and port priority.&lt;/p&gt;

&lt;p&gt;IST also plays a huge role in multiple MSTP region configurations. When a switch receives a BPDU from another region, it marks the corresponding port as MSTP &lt;em&gt;boundary&lt;/em&gt;. The interconnected, different region switches then form a CIST spanning across the regions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.ine.com/wp-content/uploads/2010/02/mstp-3-multi-region-physical-topology.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Remember, an IST is internal to a region while a CIST is the IST spanning across multiple regions.&lt;/p&gt;

&lt;p&gt;Here is a sample MST BPDU:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.ine.com/wp-content/uploads/2010/02/mstp-3-multi-region-cst-mstp-packet-format.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The CIST Root is elected among all regions while the CIST Regional Root is elected in every region. The IST Root = CIST Regional Root in cases where multiple MST regions interoperate. The CIST Root is the bridge that has the lowest Bridge Id among all regions - the CIST Root could be a bridge inside a region or a boundary switch in a region. The CIST Regional Root is a &lt;em&gt;boundary switch&lt;/em&gt; elected for every region based on the shortest external path cost to reach the CIST Root. As mentioned above, it is important to remember that the CIST Regional Root becomes the root of the IST for the given region as well - the region changes its IST election process to make the CIST Regional Root the IST root.&lt;/p&gt;

&lt;p&gt;When an MST switch boots up, it declares itself the CIST Root and CIST Regional Root and announce that it its outgoing BPDUs on all internal ports. On boundary ports (those that have received BPDUs from another region), the switch will only advertise its CIST Root Bridge ID and CIST External Root Path Cost, hiding the details of the region’s inner topology.&lt;/p&gt;

&lt;p&gt;The region that contains the CIST Root automatically places all of its boundary ports in an unblocked state.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;CIST External Root Path Cost&lt;/em&gt; is the cost to reach the CIST Root across the links connecting the boundary ports. When a BPDU is received on an internal link, this cost is not changed.&lt;/p&gt;

&lt;p&gt;Only a boundary switch can be elected as the CIST Regional Root, and this is the switch with the lowest cost to reach the CIST Root. If a boundary switch receives a BPDU with a lower CIST External Root Path cost on one of its internal ports, it will stop announcing itself as the CIST Regional Root and start announcing the new metric out of its boundary ports.&lt;/p&gt;

&lt;p&gt;If a switch is a CIST Regional Root, it elects one of its boundary ports as the CIST Root port and blocks all other boundary ports. If a boundary switch is not the CIST Regional Root, it will mark its boundary ports as Designated or Alternate, Designate only if it has a better External Root Path cost or in case of a tie, lower CIST Regional Root Bridge ID.&lt;/p&gt;

&lt;p&gt;The regional MSTIs are constructed independently at every region, but they have to be mapped to the CIST at the boundary ports. This equates to the inability to load-balance VLAN traffic on the boundary links by mapping VLANs to different instances.&lt;/p&gt;

&lt;p&gt;A topology change in the CST could change all paths in the topology thus requiring massive MAC address relearning.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>EtherChannel</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/23/EtherChannel-General/"/>
   <updated>2017-02-23T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/23/EtherChannel-General</id>
   <content type="html">&lt;p&gt;LAG goal is to trick our Spanning Tree Protocol into forwarding active/active across multiple links. The risk we take is an infinite loop in the data plane, as there is no TTL with Ethernet. The LAG negotiation protocols help to mitigate this risk. Static LAG is supported but not recommended, as a failure to LAG can cause an STP Loop. If you do deploy Static LAG, it is recommended to deploy EtherChannel Guard to help mitigate the chances of a loop.&lt;/p&gt;

&lt;p&gt;PAgP and LACP accomplish the exact same thing, just in different ways.&lt;/p&gt;

&lt;p&gt;Since both PAgP and LACP both require the member ports to have the same characteristics, a good command to start with is &lt;code class=&quot;highlighter-rouge&quot;&gt;show interfaces status&lt;/code&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>VTP Pruning</title>
   <link href="http://bsrandall.github.io/vtp/2017/02/22/VTP-Pruning/"/>
   <updated>2017-02-22T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vtp/2017/02/22/VTP-Pruning</id>
   <content type="html">&lt;p&gt;The principal of VTP pruning is if a client sends a broadcast to its connected switch’s access port, that switch will flood the broadcast to all other connected switches in the VTP / Layer 2 domain. Because of VTP, all the other switches would be aware of the client VLAN, and would thus be required to flood the broadcast to all other switches.&lt;/p&gt;

&lt;p&gt;But what if the other switches do not have any clients connected to access ports in that VLAN? They are still having to process the request, and the network segment still has to bear the broadcast traffic.&lt;/p&gt;

&lt;p&gt;When you enable VTP pruning, you are enabling it for the entire VTP domain.&lt;/p&gt;

&lt;p&gt;NEED TO FINISH&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Multiple Spanning Tree</title>
   <link href="http://bsrandall.github.io/mst/2017/02/22/MST/"/>
   <updated>2017-02-22T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/mst/2017/02/22/MST</id>
   <content type="html">&lt;p&gt;Multiple Spanning Tree (MST) was developed to overcome the high resource requirements of PVST. In reality, there are only a few logical redundant design on a network, regardless of the number of VLANs or the number of physical links. With MST you can run several different logical topologies (instances), and map VLANs to those instances. You get the benefit of running a redundant, fully utilized network without the resource overhead on the switches.&lt;/p&gt;

&lt;p&gt;So the end result is that with PVST, a port is either forwarding or discarding for a VLAN, while with MST, a port is either forwarding or discarding for an instance which contains multiple VLANs.&lt;/p&gt;

&lt;p&gt;MST is defined by IEEE 802.1s. A special instance, instance 0 or the Internal Spanning Tree (IST), is designated to carry all STP information. The BPDUs for IST carry all the standard RSTP information, as well as the configuration name, revision number, and a &lt;em&gt;hash value&lt;/em&gt; calculated over the VLAN to instance mapping.&lt;/p&gt;

&lt;p&gt;You should not run MSTP on access ports.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>VTP Versions</title>
   <link href="http://bsrandall.github.io/vtp/2017/02/21/VTP-Versions/"/>
   <updated>2017-02-21T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vtp/2017/02/21/VTP-Versions</id>
   <content type="html">&lt;p&gt;VTP is a Cisco proprietary protocol that allows VLAN administration to be shared across switches. It gives an administrator the capability to centrally administer VLAN creation across one or two switches, and have those VLANs propagate across a VTP domain made up of any number of switches.&lt;/p&gt;

&lt;p&gt;There are 3 versions of VTP, versions 1, 2, and 3.  There are not many significant changes between versions 1 and 2, except version 2 introduced support for Token Ring VLANs.&lt;/p&gt;

&lt;p&gt;Version 3 introduced the following enhancements:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;hidden authentication (does not appear in plain text in the configuration file)&lt;/li&gt;
  &lt;li&gt;Extended VLAN support. Versions 1 and 2 only support VLANs 1 - 1000 only.&lt;/li&gt;
  &lt;li&gt;Support for private VLANs&lt;/li&gt;
  &lt;li&gt;Support for MST&lt;/li&gt;
  &lt;li&gt;primary and secondary servers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With version 3, there are two types of VTP servers - primary and secondary. There is only one primary server, and the rest of the secondary servers act as backups to the primary. To declare a server as primary, use the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`SW1# vtp primary vlan
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Notice the command is done in privileged mode, not configure mode!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>VTP Messages</title>
   <link href="http://bsrandall.github.io/vtp/2017/02/21/VTP-Header/"/>
   <updated>2017-02-21T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vtp/2017/02/21/VTP-Header</id>
   <content type="html">&lt;p&gt;All VTP packets contain these fields in the header:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;VTP version (1, 2, or 3)&lt;/li&gt;
  &lt;li&gt;VTP Message Type
    &lt;ul&gt;
      &lt;li&gt;Summary advertisements&lt;/li&gt;
      &lt;li&gt;Subset advertisement&lt;/li&gt;
      &lt;li&gt;Advertisement requests&lt;/li&gt;
      &lt;li&gt;VTP Join Messages&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Management domain length&lt;/li&gt;
  &lt;li&gt;Management domain name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most VTP packets contain the &lt;em&gt;configuration revision number&lt;/em&gt; of the sender. This is used to determine if the received information is more recent than the current version.&lt;/p&gt;

&lt;p&gt;By default, &lt;em&gt;summary advertisements&lt;/em&gt; are sent every 5 minutes. The summary advertisement contains the VTP domain name and the current configuration revision number. If the VTP domain matches the switch’s configured VTP domain, and the configuration revision number is higher than its own revision, the switch will send an &lt;em&gt;advertisement request&lt;/em&gt;. Otherwise, it ignores the packet.&lt;/p&gt;

&lt;h4 id=&quot;summary-advertisement-packet-format&quot;&gt;Summary Advertisement Packet Format&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cisco.com/c/dam/en/us/support/docs/lan-switching/vtp/10558-21c.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;subset advertisement&lt;/em&gt; will follow a summary advertisement - it is the message that actually contains a list (or a subset of a list) of the VLANs being advertised.&lt;/p&gt;

&lt;p&gt;A switch will send an &lt;em&gt;advertisement request&lt;/em&gt; in these situations:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the switch has been reset&lt;/li&gt;
  &lt;li&gt;the VTP domain name has been changed on the switch&lt;/li&gt;
  &lt;li&gt;the switch has received a VTP summary advertisement with a higher configuration than its own&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Dot1q</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/21/Dot1q/"/>
   <updated>2017-02-21T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/21/Dot1q</id>
   <content type="html">&lt;h4 id=&quot;trunks&quot;&gt;Trunks&lt;/h4&gt;
&lt;p&gt;Dot1q is the standard trunking protocol used for transporting multiple VLANs across a trunk port. A trunk is a point-to-point link that carries the traffic for multiple VLANs across a single trunk. Dot1q is a standard that tags VLANs for identification. The receiving switch will then strip the VLAN tag from the frame before passing it to the appropriate access port.&lt;/p&gt;

&lt;p&gt;The full name for Dot1q is IEEE 802.1Q.&lt;/p&gt;

&lt;p&gt;The 802.1Q Tagged frame looks like this:
&lt;img src=&quot;http://bsrandall.github.io/public/img/802.1q.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The PRI field is the 3-bit 802.1p priority field.&lt;/li&gt;
  &lt;li&gt;The CFI field is always set to 0 for Ethernet switches&lt;/li&gt;
  &lt;li&gt;VLAN ID is a 12-bit field&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because of the extra fields, an 802.1Q frame has an MTU of 1522 bytes.&lt;/p&gt;

&lt;p&gt;If a non-802.1Q enabled device or an access port receives a tagged frame, it simply ignores the frame and forwards it as usual.&lt;/p&gt;

&lt;h4 id=&quot;native-vlan&quot;&gt;Native VLAN&lt;/h4&gt;
&lt;p&gt;A Native VLAN on a trunk is the VLAN to which untagged traffic belongs. Across a trunk, the Native VLANs should match on each end.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# show interface trunk&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;will show the Native VLAN for each interface that has active trunking.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Dynamic Trunking Protocol (DTP)</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/21/DTP/"/>
   <updated>2017-02-21T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/21/DTP</id>
   <content type="html">&lt;p&gt;Dynamic Trunking Protocol is a Cisco proprietary protocol that, when configured, attempts to negotiate trunking between two connected ports. It will try to negotiate trunking as well as the encapsulation type.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport mode dynamic auto&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;allows the interfaces to become a trunk if the neighboring trunk is set to trunk or desirable mode&lt;/li&gt;
  &lt;li&gt;this is the default setting for newer Cisco switches&lt;/li&gt;
  &lt;li&gt;if both ends of a trunk are set to dynamic auto, they will not form a trunk&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport mode dynamic desireable&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;makes the interface actively attempt to negotiate trunking&lt;/li&gt;
  &lt;li&gt;the link will become a trunk if the neighbor interface is set to trunk, auto, or desirable&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport nonegotiate&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;prevents the interface from sending DTP frames&lt;/li&gt;
  &lt;li&gt;can use this when the interface switch port mode is &lt;em&gt;access&lt;/em&gt; or &lt;em&gt;trunk&lt;/em&gt; only&lt;/li&gt;
  &lt;li&gt;if enabled, to establish a trunk the neighbor interface must be manually set to &lt;em&gt;trunk&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>VLANs</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/21/Allowed-VLANs/"/>
   <updated>2017-02-21T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/21/Allowed-VLANs</id>
   <content type="html">&lt;p&gt;By default, all VLANs are allowed to traverse an 802.1Q trunk once it is active. To restrict which VLANs are allowed to cross a trunk, you must go into IOS and explicitly define the VLANs that are allowed.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk allow VLAN 15-20,22,25&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk allowed vlan add 27&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk allowed vlan remove 18&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You must remember that if an allowed VLAN list is already configured on a trunk, issuing the &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk allowed vlan 16-20,2,25&lt;/code&gt; command will overwrite the previously defined VLANs. You must use the &lt;em&gt;add&lt;/em&gt; and &lt;em&gt;remove&lt;/em&gt; commands if there is already an allowed clan configuration in the running config.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Access Ports</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/21/Access-Ports/"/>
   <updated>2017-02-21T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/21/Access-Ports</id>
   <content type="html">&lt;p&gt;Access ports are those ports that are connected to end devices, not other switches. We define an access port on the command line with 
SW1# switchport mode access&lt;/p&gt;

&lt;p&gt;We will see later with Spanning Tree, that PortFast can and should be used on access ports. This does two things. First, it allows the port to skip the listening phase for faster availability. Second, it prevents the access port from sending TCNs (Topology Change Notifications) every time a user plugs or unplugs a device into the port.&lt;/p&gt;

&lt;p&gt;Another Spanning Tree feature which will relate to Access ports is BPDU Guard. With BPDU Guard, if the switch receives a BPDU on a port where BPDU Guard was enabled, the port will transition to the errdisabled state.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>VLANs</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/20/VLANs/"/>
   <updated>2017-02-20T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/20/VLANs</id>
   <content type="html">&lt;h4 id=&quot;standard-vlans&quot;&gt;Standard VLANs&lt;/h4&gt;
&lt;p&gt;Cisco calls VLANS 1 - 1005 Normal VLANs. Of those, VLAN 1 is the Cisco default. You can use this VLAN, but your are not allowed to delete it. VLANs 1002 - 1005 are the Cisco defaults for FDDI and Token Ring. These also cannot be deleted.&lt;/p&gt;

&lt;p&gt;That leaves us VLANs 2 - 1001 as Normal VLANs that we can add or delete as we wish.&lt;/p&gt;

&lt;p&gt;VLANs 2 - 1001 are pruning eligible, while VLANs 1006 - 4094 are not.&lt;/p&gt;

&lt;p&gt;When you delete a VLAN, any LAN ports configured as access ports for that VLAN become inactive until you assign them to a new VLAN.&lt;/p&gt;

&lt;h4 id=&quot;extended-vlans&quot;&gt;Extended VLANs&lt;/h4&gt;
&lt;p&gt;Extended VLANs are in the range of 1006 - 4094. Extended range VLANs are not controlled by VTP and cannot be pruned. The router must be in VTP transparent mode in order to create extended VLANs.&lt;/p&gt;

&lt;p&gt;Extended range VLANs are not stored in van.dat&lt;/p&gt;

&lt;h4 id=&quot;vlan-database&quot;&gt;VLAN Database&lt;/h4&gt;
&lt;p&gt;Only applies to standard VLANs.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Hello World</title>
   <link href="http://bsrandall.github.io/general/2017/02/20/Hello-World/"/>
   <updated>2017-02-20T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/general/2017/02/20/Hello-World</id>
   <content type="html">&lt;p&gt;This is my first post in my newly launched blog. I decided to go with Jekyll and a GitHub page for my blog backend. I wanted my content to be in Markdown, as that seems to be the authoring flavor of the day. Jekyll and GitHub just made sense due to their support of Markdown.&lt;/p&gt;

&lt;p&gt;Our knowledge is at its pinnacle when we can fluidly explain topics to others. That is my main motivation for this blog. There most likely will not be any ground breaking content, but I hope to explain some of the topics in a way that makes sense.&lt;/p&gt;

&lt;p&gt;The other two benefits to my blog is hopefully improving on my Markdown and typing skills. It is sad that I still type as badly as I do, considering how much I type. I will use Markdown highlighting for code samples. TextExpander should make all of this a little easier.&lt;/p&gt;

&lt;p&gt;This is some sample IOS commands using Markdown:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk encapsulation dot1q&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport mode trunk&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Well I am off to the races. Or as most of those who have gone before me stress, off to start the marathon!&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Git</title>
   <link href="http://bsrandall.github.io/general/2017/02/20/Git/"/>
   <updated>2017-02-20T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/general/2017/02/20/Git</id>
   <content type="html">&lt;p&gt;I am not a git master, nor do I strive to become one. But I do need to know some basic details to manage this blog as well as my INE VIRL configurations. There are probably better ways to do this, but for my purposes, these are the commands I am running to push my updates from my MacBook to by GitHub page:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/Dropbox/jekyll.bsrandall.github.io(master) &amp;gt;&amp;gt; git add --all&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt; ~/Dropbox/jekyll.bsrandall.github.io(master) &amp;gt;&amp;gt; git commit -m &quot;update notes&quot;&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;~/Dropbox/jekyll.bsrandall.github.io(master) &amp;gt;&amp;gt; git push -u origin master&lt;/code&gt;&lt;/p&gt;

</content>
 </entry>
 

</feed>
