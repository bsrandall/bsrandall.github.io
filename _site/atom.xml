<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>No Excuses CCIE</title>
 <link href="http://bsrandall.github.io/atom.xml" rel="self"/>
 <link href="http://bsrandall.github.io/"/>
 <updated>2017-03-28T20:20:10-04:00</updated>
 <id>http://bsrandall.github.io</id>
 <author>
   <name>Brian Scott Randall</name>
   <email></email>
 </author>

 
 <entry>
   <title>Spanning Tree Root Guard</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-Root-Guard/"/>
   <updated>2017-03-28T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-Root-Guard</id>
   <content type="html">&lt;p&gt;Root Guard is an enhancement to STP developed by Cisco. One issue with standard STP is that there is no way to ensure root bridge placement within the network. Even if you set a switch’s bridge priority to 0, another switch can come behind it with a priority of 0 and a lower MAC address and immediately take over the Root Bridge role.&lt;/p&gt;

&lt;p&gt;Root Guard is enabled on a per port basis. Root Guard ensures that the port on which it is configured remains a designated port. If the bridge receives superior BPDUs on that designated port, Root Guard moves the port to root-inconsistent state, which is effectively equivalent to the STP listening state so no frames are forwarded.&lt;/p&gt;

&lt;p&gt;The difference between BPDU Guard and Root Guard is that Root Guard allows the port to participate in STP, so long as the port does not receive a &lt;em&gt;superior&lt;/em&gt; BPDU. With BPDU Guard, &lt;em&gt;any&lt;/em&gt; BPDU will put the port into an err-disabled state.&lt;/p&gt;

&lt;p&gt;Again, Root Guard is enabled on a per interface basis as below.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface gig0/1
SW!(config-if)# spanning-tree rootguard
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The Cisco explanation is located &lt;a href=&quot;http://www.cisco.com/c/en/us/support/docs/lan-switching/spanning-tree-protocol/10588-74.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Spanning Tree BPDU Guard</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-BPDU-Guard/"/>
   <updated>2017-03-28T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-BPDU-Guard</id>
   <content type="html">&lt;p&gt;BPDU Guard is a STP PortFast safety enhancement. It works by disabling a port any time the interface hears a BPDU. PortFast by itself will not do that, so if you have PortFast enabled on an interface, and an end user plugs a switch into that link, all kinds of events can happen (including the plugged in switch becoming the Root Bridge!). BPDU Guard ensures that unauthorized switches cannot be plugged into the network. A sample configuration is below.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface gig0/1
  spanning-tree bodyguard enable

errdisable recovery cause bpduguard
errdisable recovery interval 120
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The errdisable section enables the port after 120 seconds, in case the port is placed into err disabled state to due BPDU Guard.&lt;/p&gt;

&lt;p&gt;Optionally, you can set BPDU Guard as the default configuration on all interfaces with the following global commands:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;spanning-tree portfast bodyguard default
spanning-tree portfast default
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree BPDU Filter</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-BPDU-Filter/"/>
   <updated>2017-03-28T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-BPDU-Filter</id>
   <content type="html">&lt;p&gt;BPDU Filter is another optional feature of STP. It is similar to BPDU Guard, in that it is used to terminate the STP domain. Like BPDU Guard, it can be enabled globally or per interface, but unlike BPDU Guard, BGPU filter behaves differently depending on how it is enabled.&lt;/p&gt;

&lt;p&gt;If BPDU Filter is enabled at the interface level, it silently drops all received inbound BPDUs and does not send outbound BPDUs. Unlike BPDU Guard, there is no err-disabled option for BPDU Filter. Here is an example of BPDU Filter enabled at the interface level:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config-if)# switchport mode access
SW1(config-if)# switchport access vlan 10
SW1(config-if)# spanning-tree bpdufilter enable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When BPDU Filter is enabled globally, it will only affect PortFast enabled ports. The switch will send out exactly 11 BPDUs, and inbound BPDUs are not filtered. The reason 11 BPDUs are sent is the default Hello timer is 2 seconds and the default Max Age timer is 20 seconds. If the switch receives inbound BPDUs, the port loses its PortFast status and STP is negotiated normally on that port. For this reason, you can say that BPDU Filter enabled globally is a safer option than BPDU enabled at the interface level, as STP loops cannot form.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>STP UplinkFast</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-UplinkFast/"/>
   <updated>2017-03-27T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-UplinkFast</id>
   <content type="html">&lt;p&gt;UplinkFast provides fast convergence in case the link on which the root port is connected suffers a failure. It does this with the use of an uplink group. An uplink group is a set of Layer 2 interfaces, of which only one is forwarding at a particular time. If the root port (forwarding port) goes down, then a successor root port is chosen which immediately goes into Forwarding state, bypassing the Listening and Learning phases.&lt;/p&gt;

&lt;p&gt;UplinkFast functionality is built into RSTP, so UplinkFast is only applicable with legacy IEEE 802.1D.&lt;/p&gt;

&lt;p&gt;When UplinkFast is enabled on a switch, that switch’s bridge priority will automatically be increased to 49152 and its port cost will be increased to 3000. This is to ensure that the switch does not become a transit switch.&lt;/p&gt;

&lt;p&gt;To enable UplinkFast, go to the switch on which you want it to run and run &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree uplinkfast&lt;/code&gt; in global configuration mode.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>STP PortFast</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-Portfast/"/>
   <updated>2017-03-27T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-Portfast</id>
   <content type="html">&lt;p&gt;PortFast is used in Spanning Tree to avoid the lengthy delay of the Listening and Learning phases during STP convergence. When PortFast is enabled on an interface, the interface skips the Listening and Learning phases and goes straight into the Forwarding state. PortFast should be used on access switches on ports where you know end devices will be plugged in.&lt;/p&gt;

&lt;p&gt;To enable port fast on an interface, in interface sub configuration mode use &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree portfast&lt;/code&gt;. If it is a trunk you must append the &lt;code class=&quot;highlighter-rouge&quot;&gt;trunk&lt;/code&gt; keyword after the command, and if it is an access port you should use the &lt;code class=&quot;highlighter-rouge&quot;&gt;edge&lt;/code&gt; keyword.&lt;/p&gt;

&lt;p&gt;Another way to enable PortFast for access ports is to use &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree portfast default&lt;/code&gt; in global configuration mode. Once enabled, all access ports will automatically have PortFast enabled.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree BackboneFast</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-BackboneFast/"/>
   <updated>2017-03-27T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-BackboneFast</id>
   <content type="html">&lt;p&gt;BackboneFast enables fast reconvergence due to indirect link failures. The key operation happens when a switch begins receiving inferior BPDUs.  When a switch loses the link off its Root Port, it immediately starts sending BPDUs announcing itself as the new Root. Usually, when a switch receives inferior BPDUs, it will wait for its Max Age timer to expire before beginning STP convergence. Once its Max Age timer expires, the inferior BPDU ages out and the switch will then forward its superior BPDU to the neighbor switch who was sending the inferior BPDU.&lt;/p&gt;

&lt;p&gt;When BackboneFast is enabled, as soon as a switch receives an inferior BPDU, it will send RLQ (Root Link Query) messages out all it’s non-designated ports. The RLQ asks other switches if the current Root Bridge is accessible via that switch. Note it doesn’t wait for its Max Age timer to expire - it begins sending RLQ messages immediately. The RLQ is a new type of PDU defined within the BackboneFast specification. The RLQ is essentially a proactive way to age out ports compared to just waiting on the Max Age timer to expire.&lt;/p&gt;

&lt;p&gt;Based on the received RLQ responses, the switch will update its root ports and designated ports accordingly.. However all ports still transition through the regular IEEE 802.1D STP port states - listening, learning, and forwarding/blocking.&lt;/p&gt;

&lt;p&gt;To enable BackboneFast use the command &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree backbonefast&lt;/code&gt; on all switches in the Layer 2 domain. The easiest way to verify that BackboneFast is enabled is to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;show spanning-tree summary&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;This is a great Cisco article describing the operation: &lt;a href=&quot;http://www.cisco.com/c/en/us/support/docs/lan-switching/spanning-tree-protocol/12014-18.html&quot;&gt;BackboneFast&lt;/a&gt;.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Debugging Spanning Tree Events</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/27/Debugging-STP/"/>
   <updated>2017-03-27T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/27/Debugging-STP</id>
   <content type="html">&lt;p&gt;Here is a configuration for debugging Spanning Tree events:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# debug spanning-tree events
SW1# debug condition vlan 2
SW1# config t
SW1(config)# service timestamps debug datetime msec
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>STP Convergence Timers</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/26/STP-Timers/"/>
   <updated>2017-03-26T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/26/STP-Timers</id>
   <content type="html">&lt;p&gt;There are 3 timers we need to be concerned with in Spanning Tree: the Hello Time, the Forward Delay, and the Max-Age Time.&lt;/p&gt;

&lt;p&gt;The Hello Time is the frequency with which BPDUs are transmitted from the root bridge. It can be adjusted with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree vlan 1-4094 hello-time 3&lt;/code&gt; where 3 is in seconds. The default is 2 seconds, but in can be adjusted between 1 and 10 seconds. Non-root bridges will never generate BPDUs, but only relay BPDUs they receive on their root port.&lt;/p&gt;

&lt;p&gt;The Forward Delay is the time that is spent in the listening and learning states. Its value is 15 seconds by default, but it can be adjusted to anywhere between 4 and 30 seconds.&lt;/p&gt;

&lt;p&gt;The Max Age timer controls the maximum length of time that passes before a bridge port saves its configuration BPDU. This time is 20 seconds by default, but it can be tuned to be anytime between 6 and 40 seconds.&lt;/p&gt;

&lt;p&gt;There is another item that is not a timer but is related. This is the &lt;em&gt;message age&lt;/em&gt;. The root bridge sends all of its BPDUs with a message age of 0. Each downstream switch then adds 1 to this message age value. The actual age out time of the downstream switches is then (max age - message age).&lt;/p&gt;

&lt;p&gt;Here is a good article that describes the Max Age timer as it relates to superior BPDUs:  &lt;a href=&quot;https://packetmagnifier.wordpress.com/2013/09/09/understanding-stp-max-age/&quot;&gt;Max Age&lt;/a&gt;. If a switch’s root port goes down, there is no need for it to go through the Max Age timer process - if there are no better BPDUs received, the switch will immediately start announcing itself as root and begin sending BPDUs. In the scenario in the article, the switch that went down is sending inferior BPDUs, but yet the receiving switch goes through the Max Age process before it transforms its non-designated port to a Designated Port and begins sending the superior BPDUs towards the switch that suffered the down link.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>STP Path Selection with Port Cost</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/21/STP-Port-Cost/"/>
   <updated>2017-03-21T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/21/STP-Port-Cost</id>
   <content type="html">&lt;p&gt;There are two ways we can alter STP Path selection. We can alter the cost of a port, or we can change the priority of a port.&lt;/p&gt;

&lt;p&gt;When a switch receives a BPDU, that BPDU contains the root path cost from the previous switch. The receiving switch then adds the cost of the link between it and the sending switch from which it received the BPDU. That is very important - it is the receiving switch that adds the cost associated with its interface to the Root Path Cost it received from the sending switch.&lt;/p&gt;

&lt;p&gt;Cost is used for the selection of the root port to the upstream switch.&lt;/p&gt;

&lt;p&gt;Priority is used for influencing the root port of the downstream switch, and as such, it is set up on a port in Designated state. Cost has a higher precedence than priority. You will see priority on the local switch &lt;code class=&quot;highlighter-rouge&quot;&gt;show spanning-tree vlan 2&lt;/code&gt; but it will actually affect the forwarding decision on the downstream connected switch.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>STP Root Bridge Election</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/20/STP-Root-Bridge-Election/"/>
   <updated>2017-03-20T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/20/STP-Root-Bridge-Election</id>
   <content type="html">&lt;p&gt;STP Root Bridge Election is based on the Bridge ID of the switches in the active Layer 2 domain. The Bridge ID is made up of the 4-bit bridge priority, a 12-bit Systems ID, and the 48-bit MAC address. The bridge priority is configurable from 0 to 61440. The default is 32768. The System ID is taken from the VLAN number (IEEE 802.1t).&lt;/p&gt;

&lt;p&gt;The election process is very simple. Each bridge starts off assuming it is the Root Bridge and sends BPDUs out advertising itself as such. If it receives a superior BPDU (a BPDU that has a Bridge ID lower than its current root bridge Bridge ID), it ceases advertising that Root Bridge and begins advertising the new Root Bridge with the lower Bridge ID. This process continues until all switches in the domain agree to the same Root Bridge.&lt;/p&gt;

&lt;p&gt;Note that since MAC addresses are guaranteed to be unique, there will always be 1 Root Bridge elected. If all switches are set to the default priority, then the switch with the lowest MAC Address will become the Root Bridge. this is a bad idea for many reasons. One, you typically want your distribution layer switch to be the Root Bridge. Second, older switches will have lower MAC addresses, so your switch with the least resources ends up having a heavier load along with a higher chance for failure&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>STP Root Bridge Election</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/20/STP-Port-Election/"/>
   <updated>2017-03-20T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/20/STP-Port-Election</id>
   <content type="html">&lt;p&gt;After the election of the STP Root Bridge, all ports in the Layer 2 Switch topology will need to be assigned a state. The steps can be listed as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;All ports on the Root Bridge become Designated Ports&lt;/li&gt;
  &lt;li&gt;On each non-root switch, exactly ONE port is elected as the &lt;em&gt;Root Port&lt;/em&gt; which is the port having the lowest path-cost to the Root Bridge.&lt;/li&gt;
  &lt;li&gt;Each segment between switches will have one Designated Port which is the port on the segment that has the lowest path-cost to reach the root bridge.&lt;/li&gt;
  &lt;li&gt;The Root and Designated Ports are placed into a Forwarding State.&lt;/li&gt;
  &lt;li&gt;The ports that are not Root ports or Designated Ports will be placed in the Blocking State. These are displayed in show commands with an A for Alternate.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is helpful to remember that Designated Ports lead away from the Root Bridge, while Root Ports lead toward the Root Bridge.&lt;/p&gt;

&lt;p&gt;What are the tiebreakers for Root Ports and Designated Ports?&lt;/p&gt;

&lt;p&gt;The tiebreaker for Spanning Tree decisions is as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Lowest root bridge ID (used for root bridge election)&lt;/li&gt;
  &lt;li&gt;Lowest path cost to root bridge&lt;/li&gt;
  &lt;li&gt;Lowest sender bridge ID (used when a switch is connected to two switches through which it has equal cost to reach the root bridge)&lt;/li&gt;
  &lt;li&gt;Lowest sender port ID (when the switch has two interfaces connecting to the same switch and the cost to reach the root bridge is the same through either interface, it will use the interface with the lowest number as the root port (or designated port).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is helpful to keep in mind for elections that there is only one bridge that originates BPDUs - the root bridge. Other bridges update some fields (such as Sending Bridge ID, Message Age, etc) when retransmitting out their designated ports.&lt;/p&gt;

&lt;p&gt;The access ports will be designated ports typically and will send BPDUs toward the host, unless BPDU Filter is set.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Virtual Switch System</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/17/Spanning-Tree-Types/"/>
   <updated>2017-03-17T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/17/Spanning-Tree-Types</id>
   <content type="html">&lt;p&gt;There are several different versions of the Spanning Tree Protocol that we will come across. We will review them in chronological order today.&lt;/p&gt;

&lt;p&gt;The original spanning tree is Common Spanning Tree, or CST. It was defined with IEEE 802.1D. The basic premise is to create a logical loop free topology for Ethernet networks by building a spanning tree of connected layer-2 bridges. The links that are not part of the spanning tree are disabled, leaving a single active path between any two network nodes.&lt;/p&gt;

&lt;p&gt;PVST and PVST+ are both Cisco proprietary protocols. Cisco developed them as they believed we may need different spanning-trees on a per-VLAN basis for  the best path flow. PVST only ran over ISL trunks, but with PVST+ compatibility with 802.1q trunks arrived. The + version also added new features such as UplinkFast, BackboneFast, and PortFast.&lt;/p&gt;

&lt;p&gt;RSTP is the IEEE’s answer to Cisco’s PVST+ implementation. RSTP took many of the added features of PVST+ and standardized them into IEEE 802.1w. RSTP added new bridge port roles and port states.&lt;/p&gt;

&lt;p&gt;Cisco then responded to the IEEE 802.1w Rapid Spanning Tree Protocol with RPVST+, which is just RSTP with per-vlan support. RPVST+ supports both ISL and 802.1Q trunks.&lt;/p&gt;

&lt;p&gt;When the concept of VLANs finally hit home when VoIP hit the LAN, everyone finally agreed that we needed VLAN support for STP. However, it was also determined that there are usually on three paths needed to support redundancy with Spanning Tree designs. But yet with Spanning Trees based on a per-VLAN approach, we may end up with way more than 3 instances of Spanning Tree running on the router.&lt;/p&gt;

&lt;p&gt;This led to the introduction of Multiple Spanning Tree Protocol. It was originally defined with 802.1s and was later merged into IEEE 802.1Q-2005. MSTP creates on common Spanning Tree for the entire Layer 2 network. If a network contains multiple VLANs, we can create multiple Spanning Trees and then assign specific VLANs to specific Spanning Tree instances. Since most networks will need a maximum of two Spanning Tree instances, MSTP greatly reduces the overhead on the router compared to RPVST which needed a separate instance per VLAN.&lt;/p&gt;

&lt;p&gt;Cisco MST supports both 802.1Q and ISL trunks.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Virtual Switch System</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/13/VSS/"/>
   <updated>2017-03-13T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/13/VSS</id>
   <content type="html">&lt;p&gt;VSS, or Virtual Switch System, exists in Cisco Catalyst 6500 and 4500 switches running IOS-XE. VSS simplifies the network by reducing the number of network elements. VSS can combine multiple Catalyst Switches into a single logical device. VSS logically combines a pair of switches into a single network element.&lt;/p&gt;

&lt;p&gt;The two switches in the pair negotiate their roles - one will assume the role of the active switch while the other assumes the role of the standby switch. The VSS active switch controls the VSS, running the Layer 2 and Layer 3 protocols for both switches. Both switches perform packet forwarding as needed, but the standby switch sends all control traffic to the VSS active switch for processing.&lt;/p&gt;

&lt;p&gt;The virtual switch link (VSL) is the link which ties the active and standby switches together. It is typically implemented as an EtherChannel, and therefore can support up to 8 links in the bundle. The attached devices (such as access switches) can then connect to the VSS using Multichassis EtherChannel. Unlike normal EtherChannel witch connects multiple links between two switches, MultiChassis EtherChannel can connect one switch over multiple links to two switches. In total, a VSS can support up to 256 EtherChannels in a combination of regular EtherChannels and MultiChassis EtherChannels (MEC).&lt;/p&gt;

&lt;h4 id=&quot;configuration&quot;&gt;Configuration&lt;/h4&gt;

&lt;p&gt;Both switches in a VSS pair need to belong to the same VSS domain. This domain is a number between 1 and 255. After creating the domain, you must configure one switch to be switch number 1 and the other switch to be switch number 2.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# switch virtual domain 10
SW1(config-vs-domain)# switch 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2(config)# switch virtual domain 10
SW2(config-vs-domain)# switch 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next you should create the VSL between the two VSS switches.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface port-channel 5
SW1(config-if)# switchport
SW1(config-if)# switch virtual link 1
SW1(config-if)# no shutdown
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2(config)# interface port-channel 10
SW2(config-if)# switchport
SW2(config-if)# switch virtual link 2
SW2(config-if)# no shutdown
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, you have to put the physical interfaces into the appropriate port-channels created for the VSL.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# int range gig1/0-3
SW1(config-if-range)# switchport mode trunk
SW1(config-if-range)# channel-group 5 mode on
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# int range gig1/0-3
SW1(config-if-range)# switchport mode trunk
SW1(config-if-range)# channel-group 10 mode on
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, to complete the switch conversion process you need to run the following command on each switch:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# switch convert mode virtual
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2# switch convert mode virtual
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The switch will reload and when they come back up they will now be part of the VSS domain.&lt;/p&gt;

&lt;p&gt;Some sample show commands are:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# show switch virtual

SW1# show switch virtual role

SW1# show switch virtual link

SW1# show switch virtual link port-channel
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>SPAN Configuration</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/11/SPAN-Configuration/"/>
   <updated>2017-03-11T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/11/SPAN-Configuration</id>
   <content type="html">&lt;p&gt;Basic SPAN Configuration:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# monitor session 1 source interface fa0/12
SW1(config)# monitor session 1 destination interface fa0/24
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Here is an example where we will only monitor respective traffic from fa0/18 and only monitor sent traffic from interface fa0/19. Additionally we will filter (remove) VLANs 1 through 3. Finally, we will preserve the encapsulation from the sources:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# monitor session 1 source interface fa0/18 rx
SW1(config)# monitor session 1 source interface fa0/19 tx
SW1(config)# monitor session 1 filter vlan 1-3
SW1(config)# monitor session 1 destination interface fa0/24 encapsulation replicate
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next we have a RSPAN sample configuration. We will monitor all traffic on VLANs 66-68 on SW1 and send it to VLAN 199, which will then be delivered to port fa0/24 on SW2:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# vlan 199
SW1(config-vlan)# remote span
SW1(config-vlan)# exit
SW1(config)# monitor session 1 source vlan 66-68
SW1(config)# monitor session 1 destination remote van 199
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2(config)# vlan 199
SW2(config-vlan)# remote span
SW2(config-vlan)# exit
SW2(config)# monitor session 2 source remote vlan 199
SW2(config)# monitor session 2 destination interface fa0/24
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notice above that the monitor session numbers do not have to match on each switch.&lt;/p&gt;

&lt;p&gt;Finally, we have a ERSPAN example. We will configure R1 to capture received traffic and send it to SW1 gig2/1.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1(config)# monitor session 1 type erspan-source
R1(config-mon-erspan-src)# source interface gig1/1 rx
R1(config-mon-erspan-src)# no shutdown
R1(config-mon-erspan-src)# destination
R1(config-mon-erspan-src-dst)# erspan-id 101
R1(config-mon-erspan-src-dst)# ip address 10.1.1.1
R1(config-mon-erspan-src-dst)# origin ip address 172.16.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# monitor session 2 type erspan-destination
SW1(config-mon-erspan-dst)# destination interface gig2/1
SW1(config-mon-erspan-dst)# no shutdown
SW1(config-mon-erspan-dst)# source
SW1(config-mon-erspan-dst-src)# erspan-id 101
SW1(config-mon-erspan-dst)# ip address 10.1.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A couple of configuration notes. First, you must make sure the destination port is not in a shutdown state or else the SPAN session will not come up.&lt;/p&gt;

&lt;p&gt;To view the session, simply use &lt;code class=&quot;highlighter-rouge&quot;&gt;show monitor session 1&lt;/code&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>SPAN</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/09/SPAN/"/>
   <updated>2017-03-09T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/09/SPAN</id>
   <content type="html">&lt;p&gt;SPAN stands for Switch Port Analyzer. It is a way to direct all traffic from a source port or source VLAN to a single port. Some uses include IDS/IPS, VoIP Call recording, or troubleshooting / analysis.&lt;/p&gt;

&lt;p&gt;If the destination port is on the local switch, we say it is in SPAN operation mode. The destination port could also be mapped to a port on a remote switch, in which case we call it Remote SPAN or RSPAN. In RSPAN, a specific VLAN must be configured across the entire switching path from the source port or VLAN to the RSPAN destination port. So the source is still at least one port or at least one VLAN,  but the destination is always the RSPAN VLAN. At the switch where the RSPAN destination port exists, the RSPAN VLAN is delivered to the RSPAN port.&lt;/p&gt;

&lt;p&gt;Encapsulated Remote SPAN (ERSPAN) is a variant of RSPAN in which we are encapsulating the Remote SPAN information. ERSPAN creates a GRE tunnel for all captured traffic and allows it to be extended across Layer 3 domains. This became an option with IOS-XE.&lt;/p&gt;

&lt;p&gt;Regardless of the type of SPAN we are running, the source port can be any type of port including EtherChannel, trunk port, routed port, etc. When using a VLAN as the source, all active ports in that VLAN are monitored, and the monitored ports are updated dynamically as membership to that VLAN changes. A port configured as a SPAN destination cannot be part of a SPAN source VLAN.&lt;/p&gt;

&lt;p&gt;Iy is important to understand that when you configure a SPAN destination port, the existing configuration is removed buy is restored if you later remove the SPAN configuration. The destination port does not support any security, nor does it support any Layer 2 protocols such as CDP, VTP, etc. If the destination port was part of an EtherChannel, it will be removed from the EtherChannel once the SPAN configuration is applied.&lt;/p&gt;

&lt;p&gt;There are a number of restrictions with SPAN including:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the source can be one or more ports or a VLAN, but not both&lt;/li&gt;
  &lt;li&gt;up to 64 destination ports can be configured on a switch&lt;/li&gt;
  &lt;li&gt;you must be careful not to overload the destination port, especially if a VLAN is being monitored.&lt;/li&gt;
  &lt;li&gt;within a single SPAN session, you cannot deliver traffic to a destination port when it is sourced by a mix of SPAN, RSPAN, or ERSPAN source ports or VLANs. This usually comes into play when you want to mirror source traffic to both a local port on a switch (SPAN mode) and a remote port on another switch (RSPAN mode).&lt;/li&gt;
  &lt;li&gt;only one SPAN/RSPAN/ERSPAN session can send traffic to a single destination port&lt;/li&gt;
  &lt;li&gt;if you use a trunk port as a SPAN or RSPAN source, then by default all VLANs on the trunk are monitored by default&lt;/li&gt;
  &lt;li&gt;traffic that is routed from another VLAN to a source VLAN cannot be monitored with SPAN&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, SPAN, RSPAN, and ERSPAN support three types of traffic: transmitted, received, and both (default). If you set a SPAN to monitor just receive or just transmit, some conditions apply:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;for Receive (RX) the goal is to deliver all traffic that is received by the SPAN source. As a result, each frame that is received by the source port or VLAN is copied to the destination port or VLAN &lt;em&gt;before&lt;/em&gt; any modifications are made to the frame (such as ACL filtering, QoS, etc)&lt;/li&gt;
  &lt;li&gt;for Transmit (TX), all relevant filtering or modification to the frame is done before the switch forwards the traffic to the SPAN or RSPAN destination.&lt;/li&gt;
  &lt;li&gt;SPAN usually ignores certain Layer 2 frames like CDP, BPDUs, etc. However, SPAN can be configured to forward that traffic to the destination port/VLAN with the &lt;code class=&quot;highlighter-rouge&quot;&gt;encapsulation replicate&lt;/code&gt; command&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree Intro</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/08/Spanning-Tree-Intro/"/>
   <updated>2017-03-08T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/08/Spanning-Tree-Intro</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;https://networklessons.com/wp-content/uploads/2013/01/switches-redundant-cable-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Imagine in the above diagram that H1 sends out an ARP request, which is a broadcast frame. SW1 will forward this broadcast frame on ports Fa0/0 and Fa1/0 toward SW2.&lt;/p&gt;

&lt;p&gt;SW2 will forward the broadcast frame it received on Fa0/0 out Fa1/0 and the interface connected to H2. This cycle will continue and continue. By introducing redundancy, we have created an environment that is friendly to Layer 2 loops. And since Ethernet frames do not have a TTL, they will loop around forever.&lt;/p&gt;

&lt;p&gt;Spanning Tree is a Layer 2 protocol that was created to deal with the possible loop creation that is introduced with redundant Layer 2 loops. Spanning Tree takes over the Layer 2 forwarding decisions, and places certain ports in a blocking state to prevent the possibility of these loops occurring.&lt;/p&gt;

&lt;p&gt;When Spanning Tree is enabled, switches send out a special frame called a BPDU (Bridge Protocol Data Unit). Included in this BPDU is the Switch’s Priority and MAC Address, which concatenated equals the Bridge Id. Among connected Switch’s, the Switch with the lowest Bridge Id becomes the Root Bridge.&lt;/p&gt;

&lt;p&gt;A Root Bridge marks all of its ports as Designated, which are placed in a forwarding state. Designated ports lead away from the Root bridge.&lt;/p&gt;

&lt;p&gt;For the remaining switches, we have to elect one root port on each switch. The root port will be the port whose path has the lowest cost to the root bridge&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Common Spanning Tree</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/08/CST/"/>
   <updated>2017-03-08T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/08/CST</id>
   <content type="html">&lt;p&gt;Common Spanning-Tree (CST) assumes one spanning-tree instance for the entire bridged network, regardless of the number of VLANs. Running only one instance reduces CPU load. All CST BPDUs are sent over trunks using the native VLAN with untagged frames.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>UDLD</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/07/UDLD/"/>
   <updated>2017-03-07T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/07/UDLD</id>
   <content type="html">&lt;p&gt;UDLD, or Unidirectional Link Detection, is a Cisco proprietary, Layer 2 protocol that helps detects if either the transmit or the receive fails on a link. It’s purpose is similar to LoopGuard, but it is completely independent of Spanning Tree. The operation of UDLD is fairly simple. A switch sends UDLD Hellos and if it receives echoes of those Hellos back it knows the link is an active two way link. As soon as it quits receiving the UDLD Hellos, it knows there must be a unidirectional link failure. UDLD operates at the physical port level, compared to say STP LoopGuard which works at the logical port level (EtherChannel). Also UDLD functions at linkup, while LoopGuard does not. It is recommended to enable both UDLD and LoopGuard.&lt;/p&gt;

&lt;p&gt;UDLD is mainly used on fiber connections, but it can also be useful on Ethernet connections that have dumb devices in the middle such as media converters.&lt;/p&gt;

&lt;p&gt;The default advertisement timer is 15 seconds and the hold time is 5 seconds. Upon detecting the loss of a UDLD neighbor, UDLD will send seven additional advertisements (one per second). If no reply is received, the link’s bidirectional status transitions to unknown.&lt;/p&gt;

&lt;p&gt;To set up UDLD globally, use &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1(config)# udld enable&lt;/code&gt; and use the &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1(config-if)# udld port enable&lt;/code&gt; command to enable per interface. Use &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1(config)# udld enable aggressive&lt;/code&gt; if you want the ports to be shut down upon UDLD neighbor failure.&lt;/p&gt;

&lt;p&gt;In order to reset an interface that was shut down by UDLD, use &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# udld reset&lt;/code&gt;, or the typical shut / no shut commands.&lt;/p&gt;

&lt;p&gt;You could also enable auto recovery of the interface if desired. It would look like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# errdisable recovery cause idled
SW1(config)# errdisable recovery interval 30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>LLDP</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/06/LLDP/"/>
   <updated>2017-03-06T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/06/LLDP</id>
   <content type="html">&lt;p&gt;LLDP is the IEEE equivalent of CDP. It’s development was due to Cisco’s deployment of CDP, so the IEEE sought to make a universal version. It is very similar to CDP and many of the Cisco commands for LLDP are the same commands as those for CDP, just substituting lldp for cdp. Like CDP, LLDP is a link layer protocol, but unlike CDP it is specifically for Ethernet networks. LLDP is described under IEEE 802.1AB LLDP.&lt;/p&gt;

&lt;p&gt;LLDP, like CDP, also uses TLVs to describe neighbor devices and capabilities.&lt;/p&gt;

&lt;p&gt;One additional feature LLDP includes is that LLDP has a TLV for an interface description, so if you set a description with &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1#(config-if) description LINK_SW1_SW2&lt;/code&gt;, that description would show up under Switch 2 LLDP like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2# show lldp neighbors detail

Chasis id: 0019.569d.571a
Port id: Fa0/24
Port Description: LINK_SW1_SW2
System Name: SW1.cisco.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;An enhancement was made to LLDP that allows you to use LLDP for VLAN assignment or POE requirements. This enhanced version is known as LLDP-MED (Media Endpoint Discovery).&lt;/p&gt;

&lt;p&gt;One difference between CDP and LLDP is that with LLDP the Hello timer is set to 30 seconds by default and the hold time is set to 4 times the Hello time. CDP is 60 seconds and the hold timer is 3 times the Hello time, as a reminder. Another difference is that LLDP has a reinitialization delay (default 2 seconds).  This is the time that an LLDP port waits before reinitializing LLDP transmission. The command to set the reinitialization period is &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1#(config) lldp reinit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can also set LLDP up to only transmit and not receive LLDP packets. This is done by using the &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1#(config) no lldp receive&lt;/code&gt; command. You can also do this on a per-interface basis. Likewise, you can also disallow sending LLDP packets with the &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1#(config) no lldp transmit&lt;/code&gt; command, which can also be done at the interface level.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CDP Configuration</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/06/CDP-Configuration/"/>
   <updated>2017-03-06T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/06/CDP-Configuration</id>
   <content type="html">&lt;p&gt;To enable CDP globally we use &lt;code class=&quot;highlighter-rouge&quot;&gt;cdp run&lt;/code&gt;. To enable CDP on a per-interface basis, use &lt;code class=&quot;highlighter-rouge&quot;&gt;cdp enable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) cdp timer seconds&lt;/code&gt;  specifies the frequency of CDP update transmissions.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) cdp holdtime seconds&lt;/code&gt; specifies the amount of time a receiving device should hold the information sent by your device before discarding it.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) no cdp adertise-v2&lt;/code&gt; disables the advertisement of CDPv2 advertisements if for some crazy reason you need to.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) clear cdp counters&lt;/code&gt; resets the traffic counters to zero.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) clear cdp table&lt;/code&gt; deletes the CDP table of information about neighbors&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) show cdp&lt;/code&gt; displays the interval between CDP transmissions, the number of seconds a CDP advertisement is valid for a given port, and the version of the advertisement&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) show cdp interface [type number]&lt;/code&gt; displays information about interfaces on which CDP is enabled&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) show cdp entry device-name&lt;/code&gt; displays information about a specific neighbor&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>CDP Basics</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/06/CDP-Basics/"/>
   <updated>2017-03-06T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/06/CDP-Basics</id>
   <content type="html">&lt;p&gt;CDP is a layer 2, Cisco proprietary device discovery protocol. Even though it is a Layer 2 protocol, it provides information about Layer 3 protocols (such as IP address). CDP operates by its member devices sending multicasts to the link-local multicast address 01:00:0c:cc:cc:cc (same as VTP). The member devices listen for multicasts at that address, process them accordingly, and store the information in a local table. The announcements are sent out every 60 seconds by default.&lt;/p&gt;

&lt;p&gt;SNAP (Subnetwork Access Protocol) is required to run CDP, so effectively CDP can run on any data-link protocol that supports SNAP. Ethernet, Frame Relay, and ATM are example medias that support SNAP and thus CDP.&lt;/p&gt;

&lt;p&gt;CDP relays the information about devices by Type-Length-Value (TLV) fields in the CDP packets. The &lt;em&gt;Length&lt;/em&gt; is the length (in bytes) of the Type-Value-Length fields. The Type and Value fields are described below.&lt;/p&gt;

&lt;h4 id=&quot;type&quot;&gt;Type&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Device ID - 0x0001&lt;/li&gt;
  &lt;li&gt;Address - 0x0002&lt;/li&gt;
  &lt;li&gt;Port ID - 0x0003&lt;/li&gt;
  &lt;li&gt;Capabilities - 0x0004&lt;/li&gt;
  &lt;li&gt;Version - 0x0005&lt;/li&gt;
  &lt;li&gt;Platform - 0x0006&lt;/li&gt;
  &lt;li&gt;IP Prefix - 0x0007&lt;/li&gt;
  &lt;li&gt;VTP Management Domain - 0x0009 {: .red}&lt;/li&gt;
  &lt;li&gt;Native VLAN - 0x000a {: .red}&lt;/li&gt;
  &lt;li&gt;Duplex Status - 0x000b {: .red}&lt;/li&gt;
  &lt;li&gt;Appliance ID - 0x000c {: .red}&lt;/li&gt;
  &lt;li&gt;Power consumption - 0x0010 {: .red}&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;value&quot;&gt;Value&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Device ID - MAC address in ASCII or the FQDN&lt;/li&gt;
  &lt;li&gt;Address&lt;/li&gt;
  &lt;li&gt;Port ID - ASCII string that names the port from which the message was sent&lt;/li&gt;
  &lt;li&gt;Capabilities - has a value describing the device capabilities:
    &lt;ul&gt;
      &lt;li&gt;0x01 - level 3 routing&lt;/li&gt;
      &lt;li&gt;0x02 - level 2 transparent bridging&lt;/li&gt;
      &lt;li&gt;0x04 - level 2 source-route bridging&lt;/li&gt;
      &lt;li&gt;0x08 - level 2 switching not running Spanning Tree&lt;/li&gt;
      &lt;li&gt;0x10 - sends and receives packets for a network layer protocol&lt;/li&gt;
      &lt;li&gt;0x20 - the device does not forward IGMP reports&lt;/li&gt;
      &lt;li&gt;0x40 - level 1 function&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Version - software version running the device&lt;/li&gt;
  &lt;li&gt;Platform - ASCII string describing the device (e.g. Cisco 7000)&lt;/li&gt;
  &lt;li&gt;IP Prefix - a set of 0 or more IP Prefixes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Switches see the MAC multicast address used by CDP as a special address and will not forward it out of other interfaces on a switch. Routers do not forward layer 2 frames out of their interfaces ever, so therefore only directly connected neighbors receive the CDP advertisement.&lt;/p&gt;

&lt;p&gt;The beauty of CDP is that if you walk into a network and you do not know the topology, you can use CDP to quickly learn the entire layout of the network (as long as all the devices are Cisco!).&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>MultiChassis EtherChannel</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/27/EtherChannel-MultiChassis/"/>
   <updated>2017-02-27T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/27/EtherChannel-MultiChassis</id>
   <content type="html">&lt;p&gt;A LAG bundle to the same access switch results in Fate Sharing for the links in the bundle. The alternative is to break the links out of the LAG, and have the NICs of a server connect to two different access switches. But by breaking the LAG, we now have half the available bandwidth for the server.&lt;/p&gt;

&lt;p&gt;With MultiChassis EtherChannel, we trick the server into running LAG between two different access switches. There are multiple ways to do this using different protocols made by different vendors. We generically call it MLAG.&lt;/p&gt;

&lt;p&gt;The protocol must take a physical triangle as seen below, and make it into a logical point-to-point. Many problems arise that the protocol must deal with. If NIC A sends traffic to Switch A, Switch A must know not to send that to Switch B, or else a loop might form.
&lt;img src=&quot;http://www.cisco.com/c/dam/en/us/td/i/200001-300000/220001-230000/226001-227000/226936.eps/_jcr_content/renditions/226936.jpg&quot; alt=&quot;&quot; /&gt;
The protocols are so customized, that different platforms from the same vendor cannot even run MLAG. The control place has to be identical. Cisco therefore has a couple of implementations.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Stackwise Cross-Stack EtherChannel&lt;/em&gt; has control plane over dedicated stacking cables. These stack cables create a bidirectional closed loop as seen below. One control plane is shared amongst members as well as one management plane. So if you were to log into one switch, you are actually viewing the configuration for the stack. This is used on the Access Platforms such as Catalyst 3750/3850. StackWise can have more than 2 members, up to the stack limit
&lt;img src=&quot;https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcRguQ7GRPRoSYAmPfJ4MCMN2r160qFDougT6yyluxFXu6n42Foxgg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Virtual Switching System (VSS)&lt;/em&gt; is used on the aggregation platforms such as Catalyst 4500/6500/6800. VSS is similar to Stackwise as there is one management plane and one control plane shared between connected switches. Typically with VSL, the links are going to be 2x10G LAG. VSS switches are udeployed in pairs and will usually have 1 active supervisor and 3 standby supervisors.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Virtual Port Channel (vPC)&lt;/em&gt; is very similar to VSS but it runs on the Data Center platforms such as Nexus 5000/7000/9000. The control plane is synchronized over a vPC Peer Link, which are typically 2x10GigE LAG. The biggest difference between vPC and VSS, is that vPC has &lt;em&gt;2&lt;/em&gt; independent control planes and &lt;em&gt;2&lt;/em&gt; independent management planes. vPC like VSS is deployed in pairs.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>EtherChannel PaGP</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/26/EtherChannel-PAgP/"/>
   <updated>2017-02-26T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/26/EtherChannel-PAgP</id>
   <content type="html">&lt;p&gt;Port Aggregation Protocol (PAgP) is a Cisco proprietary protocol that is only supported on Cisco switches.&lt;/p&gt;

&lt;p&gt;The two modes of PAgP are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;auto: places a port into a passive negotiating state&lt;/li&gt;
  &lt;li&gt;desirable: places a port into active negotiating state&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For Layer 2 EtherChannels, the first port that comes up lends its MAC address to the EtherChannel.&lt;/p&gt;

&lt;p&gt;PAgP supports up to 8 Ethernet ports of the same type.&lt;/p&gt;

&lt;p&gt;For all EtherChannels (including on and PAgP), when a group is first created, all ports follow the parameters set for the first port to be added to the group. If you change the configuration of any of these parameters, you must also make changes to all ports in the group:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Allowed-VLAN list&lt;/li&gt;
  &lt;li&gt;Spanning-tree path cost for each VLAN&lt;/li&gt;
  &lt;li&gt;Spanning-tree port priority for each VLAN&lt;/li&gt;
  &lt;li&gt;Spanning-tree Port Fast setting&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For all Layer 2 EtherChannels, if the ports are access ports they must all be in the same VLAN.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>EtherChannel Load-Balancing</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/26/EtherChannel-Load-Balancing/"/>
   <updated>2017-02-26T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/26/EtherChannel-Load-Balancing</id>
   <content type="html">&lt;p&gt;The balancing method is locally significant and outbound. So it is OK for one side of a LAG to be src-MAC and the other side to be dest-IP.&lt;/p&gt;

&lt;p&gt;To configure the load-balancing method by using the&lt;code class=&quot;highlighter-rouge&quot;&gt;port-channel load-balance&lt;/code&gt; global configuration command. EtherChannel load-balancing can use MAC Address or IP address, source or destination address, or both source and destination address.&lt;/p&gt;

&lt;p&gt;The selected load balancing mode applies to all ether channels on a switch.&lt;/p&gt;

&lt;p&gt;With source-MAC address forwarding, packets are distributed across the ports based on the source-MAC of the &lt;em&gt;incoming&lt;/em&gt; packet. So packets from the same host use the same port in the channel.&lt;/p&gt;

&lt;p&gt;With destination-MAC address forwarding, packets are distributed across the ports of the channel based on the destination-MAC of the incoming packet. So packets destined to the same host use the same port in the channel.&lt;/p&gt;

&lt;p&gt;With source-and-destination MAC address forwarding, packets are distributed across the ports in a channel based on both the source and the destination MAC address. This is often used if it is not clear whether source-MAC or destination-MAC would be more appropriate.&lt;/p&gt;

&lt;p&gt;IP based forwarding has the same principles as the MAC based forwarding outlined above.&lt;/p&gt;

&lt;p&gt;To chose the appropriate load-balancing method, you must analyze the position of the EtherChannel in the network. For example, if you have 4 hosts going towards one router, you would be much better load-balancing based on source-MAC  than destination-MAC from the switch. On the router, you will be better off using destination-MAC.&lt;/p&gt;

&lt;p&gt;To configure EtherChannel load-balancing, in global config use the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`port-channel load-balance {dst-ip | dst-mac | src-dst-ip | src-dst-mac | src-ip | src-mac}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
The default is src-mac.&lt;/p&gt;

&lt;p&gt;One negative of EtherChannel is that flows cannot exceed the bandwidth of an individual link. EtherChannel adds lanes to the highway but it doesn’t increase the speed limit.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>EtherChannel LACP</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/24/EtherChannel-LACP/"/>
   <updated>2017-02-24T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/24/EtherChannel-LACP</id>
   <content type="html">&lt;p&gt;LACP is the IEEE standard for establishing a single logical channel out of several physical ports. It is popular as it can be used in mixed-vendor switch environments. LACP ensures that when an EtherChannel is created, all physical members all have the same speed, duplex, link-type, and VLAN information. LACP is a control protocol for LAG. The official name is IEEE 802.3ad Link Aggregation (LAG).&lt;/p&gt;

&lt;p&gt;LACP supports up to 16 Ethernet ports of the same type. Up to eight ports can be active, and up to eight ports can be in standby mode.&lt;/p&gt;

&lt;p&gt;LACP assigns system priority, port priority, and and an administrative key.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;System priority&lt;/em&gt; and the MAC address form the System ID. Between two LACP neighbors, the switch with the lowest System ID will be the decision maker using the LACP Port Priority&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Port priority&lt;/em&gt; and the port number form the port identifier. The switch uses the port identifier to decide which ports to put in standby mode when a hardware limitation prevents all ports from aggregating. Port priority is also used when more than 8 physical ports are put into a channel group. Port priority will decide which 8 ports will be the active ports in the etherchannel.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Administrative key&lt;/em&gt; defines the capabilities of a port to aggregate with other ports, based on the port’s physical characteristics.&lt;/p&gt;

&lt;p&gt;Sample Configuration:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# interface range GigabitEthernet0/1-2
SW1# channel-group 1 mode active
SW1# exit
SW1# interface port-channel 1
SW1# switchport trunk encapsulation dot1q
SW1# switchport mode trunk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2# interface range GigabitEthernet0/1-2
SW2# channel-group 1 mode active
SW2# exit
SW2# interface port-channel 1
SW2# switchport trunk encapsulation dot1q
SW2# switchport mode trunk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can also start with the &lt;code class=&quot;highlighter-rouge&quot;&gt;interface port-channel 1&lt;/code&gt; command and then define the channel group. For Layer 3 ether channel, you would want to define the port-channel first and then issue the &lt;code class=&quot;highlighter-rouge&quot;&gt;no switchport&lt;/code&gt; interface command.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;interface port-channel 1&lt;/code&gt; is the logical interface. The channel-group command binds the logical interface to a physical port. The port-channel interface (numbered 1 - 48) correspond to the one specified with the channel-group interface configuration command.&lt;/p&gt;

&lt;p&gt;A successful Layer 2 EtherChannel will show SU with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;show etherchannel summary&lt;/code&gt;. An unsuccessful layer 2 will show SD.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MST IST-CIST</title>
   <link href="http://bsrandall.github.io/mst/2017/02/23/MST-IST-CIST/"/>
   <updated>2017-02-23T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/mst/2017/02/23/MST-IST-CIST</id>
   <content type="html">&lt;p&gt;IST is the Internal Spanning Tree, also known as instance 0. This instance is designated to carry all STP information, including information from other instances. MSTP does not send BPDUs for ever instance separately - these are all contained within the IST BPDU.&lt;/p&gt;

&lt;p&gt;To accommodate, the other instances information is carried within the IST BPDU using special M-Record fields - one for every active MSTI. These fields carry carry MSTP information such as bridge priority, root path cost, and port priority.&lt;/p&gt;

&lt;p&gt;IST also plays a huge role in multiple MSTP region configurations. When a switch receives a BPDU from another region, it marks the corresponding port as MSTP &lt;em&gt;boundary&lt;/em&gt;. The interconnected, different region switches then form a CIST spanning across the regions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.ine.com/wp-content/uploads/2010/02/mstp-3-multi-region-physical-topology.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Remember, an IST is internal to a region while a CIST is the IST spanning across multiple regions.&lt;/p&gt;

&lt;p&gt;Here is a sample MST BPDU:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.ine.com/wp-content/uploads/2010/02/mstp-3-multi-region-cst-mstp-packet-format.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The CIST Root is elected among all regions while the CIST Regional Root is elected in every region. The IST Root = CIST Regional Root in cases where multiple MST regions interoperate. The CIST Root is the bridge that has the lowest Bridge Id among all regions - the CIST Root could be a bridge inside a region or a boundary switch in a region. The CIST Regional Root is a &lt;em&gt;boundary switch&lt;/em&gt; elected for every region based on the shortest external path cost to reach the CIST Root. As mentioned above, it is important to remember that the CIST Regional Root becomes the root of the IST for the given region as well - the region changes its IST election process to make the CIST Regional Root the IST root.&lt;/p&gt;

&lt;p&gt;When an MST switch boots up, it declares itself the CIST Root and CIST Regional Root and announce that it its outgoing BPDUs on all internal ports. On boundary ports (those that have received BPDUs from another region), the switch will only advertise its CIST Root Bridge ID and CIST External Root Path Cost, hiding the details of the region’s inner topology.&lt;/p&gt;

&lt;p&gt;The region that contains the CIST Root automatically places all of its boundary ports in an unblocked state.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;CIST External Root Path Cost&lt;/em&gt; is the cost to reach the CIST Root across the links connecting the boundary ports. When a BPDU is received on an internal link, this cost is not changed.&lt;/p&gt;

&lt;p&gt;Only a boundary switch can be elected as the CIST Regional Root, and this is the switch with the lowest cost to reach the CIST Root. If a boundary switch receives a BPDU with a lower CIST External Root Path cost on one of its internal ports, it will stop announcing itself as the CIST Regional Root and start announcing the new metric out of its boundary ports.&lt;/p&gt;

&lt;p&gt;If a switch is a CIST Regional Root, it elects one of its boundary ports as the CIST Root port and blocks all other boundary ports. If a boundary switch is not the CIST Regional Root, it will mark its boundary ports as Designated or Alternate, Designate only if it has a better External Root Path cost or in case of a tie, lower CIST Regional Root Bridge ID.&lt;/p&gt;

&lt;p&gt;The regional MSTIs are constructed independently at every region, but they have to be mapped to the CIST at the boundary ports. This equates to the inability to load-balance VLAN traffic on the boundary links by mapping VLANs to different instances.&lt;/p&gt;

&lt;p&gt;A topology change in the CST could change all paths in the topology thus requiring massive MAC address relearning.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>EtherChannel</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/23/EtherChannel-General/"/>
   <updated>2017-02-23T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/23/EtherChannel-General</id>
   <content type="html">&lt;p&gt;LAG goal is to trick our Spanning Tree Protocol into forwarding active/active across multiple links. The risk we take is an infinite loop in the data plane, as there is no TTL with Ethernet. The LAG negotiation protocols help to mitigate this risk. Static LAG is supported but not recommended, as a failure to LAG can cause an STP Loop. If you do deploy Static LAG, it is recommended to deploy EtherChannel Guard to help mitigate the chances of a loop.&lt;/p&gt;

&lt;p&gt;PAgP and LACP accomplish the exact same thing, just in different ways.&lt;/p&gt;

&lt;p&gt;Since both PAgP and LACP both require the member ports to have the same characteristics, a good command to start with is &lt;code class=&quot;highlighter-rouge&quot;&gt;show interfaces status&lt;/code&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>VTP Pruning</title>
   <link href="http://bsrandall.github.io/vtp/2017/02/22/VTP-Pruning/"/>
   <updated>2017-02-22T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vtp/2017/02/22/VTP-Pruning</id>
   <content type="html">&lt;p&gt;The principal of VTP pruning is if a client sends a broadcast to its connected switch’s access port, that switch will flood the broadcast to all other connected switches in the VTP / Layer 2 domain. Because of VTP, all the other switches would be aware of the client VLAN, and would thus be required to flood the broadcast to all other switches.&lt;/p&gt;

&lt;p&gt;But what if the other switches do not have any clients connected to access ports in that VLAN? They are still having to process the request, and the network segment still has to bear the broadcast traffic.&lt;/p&gt;

&lt;p&gt;When you enable VTP pruning, you are enabling it for the entire VTP domain.&lt;/p&gt;

&lt;p&gt;NEED TO FINISH&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Multiple Spanning Tree</title>
   <link href="http://bsrandall.github.io/mst/2017/02/22/MST/"/>
   <updated>2017-02-22T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/mst/2017/02/22/MST</id>
   <content type="html">&lt;p&gt;Multiple Spanning Tree (MST) was developed to overcome the high resource requirements of PVST. In reality, there are only a few logical redundant design on a network, regardless of the number of VLANs or the number of physical links. With MST you can run several different logical topologies (instances), and map VLANs to those instances. You get the benefit of running a redundant, fully utilized network without the resource overhead on the switches.&lt;/p&gt;

&lt;p&gt;So the end result is that with PVST, a port is either forwarding or discarding for a VLAN, while with MST, a port is either forwarding or discarding for an instance which contains multiple VLANs.&lt;/p&gt;

&lt;p&gt;MST is defined by IEEE 802.1s. A special instance, instance 0 or the Internal Spanning Tree (IST), is designated to carry all STP information. The BPDUs for IST carry all the standard RSTP information, as well as the configuration name, revision number, and a &lt;em&gt;hash value&lt;/em&gt; calculated over the VLAN to instance mapping.&lt;/p&gt;

&lt;p&gt;You should not run MSTP on access ports.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>VTP Versions</title>
   <link href="http://bsrandall.github.io/vtp/2017/02/21/VTP-Versions/"/>
   <updated>2017-02-21T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vtp/2017/02/21/VTP-Versions</id>
   <content type="html">&lt;p&gt;VTP is a Cisco proprietary protocol that allows VLAN administration to be shared across switches. It gives an administrator the capability to centrally administer VLAN creation across one or two switches, and have those VLANs propagate across a VTP domain made up of any number of switches.&lt;/p&gt;

&lt;p&gt;There are 3 versions of VTP, versions 1, 2, and 3.  There are not many significant changes between versions 1 and 2, except version 2 introduced support for Token Ring VLANs.&lt;/p&gt;

&lt;p&gt;Version 3 introduced the following enhancements:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;hidden authentication (does not appear in plain text in the configuration file)&lt;/li&gt;
  &lt;li&gt;Extended VLAN support. Versions 1 and 2 only support VLANs 1 - 1000 only.&lt;/li&gt;
  &lt;li&gt;Support for private VLANs&lt;/li&gt;
  &lt;li&gt;Support for MST&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>VTP Messages</title>
   <link href="http://bsrandall.github.io/vtp/2017/02/21/VTP-Header/"/>
   <updated>2017-02-21T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vtp/2017/02/21/VTP-Header</id>
   <content type="html">&lt;p&gt;All VTP packets contain these fields in the header:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;VTP version (1, 2, or 3)&lt;/li&gt;
  &lt;li&gt;VTP Message Type
    &lt;ul&gt;
      &lt;li&gt;Summary advertisements&lt;/li&gt;
      &lt;li&gt;Subset advertisement&lt;/li&gt;
      &lt;li&gt;Advertisement requests&lt;/li&gt;
      &lt;li&gt;VTP Join Messages&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Management domain length&lt;/li&gt;
  &lt;li&gt;Management domain name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most VTP packets contain the &lt;em&gt;configuration revision number&lt;/em&gt; of the sender. This is used to determine if the received information is more recent than the current version.&lt;/p&gt;

&lt;p&gt;By default, &lt;em&gt;summary advertisements&lt;/em&gt; are sent every 5 minutes. The summary advertisement contains the VTP domain name and the current configuration revision number. If the VTP domain matches the switch’s configured VTP domain, and the configuration revision number is higher than its own revision, the switch will send an &lt;em&gt;advertisement request&lt;/em&gt;. Otherwise, it ignores the packet.&lt;/p&gt;

&lt;h4 id=&quot;summary-advertisement-packet-format&quot;&gt;Summary Advertisement Packet Format&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cisco.com/c/dam/en/us/support/docs/lan-switching/vtp/10558-21c.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;subset advertisement&lt;/em&gt; will follow a summary advertisement - it is the message that actually contains a list (or a subset of a list) of the VLANs being advertised.&lt;/p&gt;

&lt;p&gt;A switch will send an &lt;em&gt;advertisement request&lt;/em&gt; in these situations:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the switch has been reset&lt;/li&gt;
  &lt;li&gt;the VTP domain name has been changed on the switch&lt;/li&gt;
  &lt;li&gt;the switch has received a VTP summary advertisement with a higher configuration than its own&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Dot1q</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/21/Dot1q/"/>
   <updated>2017-02-21T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/21/Dot1q</id>
   <content type="html">&lt;h4 id=&quot;trunks&quot;&gt;Trunks&lt;/h4&gt;
&lt;p&gt;Dot1q is the standard trunking protocol used for transporting multiple VLANs across a trunk port. A trunk is a point-to-point link that carries the traffic for multiple VLANs across a single trunk. Dot1q is a standard that tags VLANs for identification. The receiving switch will then strip the VLAN tag from the frame before passing it to the appropriate access port.&lt;/p&gt;

&lt;p&gt;The full name for Dot1q is IEEE 802.1Q.&lt;/p&gt;

&lt;p&gt;The 802.1Q Tagged frame looks like this:
&lt;img src=&quot;http://bsrandall.github.io/public/img/802.1q.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The PRI field is the 3-bit 802.1p priority field.&lt;/li&gt;
  &lt;li&gt;The CFI field is always set to 0 for Ethernet switches&lt;/li&gt;
  &lt;li&gt;VLAN ID is a 12-bit field&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because of the extra fields, an 802.1Q frame has an MTU of 1522 bytes.&lt;/p&gt;

&lt;p&gt;If a non-802.1Q enabled device or an access port receives a tagged frame, it simply ignores the frame and forwards it as usual.&lt;/p&gt;

&lt;h4 id=&quot;native-vlan&quot;&gt;Native VLAN&lt;/h4&gt;
&lt;p&gt;A Native VLAN on a trunk is the VLAN to which untagged traffic belongs. Across a trunk, the Native VLANs should match on each end.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# show interface trunk&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;will show the Native VLAN for each interface that has active trunking.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Dynamic Trunking Protocol (DTP)</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/21/DTP/"/>
   <updated>2017-02-21T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/21/DTP</id>
   <content type="html">&lt;p&gt;Dynamic Trunking Protocol is a Cisco proprietary protocol that, when configured, attempts to negotiate trunking between two connected ports. It will try to negotiate trunking as well as the encapsulation type.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport mode dynamic auto&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;allows the interfaces to become a trunk if the neighboring trunk is set to trunk or desirable mode&lt;/li&gt;
  &lt;li&gt;this is the default setting for newer Cisco switches&lt;/li&gt;
  &lt;li&gt;if both ends of a trunk are set to dynamic auto, they will not form a trunk&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport mode dynamic desireable&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;makes the interface actively attempt to negotiate trunking&lt;/li&gt;
  &lt;li&gt;the link will become a trunk if the neighbor interface is set to trunk, auto, or desirable&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport nonegotiate&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;prevents the interface from sending DTP frames&lt;/li&gt;
  &lt;li&gt;can use this when the interface switch port mode is &lt;em&gt;access&lt;/em&gt; or &lt;em&gt;trunk&lt;/em&gt; only&lt;/li&gt;
  &lt;li&gt;if enabled, to establish a trunk the neighbor interface must be manually set to &lt;em&gt;trunk&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>VLANs</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/21/Allowed-VLANs/"/>
   <updated>2017-02-21T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/21/Allowed-VLANs</id>
   <content type="html">&lt;p&gt;By default, all VLANs are allowed to traverse an 802.1Q trunk once it is active. To restrict which VLANs are allowed to cross a trunk, you must go into IOS and explicitly define the VLANs that are allowed.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk allow VLAN 15-20,22,25&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk allowed vlan add 27&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk allowed vlan remove 18&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You must remember that if an allowed VLAN list is already configured on a trunk, issuing the &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk allowed vlan 16-20,2,25&lt;/code&gt; command will overwrite the previously defined VLANs. You must use the &lt;em&gt;add&lt;/em&gt; and &lt;em&gt;remove&lt;/em&gt; commands if there is already an allowed clan configuration in the running config.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Access Ports</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/21/Access-Ports/"/>
   <updated>2017-02-21T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/21/Access-Ports</id>
   <content type="html">&lt;p&gt;Access ports are those ports that are connected to end devices, not other switches. We define an access port on the command line with 
SW1# switchport mode access&lt;/p&gt;

&lt;p&gt;We will see later with Spanning Tree, that PortFast can and should be used on access ports. This does two things. First, it allows the port to skip the listening phase for faster availability. Second, it prevents the access port from sending TCNs (Topology Change Notifications) every time a user plugs or unplugs a device into the port.&lt;/p&gt;

&lt;p&gt;Another Spanning Tree feature which will relate to Access ports is BPDU Guard. With BPDU Guard, if the switch receives a BPDU on a port where BPDU Guard was enabled, the port will transition to the errdisabled state.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>VLANs</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/20/VLANs/"/>
   <updated>2017-02-20T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/20/VLANs</id>
   <content type="html">&lt;h4 id=&quot;standard-vlans&quot;&gt;Standard VLANs&lt;/h4&gt;
&lt;p&gt;Cisco calls VLANS 1 - 1005 Normal VLANs. Of those, VLAN 1 is the Cisco default. You can use this VLAN, but your are not allowed to delete it. VLANs 1002 - 1005 are the Cisco defaults for FDDI and Token Ring. These also cannot be deleted.&lt;/p&gt;

&lt;p&gt;That leaves us VLANs 2 - 1001 as Normal VLANs that we can add or delete as we wish.&lt;/p&gt;

&lt;p&gt;VLANs 2 - 1001 are pruning eligible, while VLANs 1006 - 4094 are not.&lt;/p&gt;

&lt;p&gt;When you delete a VLAN, any LAN ports configured as access ports for that VLAN become inactive until you assign them to a new VLAN.&lt;/p&gt;

&lt;h4 id=&quot;extended-vlans&quot;&gt;Extended VLANs&lt;/h4&gt;
&lt;p&gt;Extended VLANs are in the range of 1006 - 4094. Extended range VLANs are not controlled by VTP and cannot be pruned. The router must be in VTP transparent mode in order to create extended VLANs.&lt;/p&gt;

&lt;p&gt;Extended range VLANs are not stored in van.dat&lt;/p&gt;

&lt;h4 id=&quot;vlan-database&quot;&gt;VLAN Database&lt;/h4&gt;
&lt;p&gt;Only applies to standard VLANs.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Hello World</title>
   <link href="http://bsrandall.github.io/general/2017/02/20/Hello-World/"/>
   <updated>2017-02-20T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/general/2017/02/20/Hello-World</id>
   <content type="html">&lt;p&gt;This is my first post in my newly launched blog. I decided to go with Jekyll and a GitHub page for my blog backend. I wanted my content to be in Markdown, as that seems to be the authoring flavor of the day. Jekyll and GitHub just made sense due to their support of Markdown.&lt;/p&gt;

&lt;p&gt;Our knowledge is at its pinnacle when we can fluidly explain topics to others. That is my main motivation for this blog. There most likely will not be any ground breaking content, but I hope to explain some of the topics in a way that makes sense.&lt;/p&gt;

&lt;p&gt;The other two benefits to my blog is hopefully improving on my Markdown and typing skills. It is sad that I still type as badly as I do, considering how much I type. I will use Markdown highlighting for code samples. TextExpander should make all of this a little easier.&lt;/p&gt;

&lt;p&gt;This is some sample IOS commands using Markdown:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk encapsulation dot1q&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport mode trunk&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Well I am off to the races. Or as most of those who have gone before me stress, off to start the marathon!&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Git</title>
   <link href="http://bsrandall.github.io/general/2017/02/20/Git/"/>
   <updated>2017-02-20T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/general/2017/02/20/Git</id>
   <content type="html">&lt;p&gt;I am not a git master, nor do I strive to become one. But I do need to know some basic details to manage this blog as well as my INE VIRL configurations. There are probably better ways to do this, but for my purposes, these are the commands I am running to push my updates from my MacBook to by GitHub page:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/Dropbox/jekyll.bsrandall.github.io(master) &amp;gt;&amp;gt; git add --all&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt; ~/Dropbox/jekyll.bsrandall.github.io(master) &amp;gt;&amp;gt; git commit -m &quot;update notes&quot;&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;~/Dropbox/jekyll.bsrandall.github.io(master) &amp;gt;&amp;gt; git push -u origin master&lt;/code&gt;&lt;/p&gt;

</content>
 </entry>
 

</feed>
