<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>No Excuses CCIE</title>
 <link href="http://bsrandall.github.io/atom.xml" rel="self"/>
 <link href="http://bsrandall.github.io/"/>
 <updated>2017-04-24T23:58:00-04:00</updated>
 <id>http://bsrandall.github.io</id>
 <author>
   <name>Brian Scott Randall</name>
   <email></email>
 </author>

 
 <entry>
   <title>Ip Routing General</title>
   <link href="http://bsrandall.github.io/2017/04/21/IP-Routing-General/"/>
   <updated>2017-04-21T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/2017/04/21/IP-Routing-General---</id>
   <content type="html">&lt;p&gt;layout: post
title: IP Routing General
category: General Routing
tag: knowledge
date: 2017-04-21 19:56:45
—
Static routes that point to an interface are advertised via RIP (and EIGRP) regardless of whether &lt;strong&gt;redistribute static&lt;/strong&gt; router configuration commands are specified for those routing protocols. This is because these routes are considered “connected” routes and lose their static nature. However, if there is no &lt;strong&gt;network&lt;/strong&gt; command defined for that interface, then the default route will not be advertised unless a &lt;strong&gt;redistribute static&lt;/strong&gt; command is configured.&lt;/p&gt;

&lt;p&gt;There are 3 ways (outside of dynamic routing protocols) to generate a default route.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ip default-gateway&lt;/li&gt;
  &lt;li&gt;ip default-network&lt;/li&gt;
  &lt;li&gt;ip route 0.0.0.0 0.0.0.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ip default-gateway&lt;/strong&gt; is used to define a default gateway when ip routing &lt;em&gt;is not&lt;/em&gt; enabled on the device. This can be handy to transfer a Cisco software image to a device when the device is in boot mode.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ip default-network&lt;/strong&gt; is used to define a default gateway when ip routing &lt;em&gt;is&lt;/em&gt; enabled on the router. Default routes configured this way are propagated differently depending on which routing protocol is propagating the default route. For EIGRP to propagate the default route, the network specified by &lt;strong&gt;ip default-network&lt;/strong&gt; must be known to EIGRP. The network must be an EIGRP derived network in the routing table, or the static route used to generate the route to the network must be redistributed into EIGRP.&lt;/p&gt;

&lt;p&gt;RIP advertises a route to network 0.0.0.0 if a gateway of last resort is configured using the &lt;strong&gt;ip default-network&lt;/strong&gt; command.&lt;/p&gt;

&lt;p&gt;When using &lt;strong&gt;ip route 0.0.0.0 0.0.0.0&lt;/strong&gt; to create a default route, EIGRP will propagate a route to network 0.0.0.0, but the static route must be redistributed into the routing protocol. With RIP, on most versions of IOS the default route created by &lt;strong&gt;ip route 0.0.0.0 0.0.0.0&lt;/strong&gt; is automatically advertised by RIP. Not only are these routes not automatically propagated by OSPF, you cannot redistribute a default route into OSPF - you must use the &lt;strong&gt;default-information originate&lt;/strong&gt; command.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>RIPng Configuration</title>
   <link href="http://bsrandall.github.io/ripng/2017/04/19/RIPng-Configuration/"/>
   <updated>2017-04-19T18:06:45-04:00</updated>
   <id>http://bsrandall.github.io/ripng/2017/04/19/RIPng-Configuration</id>
   <content type="html">&lt;p&gt;RIPng has an entirely different (and simpler) configuration process. Instead of specifying networks under router rip configuration mode, you simply enable IPv6 routing globally and then enable RIPng on a per interface basis.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`ipv6 unicast-routing
interface Ethernet0
 ipv6 address 2001:db8:0:6::1/64
 ipv6 rip bigMountain enable
!
interface Ethernet1
 ipv6 address 2001:db8:0:4::1/64
 ipv6 rip bigMountain enable
!
interface Ethernet2
 ipv6 address 2001:db8:0:5::1/64
 ipv6 rip bigMountain enable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`The process name is relevant only to the local router. But it is possible to have multiple RIPng routing processes running on the same router, unlike in RIPv1 or RIPv2 where only one RIP routing process was allowed per router. However if multiple RIPng processes are going to run on a single interface, you must change the UDP port to something other than 521 on any extra processes.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`ipv6 router rip smallMountain
  port 527 multicast ff02::9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`The fact that process names are only locally significant should also give you a clue that the port numbers would have to be different for multiple processes to be running on the same interface.&lt;/p&gt;

&lt;p&gt;Even though the enabling of RIPng occurs at the interface level, much of the customization is still done at the router configuration mode, just as with RIPv1 and RIPv2.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`ipv6 router rip bigMountain
  timers 10 30 30 60
  maximum-paths 8
  distance 200
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`The default RIPng timer values are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;update: 30 seconds&lt;/li&gt;
  &lt;li&gt;expire (invalid): 180 seconds&lt;/li&gt;
  &lt;li&gt;garbage collection: 120 seconds&lt;/li&gt;
  &lt;li&gt;holddown: 0 seconds&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Metric manipulation is different with RIPng. With RIPv1 and RIPv2, the hop count was adjusted by using an offset. RIPng does not modify the metric of each entry in a list of prefixes. Instead, RIPng modifies the hop count that is associated with an interface. This increments the metric of every prefix that is advertised to the router via their interface by the mount of the hop count configured on the interface. By default, RIPng adds a hop count of one to the prefixes advertised by a neighbor received by an interface. To alter the hop count that is added, us the &lt;strong&gt;metric-offset&lt;/strong&gt; interface subcommand.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`interface Ethernet0/1
  ipv6 rip smallMountain metric-offset 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>RIPv2 Configuration</title>
   <link href="http://bsrandall.github.io/rip/2017/04/19/RIPv2-Configuration/"/>
   <updated>2017-04-19T16:48:45-04:00</updated>
   <id>http://bsrandall.github.io/rip/2017/04/19/RIPv2-Configuration</id>
   <content type="html">&lt;p&gt;Much of the configuration for RIPv2 is the same as for RIPv1. Here we will address some of the differences.&lt;/p&gt;

&lt;p&gt;To specify RIPv2, use the version command under router configuration mode.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`router rip
  version 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
By default, a RIP process on  a Cisco router sends only RIPv1 messages but listens to both RIPv1 and RIPv2 messages. There are interface-level compatibility commands that should be utilized when working in an environment that uses both versions of RIP.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`interface Ethernet0
 ip address 192.168.50.129 255.255.255.192
 ip rip send version 1
 ip rip receive version 1
!
interface Ethernet1
 ip address 172.25.150.193 255.255.255.240
 ip rip send version 1 2
!
interface Ethernet2
 ip address 172.25.150.225 255.255.255.240
!
router rip
 version 2
 network 172.25.0.0
 network 192.168.50.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
We saw with RIPv1 that discontiguous subnets could be a problem. Classless routing protocols do not have the same issue, as each route update contains a mask, so subnets of one major network can be advertised into another major network. But the default behavior of RIPv2 is to summarize at network boundaries just like RIPv1. To turn off this summarization and allow subnets to be advertised across network boundaries, use the command &lt;strong&gt;no auto-summary&lt;/strong&gt; in the RIP router configuration mode.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ip rip triggered&lt;/strong&gt; will make the router stop sending periodic updates and will only send updates when there is a change to the routing table.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>RIPng General</title>
   <link href="http://bsrandall.github.io/ripng/2017/04/19/RIPng-General/"/>
   <updated>2017-04-19T16:36:45-04:00</updated>
   <id>http://bsrandall.github.io/ripng/2017/04/19/RIPng-General</id>
   <content type="html">&lt;p&gt;RIPng is based on RIPv2, but is not an extension and rather an entirely new protocol. RIPng has no support for IPv4, so in order to run dual stack you must run both RIP and RIPng.&lt;/p&gt;

&lt;p&gt;But RIPng uses the same timers, procedures, and message types as RIPv2. One exception is authentication, which with RIPng is performed via the built-in authentication methods of IPv6.&lt;/p&gt;

&lt;p&gt;Unlike RIPv1 and RIPv2 which run on UDP port 520, RIPng operates on UDP port 521.&lt;/p&gt;

&lt;p&gt;The message format is slightly different. Unlike with RIPv2, each route does not list a next-hop address. Instead, RIPng specifies the next-hop address in a special route entry and then groups all route entries that use the next-hop address after it.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>RIPv2 General</title>
   <link href="http://bsrandall.github.io/rip/2017/04/19/RIPv2-General/"/>
   <updated>2017-04-19T13:56:45-04:00</updated>
   <id>http://bsrandall.github.io/rip/2017/04/19/RIPv2-General</id>
   <content type="html">&lt;p&gt;RIPv2 is defined in RFC 1723. It is not a new protocol, but rather just RIPv1 with some extensions bringing it more up to date with modern routing environments. The improvements include:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;subnet masks carried with each route entry&lt;/li&gt;
  &lt;li&gt;authentication of routing updates&lt;/li&gt;
  &lt;li&gt;next-hop addresses carried with each route entry&lt;/li&gt;
  &lt;li&gt;external route tags&lt;/li&gt;
  &lt;li&gt;multicast route updates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Operation of RIPv2 is similar to RIPv1, and all the timer mechanisms remain the same. One difference is that updates are sent to the multicast address 224.0.0.9 instead of the broadcast address 255.255.255.255 that RIPv1 used.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ripv2-message-format.png&quot; alt=&quot;RIPv2 Message Format&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The RIPv2 message format is similar to RIPv1.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Command&lt;/strong&gt; is set to 1 for a request message or 2 for a response message.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Version&lt;/strong&gt; will be 2 for RIPv2. Note that RIPv2 will process valid RIPv1 messages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Address Family Identifier&lt;/strong&gt; is set to 2 for IPv4. The only exception is a request for a router’s full routing table, in which case it will be 0.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Route tag&lt;/strong&gt; provides a field for tagging external routes or routes that have been distributed into the RIPv2 process. One possible use is to carry the AS number of of routes that have been imported into RIP. This might be needed in case the information is carried across the RIP domain and then shared back with the external routing protocol in another location.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IP Address&lt;/strong&gt; is the IPv4 address of the destination of the route. It may be a major network address, a subnet, or a host.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Subnet Mask&lt;/strong&gt; is a 32 bit mask that identifies the host and network portions of the IPv4 address.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Next Hop&lt;/strong&gt; identifies a better next-hop address, if one exists, than the address of the advertising router. It will be populated if there is another router on the same subnet that is closer to the destination than the advertising router. If the field is set to 0.0.0.0, then the advertising router is the best next-hop address.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Metric&lt;/strong&gt; is the hop count, between 1 and 16.&lt;/p&gt;

&lt;p&gt;As RIPv2 is a classless routing protocol, when it goes to look up a destination in the routing table, it does not pay attention to the class of the destination address. Instead, it performs a bit-by-bit best match between the destination address and all of its known routes.&lt;/p&gt;

&lt;p&gt;One interesting note in regards to all classless routing protocols - Cisco IOS rejects an attempt to configure an all-zeroes subnet. To override this enter the global configuration command &lt;strong&gt;ip subnet-zero&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>RIPv2 Authentication</title>
   <link href="http://bsrandall.github.io/rip/2017/04/19/RIPv2-Authentication/"/>
   <updated>2017-04-19T13:56:45-04:00</updated>
   <id>http://bsrandall.github.io/rip/2017/04/19/RIPv2-Authentication</id>
   <content type="html">&lt;p&gt;RFC 1723 for RIPv2 provided for only plain text passwords. This was achieved by reducing the available number of routes in a RIP message from 25 to 24 and including the plain text password in the first route entry. However, there is an Authentication Type field in the RIPv2 message format, and Cisco takes advantage of this to provide better security.&lt;/p&gt;

&lt;p&gt;Cisco decided to offer MD5 authentication by using the first and &lt;em&gt;last&lt;/em&gt; route entries of a RIP message for MD5 authentication. The Authentication Type for this is 3.&lt;/p&gt;

&lt;p&gt;The implementation of RIPv2 authentication requires the use of a key chain. The key chain and mode are then specified under interface configuration mode.
R1 Configuration:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`key chain Tewa
 key 1
 key-string Kachina
interface Ethernet 0
 ip rip authentication key-chain Tewa
 ip rip authentication mode md5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`R2 Configuration:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`key chain Keres
 key 1
 key-string Kachina
interface Ethernet 0
 ip rip authentication key-chain Keres
 ip rip authentication mode md5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
Notice that the key chain names are only locally significant - only the key-strings have to match.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>RIP Configuration</title>
   <link href="http://bsrandall.github.io/rip/2017/04/19/RIP-Configuration/"/>
   <updated>2017-04-19T07:06:45-04:00</updated>
   <id>http://bsrandall.github.io/rip/2017/04/19/RIP-Configuration</id>
   <content type="html">&lt;p&gt;Only two steps are needed to configure RIP.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Enable RIP with the global configuration command &lt;code class=&quot;highlighter-rouge&quot;&gt;router rip&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Specify each major network on which to run RIP with the &lt;strong&gt;network&lt;/strong&gt; command.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The classful nature of RIP means that we can only specify major class A, B, or C networks with the network command.&lt;/p&gt;

&lt;p&gt;If needed, &lt;strong&gt;debug ip rip&lt;/strong&gt; with show RIP messages and activity.&lt;/p&gt;

&lt;p&gt;To block RIP broadcasts on an interface connected to a subnet of a RIP-enabled network, add the &lt;code class=&quot;highlighter-rouge&quot;&gt;passive-interface gig0/1&lt;/code&gt; command to the RIP process. The &lt;strong&gt;passive-interface&lt;/strong&gt; command is not specific to RIP as it can be used with all routing protocols for this purpose.  This will only get the router to quit &lt;strong&gt;sending&lt;/strong&gt; updates. If you want the router to not learn routes advertised across the interface, you must filter those updates.&lt;/p&gt;

&lt;p&gt;Another configuration option is the &lt;strong&gt;neighbor&lt;/strong&gt;  command. If you specify a neighbor, routing exchanges will be done via unicast packets as compared to the normal RIP multicast method. Often, this is used in combination with the &lt;strong&gt;passive-interface&lt;/strong&gt; command on Ethernet interfaces. The passive-interface disables the multicast advertisements but you can then enable advertisement exchange with a single host on the broadcast network via the &lt;strong&gt;neighbor&lt;/strong&gt; command.&lt;/p&gt;

&lt;p&gt;Another configuration issue is that RIPv1 does not support discontiguous networks. Discontiguous networks arise when a major network is separated by a major network. The problem arises because RIP summarizes at the major network boundary. This summarization is done at the classful boundary. If there is one major network between the two discontiguous networks, the RIP routers will receive a summarized route they already have in their routing table, so they will silently drop it. The result is that only half the of the discontiguous network is reachable. If there are two major networks between, then each major network believes it has a route to the summarized network, so they will install two equal-cost routes to the discontiguous network. This again would result in only half the communication being received by the destination network.&lt;/p&gt;

&lt;p&gt;The workarounds for discontiguous networks with RIP would be to install static routes for the individual networks. The other solution is to apply secondary IPs to the interfaces of the in-between major network. These IPs would be from the summarized discontiguous network in question. The RIP routing process sees secondary addresses as separate data links.&lt;/p&gt;

&lt;p&gt;Sometimes with RIP configuration, it may become necessary to manipulate the metric (hop count). This is done with the combination of an &lt;strong&gt;offset-list&lt;/strong&gt; and an access-list. The offset-list adds the number specified to the metric of the route entry matching an access-list. The access-list matches the route for which to apply the offset-list. You use the keywords &lt;strong&gt;in&lt;/strong&gt; and &lt;strong&gt;out&lt;/strong&gt; with the offset-list to determine if the offset-list should change the metric on inbound Response Messages it receives or outbound Response Messages it sends. Here is an example configuration.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`access-list 1 permit 10.33.0.0 0.0.0.0
router rip
  network 192.168.12.0
  network 10.0.0.0
  offset-list 1 in 2 Serial0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;This one says examine RIP advertisements coming in interface Serial 0. If they are for the 10.33.0.0 network (from access-list 1), then add 2 hops to the metric.
&lt;/code&gt;``
`
Another configuration option is triggered updates. RIP will normally broadcast its entire routing table every 30 seconds by default. If no routes are changing, this can be very inefficient on slow links. On an interface, by interface basis, you can issue the command &lt;strong&gt;ip rip triggered&lt;/strong&gt; which will force the routers on that interface to only exchange routes and updates when changes in the topology occur.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>RIP Classful Routing</title>
   <link href="http://bsrandall.github.io/rip/2017/04/19/RIP-Classful-Routing/"/>
   <updated>2017-04-19T06:06:45-04:00</updated>
   <id>http://bsrandall.github.io/rip/2017/04/19/RIP-Classful-Routing</id>
   <content type="html">&lt;p&gt;RIPv1 is a classful routing protocol. This is not quite as black and white as it seems. First, some housekeeping. When we see a route like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R    10.10.0.0 [120/3]() via 10.5.5.1, 00:00:20, Serial1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
The 120/3 is the administrative distance followed by the metric. With RIP, the metric is hop count, so 3 in this route indicates the network is 3 hops away via the Serial1 interface.&lt;/p&gt;

&lt;p&gt;If more than one route exists for a destination, and both routes have the same hop count, then equal-cost load balancing will be performed.&lt;/p&gt;

&lt;p&gt;RIP performs the route lookup by first performing a classful route table lookup.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`Gateway of last resort is not set
10.0.0.0 255.255.0.0 is subnetted, 9 subnets
R    10.10.0.0 [120/3]() via 10.5.5.1, 00:00:20, Serial1
   [120/3]() via 10.1.1.1, 00:00:21, Ethernet0
R    10.11.0.0 [120/3]() via 10.5.5.1, 00:00:21, Serial1
   [120/3]() via 10.1.1.1, 00:00:21, Ethernet0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
So if a packet destined for 10.12.10.2 came into the router, it would first look for 10.0.0.0. If there were no match, the packet is dropped and an ICMP Destination Unreachable message is sent to the packet’s source. If there is a match for the network portion (as there is in this example), then the subnets are examined. If there is a subnet match, the packet is routed. If there is not subnet match, the packet is dropped and a Destination Unreachable message is sent (as would happen with 10.12.10.2).&lt;/p&gt;

&lt;p&gt;If you look at the routing table and examine RIP entries, you will notice there is no provision for RIP to advertise a subnet mask along with each route entry. The router’s only recourse is to assume that the mask configured on one of its interfaces for that address is used consistently throughout the rest of the network.  If the network is not directly connected, there is a listing only for the major-class network and no associated mask.&lt;/p&gt;

&lt;p&gt;Note that since the destination address of packets being routed by a classful routing protocol are interpreted according to the subnet masks locally configured on the router’s interfaces, all subnet masks within a major, class-level network must be consistent.&lt;/p&gt;

&lt;p&gt;In the case above where there is no directly connected network, RIP summarizes at the classful network boundaries. This is called &lt;em&gt;subnet hiding&lt;/em&gt;. So a router would only send advertisements for 10.0.0.0, 172.16.0.0, and 192.169.17.0 for example.&lt;/p&gt;

&lt;p&gt;A good way to summarize is the following:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If the destination address is a member of a directly connected major network, the subnet mask configured on the interface attached to that network will be used to determine the subnet of the destination.&lt;/li&gt;
  &lt;li&gt;If the destination address is not a member of a directly connected major network, the router will try to match only the major class A, B, or C portion of the destination address.&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>RIP Messages</title>
   <link href="http://bsrandall.github.io/rip/2017/04/19/RIP-Messages/"/>
   <updated>2017-04-19T05:06:45-04:00</updated>
   <id>http://bsrandall.github.io/rip/2017/04/19/RIP-Messages</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;/assets/ripformat.png&quot; alt=&quot;RIP Message&quot; /&gt;
Each RIP Message that contains a single command and a version number can contain up to 25 routes. The command is either 1 for a Request Message or 2 for a Response Message. The Version will be 1 for RIPv1.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Address Family Identifier&lt;/em&gt; is set to 2 for IP - the only exception to this is if this is a request for the router’s full route table. In this case, the address family identifier will be 0.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;IP Address&lt;/em&gt; is the address of the destination of the route.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Metric&lt;/em&gt; is the hop count, a value between 1 and 16, with 16 meaning unreachable.&lt;/p&gt;

&lt;p&gt;Request Messages can either request a full routing table or information on a specific route. If the Request message is asking for the full routing table, it will have  the address family identifier set to zero, the address set to 0.0.0.0, and the metric set to 16. A router responds to such a request by sending its full routing table, honoring rules such as split horizon and boundary summarization.&lt;/p&gt;

&lt;p&gt;If the Request message is for a specific route or routes, the router responds differently. If it does not have a route to the route in question, the router responds to the Request message with a metric of 16, otherwise, it responds to the Request listing its own metric. Interestingly, when responding to specific routes the router does not suppress routes due to split horizon or boundary summarization.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>RIP Timers</title>
   <link href="http://bsrandall.github.io/rip/2017/04/19/RIP-Timers/"/>
   <updated>2017-04-19T04:06:45-04:00</updated>
   <id>http://bsrandall.github.io/rip/2017/04/19/RIP-Timers</id>
   <content type="html">&lt;p&gt;There are several timers related to RIP. The &lt;strong&gt;update timer&lt;/strong&gt; on Cisco routers varies between 25.5 and 30 seconds (to prevent synchronization). This is the interval a router waits before sending new periodic Response messages.&lt;/p&gt;

&lt;p&gt;Cisco calls the expiration timer (or timeout) the &lt;strong&gt;invalid timer&lt;/strong&gt;. This is the amount of time a route can stay in the route table without being updated. The default Cisco invalid timer for RIP is 180 seconds (6 Update periods). If an updated route is not heard within the invalid timer, the hop count for the route is changed to 16, the equivalent of making the route unreachable. In IOS, the route in the routing table will say “possibly down” when viewed via &lt;code class=&quot;highlighter-rouge&quot;&gt;show ip route&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;garbage timer&lt;/strong&gt; (or flush timer) is the amount of time the route that was made unreachable by the invalid timer will continue to be advertised.. Once the garbage timer expires, the route will be completely removed from the routing table. With Cisco IOS it is set to 240 seconds by default, 60 seconds longer than the invalid timer.&lt;/p&gt;

&lt;p&gt;RFC 1058 for RIP does not call for the use of &lt;strong&gt;holddown timers&lt;/strong&gt;, but Cisco’s implementation implements it. We saw this earlier - the timer starts when a route is received that is already in the route table, but the new route has a higher hop count than the stored route. It is 180 seconds by default.&lt;/p&gt;

&lt;p&gt;The four timers can be manipulated with the command:
&lt;strong&gt;timers basic&lt;/strong&gt; &lt;em&gt;update invalid holddown flush&lt;/em&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>RIP General</title>
   <link href="http://bsrandall.github.io/rip/2017/04/18/RIP-General/"/>
   <updated>2017-04-18T13:54:45-04:00</updated>
   <id>http://bsrandall.github.io/rip/2017/04/18/RIP-General</id>
   <content type="html">&lt;p&gt;RIP exchanges UDP encapsulated packets over UDP port 520. RIP has two message types:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Request messages&lt;/strong&gt; are used to ask neighboring routers to send an update&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Response message&lt;/strong&gt; carries the actual update&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When a RIP router process starts, it broadcasts a Request message out &lt;em&gt;each&lt;/em&gt; RIP-enabled interface. The begins the state machine with neighbors receiving a RIP request and responding with a RIP Response.&lt;/p&gt;

&lt;p&gt;When the requesting router receives the Response message, it processes the enclosed information and responds in one of 3 ways, depending on the information in the RIP Response.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If a route in the Response is new, it is entered into the route table along with the address of the advertising router.&lt;/li&gt;
  &lt;li&gt;If there is a route for a network that RIP has already entered into the table and the new route has a lower metric (hop count), then the new route will replace the old route.&lt;/li&gt;
  &lt;li&gt;If there is a route for a network that RIP has already entered into the table and the new route has a higher hop count and the update was originated by the recorded next-hop router, the router will be marked as unreachable for a specified holddown period. If the same neighbor is still advertising the higher hop count at the end of the holddown timer, the routing table is updated with the new metric.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;RIP does not store information received in a Topology table, nor do routers have a picture of the entire topology. They receive routes in Response messages, process the information in those messages, and then move on. The RIP Response messages contain that router’s full routing table, with the exception of routes that are stressed by the split-horizon rule.&lt;/p&gt;

&lt;p&gt;Route Summarization means there are no routes for child addresses in the RIP routing table, reducing the size of the table and allowing the router to handle more routes. Summary IP address functions more efficiently than multiple individual advertised IP routes for the following reasons:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The summarized routes in the Rip database are processed first&lt;/li&gt;
  &lt;li&gt;Any associated child routes that are included in a summarized route are skipped as RIP looks through the routing database, reducing the processing time required.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If auto-summary is enabled, as soon as RIP determines a summary address is required in the RIP database, a summary entry is created in the RIP routing database. As long as there are child routes for a summary address, the address remains in the routing database.&lt;/p&gt;

&lt;p&gt;RIPv2 route summarization requires that the lowest metric of an aggregated entry, or the lowest metric of all child routes, be advertised.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;show ip protocols&lt;/strong&gt; command will verify which routes are summarized for an interface.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>IPv6 Stateless Address AUtoconfiguration</title>
   <link href="http://bsrandall.github.io/ipv6%20general/2017/04/17/IPv6-SLAAC/"/>
   <updated>2017-04-17T17:54:45-04:00</updated>
   <id>http://bsrandall.github.io/ipv6%20general/2017/04/17/IPv6-SLAAC</id>
   <content type="html">&lt;p&gt;Stateless Address Autoconfiguration is a mechanism that allows a host to generate its own unicast address using a combination of locally available information and information advertised by routers. Here are the 4 steps:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The host creates its own link-local unicast address by appending a randomly generated or EUI-64 created Interface ID to FE80::/10.&lt;/li&gt;
  &lt;li&gt;The host performs Duplicate Address Detection on its newly created link-local address.&lt;/li&gt;
  &lt;li&gt;The host (if it hasn’t already received one), sends a Router Solicitation message. The Router Advertisement includes the prefix, prefix length, and link MTU. The host uses this information along with its self created Interface ID to create its global unicast address. The default gateway is the Router’s link-local address.&lt;/li&gt;
  &lt;li&gt;The host performs Duplicate Address Detection on its global unicast address before using.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In addition to SLAAC, there is also DHCPv6, which is a stateful process. Whether a host that is configured to obtain its addressing information automatically uses SLAAC or DHCPv6 depends upon the configuration of the router’s Router Advertisement message.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>IPv6 EUI-64 Addressing</title>
   <link href="http://bsrandall.github.io/ipv6%20general/2017/04/17/IPv6-EUI-64/"/>
   <updated>2017-04-17T16:54:45-04:00</updated>
   <id>http://bsrandall.github.io/ipv6%20general/2017/04/17/IPv6-EUI-64</id>
   <content type="html">&lt;p&gt;EUI-64 is an IEEE defined process where EUI stands for Extended Unique Identifier. The EUI-64 process enables automatic Interface ID (host portion) creation. It uses the interface’s Ethernet MAC address to generate a 64-bit interface ID. The idea behind it is that a MAC address is globally unique, so combined with Router Advertisements providing prefix and prefix length, a device can self assign its IP address. The steps of EUI-64 address creation are outlined below.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The MAC address is split in the middle with 24 bits on the left and 24 bits on the right.&lt;/li&gt;
  &lt;li&gt;FFFE is inserted between the 24 bits.&lt;/li&gt;
  &lt;li&gt;The seventh bit is inverted (if it is 0 it becomes 1 and vice versa). The hexadecimal value (since it is the 7th bit or 2nd bit from the right) will go from 0 to 2.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here is an example of how to configure an EUI-64 address on an interface.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# interface gig0/1
R1(config-if)# ipv6 address ipv6-prefix/prefix-length **eui-64**
R1(config-if)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
There are some privacy concerns relating to using a device’s MAC address to generate its Layer 3 address. Because of this, many vendors have replaced the EUI-64 process with a random process to generate the Interface ID.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>IPv6 Neighbor Discovery Protocol</title>
   <link href="http://bsrandall.github.io/ipv6%20general/2017/04/17/IPv6-Neighbor-Discovery-Protocol/"/>
   <updated>2017-04-17T12:54:45-04:00</updated>
   <id>http://bsrandall.github.io/ipv6%20general/2017/04/17/IPv6-Neighbor-Discovery-Protocol</id>
   <content type="html">&lt;p&gt;Neighbor Discovery Protocol (NDP) is used by IPv6 hosts and routers for the following purposes:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Stateless Address Autoconfiguration (SLAAC)&lt;/li&gt;
  &lt;li&gt;Duplicate Address Detection&lt;/li&gt;
  &lt;li&gt;for Layer-2 Data-Link address resolution (similar to IPv4 ARP)&lt;/li&gt;
  &lt;li&gt;to determine if neighbors are reachable (Neighbor Unreachability Detection)&lt;/li&gt;
  &lt;li&gt;when a router fails, a host actively searches for functioning alternates.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Neighbor Discovery uses 5 ICMPv6 messages:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Router Solicitation message&lt;/li&gt;
  &lt;li&gt;Router Advertisement message&lt;/li&gt;
  &lt;li&gt;Neighbor Solicitation message&lt;/li&gt;
  &lt;li&gt;Neighbor Advertisement message&lt;/li&gt;
  &lt;li&gt;Redirect message&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Router Solicitation messages are used by hosts when it needs prefix, prefix length, default gateway, and other information for Stateless Address Autoconfiguration (SLAAC). Router Advertisement messages are the messages used by Routers to convey that information to hosts.&lt;/p&gt;

&lt;p&gt;Neighbor Solicitation and Neighbor Advertisement messages are two more protocols that use ICMPv6 Neighbor Discovery. These messages are used by a device to request Layer 2 link layer address information from another device on the same network or to provide this information to the requesting device. Neighbor Solicitation and Neighbor Advertisement messages are part of three important processes:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Address resolution&lt;/li&gt;
  &lt;li&gt;Duplicate Address Detection (DAD)&lt;/li&gt;
  &lt;li&gt;Neighbor Unreachability Detection (DUD)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;An IPv6 host will maintain two tables for each interface:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Neighbor cache&lt;/li&gt;
  &lt;li&gt;Destination Cache&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Neighbor cache is equivalent to an ARP table in IPv4. The neighbor cache contains mappings of hosts on the same network, while the destination cache contains layer-2 to layer-3 resolutions for devices on other links or networks.  To see the Neighbor table, issue &lt;code class=&quot;highlighter-rouge&quot;&gt;show ipv6 neighbors&lt;/code&gt; command.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>IPv6 Address types</title>
   <link href="http://bsrandall.github.io/ipv6%20general/2017/04/16/IPv6-Address-Types/"/>
   <updated>2017-04-16T14:54:45-04:00</updated>
   <id>http://bsrandall.github.io/ipv6%20general/2017/04/16/IPv6-Address-Types</id>
   <content type="html">&lt;p&gt;There are 3 types of IPv6 addresses:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Unicast&lt;/li&gt;
  &lt;li&gt;Anycast&lt;/li&gt;
  &lt;li&gt;Multicast&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is no “broadcast” type as in IPv4, but an “all nodes” multicast address does exist, which essentially serves the same purpose.&lt;/p&gt;
&lt;h4 id=&quot;unicast&quot;&gt;Unicast&lt;/h4&gt;
&lt;p&gt;A unicast address is an address that identifies a single device. A &lt;em&gt;global&lt;/em&gt; unicast address is one that is assigned to a single host and is globally unique. These are the equivalent of a routable IPv4 address.
&lt;a href=&quot;http://www.cisco.com/c/dam/en/us/td/i/300001-400000/330001-340000/330001-331000/330523.tif/_jcr_content/renditions/330523.jpg&quot;&gt;link&lt;/a&gt;
The host portion of the address is called the Interface ID. This is a more accurate description as a host can have more than one address (as can an interface, but often not).&lt;/p&gt;

&lt;p&gt;IPv6 addresses, unlike IPv4 addresses, have the subnet bits built in as part of the network portion of the address. In IPv4, the subnet bits were borrowed from the host portion. One benefit from this is that the Interface ID can be a consistent length for all IPv6 addresses, simplifying parsing of the address. The Interface ID, with very few exceptions, is 64 bits long. Also, with very few exceptions, the Subnet ID field is 16 bits long, providing for 65,636 separate subnets. This leaves 48 bits for the Global Routing Prefix of the address.&lt;/p&gt;

&lt;p&gt;The currently allocated IPv6 global unicast addresses are 2xxx::/4 through 3xxx::/4. The most common allocation is a /48 global routing prefix, a 16-bit subnet ID, and a 64 bit Interface ID.&lt;/p&gt;

&lt;p&gt;IPv6 also has &lt;em&gt;link-local&lt;/em&gt; unicast address in addition to the global unicast address type. The difference is that a link-local address’ scope is limited to a single link, and its uniqueness in not guaranteed outside of that link. The first 10 bits are always FE80 (1111111010). Link-local addresses have great utility for functions like Neighbor Discovery Protocol and Address Autoconfiguration. They are similar to the 169.254.0.0/16 in IPv4. Link local addresses are never routable. Below is an example configuration in which you will see a subnet is not even declared.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# interface GigabitEthernet0/1
R1(config-if)# ipv6 address FE80::1 link-local
R1config-if)# exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`Link-local addresses are significant only within a single link. Packets with link-local sources or destinations are mostly used by the router’s control plane protocols, such as IPv6 routing protocols.&lt;/p&gt;

&lt;p&gt;There is also &lt;em&gt;unique-local&lt;/em&gt; IPv6 addresses. These are equivalent to IPv4 RFC1918 addresses. They are likely unique, but not routable via global BGP. Thee always start with FC00::/7.&lt;/p&gt;

&lt;h4 id=&quot;anycast&quot;&gt;Anycast&lt;/h4&gt;
&lt;p&gt;An any cast address really represents more of a service than an address. An any cast address can reside on multiple hosts. Routers do not know they reside on different hosts but assume that they have multiple routes to the same host, so a single router simply choses the route to which it has the lowest cost route. Anycast also offers reliable backup, for if a single device goes down, routers will just route to the next lowest-cost available server. There are some reserved Anycast addresses, but for most services, an anycast address is just a global unicast address providing the any cast service.&lt;/p&gt;

&lt;h4 id=&quot;multicast&quot;&gt;Multicast&lt;/h4&gt;
&lt;p&gt;A multicast address identifies a set of devices - a &lt;em&gt;multicast group&lt;/em&gt;. The first 8 bits of a multicast address are always 1s (FF00). The next 4 bits are the Flags. The following 4 bits are the Scope. Finally, the last 112 bits represent the Group ID.&lt;/p&gt;

&lt;h4 id=&quot;address-type-identification&quot;&gt;Address Type Identification&lt;/h4&gt;
&lt;p&gt;| &lt;strong&gt;Address Type&lt;/strong&gt;      | &lt;strong&gt;Binary Prefic&lt;/strong&gt; | &lt;strong&gt;IPv6 notation&lt;/strong&gt; |
| Unspecified  | 00…0 (128 bits) | ::/128 |
| Loopback | 00…1 (128 bits) | ::1/128 |
| Multicast | 11111111 | FF00::/8 |
| Link-local Unicast | 1111111010 | FE80::/10 |
| Unique-local Unicast | 11111100 | FC000::/10 |&lt;/p&gt;

&lt;p&gt;Global unicast addresses are everything else.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>IPv6 Addressing</title>
   <link href="http://bsrandall.github.io/ipv6%20general/2017/04/16/IPv6-General/"/>
   <updated>2017-04-16T13:54:45-04:00</updated>
   <id>http://bsrandall.github.io/ipv6%20general/2017/04/16/IPv6-General</id>
   <content type="html">&lt;p&gt;IPv6 is a 128-bit address compared to IPv4 32-bit address. It is represented as 8 16-bit fields separated by colons. Since these 16-bit fields are written in hex, it is 8 four-digit hex values. A couple of rules exist to shorten the address:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;leading&lt;/em&gt; 0’s of any 16-bit field can be eliminated :00FF can become :FF&lt;/li&gt;
  &lt;li&gt;any single contiguous string of one or more 16-bit segments consisting of all 0’s can be shortened with a double colon - FE80:0000:0000:0000:0000:0000:0000:0001 becomes FE80::1
    &lt;ul&gt;
      &lt;li&gt;however only one double colon is allowed to exist in any address.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Within an IPv6 address, each hexadecimal number represents 4 bits. For example F represents 1111 and 8 represents 1000. IPv6 address format makes it very clear that an address is not something numerical, it is a bit string versus a numerical number. IPv4 often fools people into thinking the address is something that can be quantified when it cannot.&lt;/p&gt;

&lt;p&gt;IPv6 prefixes are always identified with a bitcount. 3ffe:1944:100:a::bc:2500:d0b/64 for example. When you are writing just the prefix, you set the host bits to all 0’s just as you would with an IPv4 address - 3ffe:1944:100:a::/64 would be the prefix of the address above.&lt;/p&gt;

&lt;p&gt;On Cisco routers, IPv6 routing has to be specifically enabled using the global configuration command &lt;strong&gt;ipv6 unicast routing&lt;/strong&gt;. If a router is configured with IPv6 addresses, but IPv6 is not enabled using the &lt;strong&gt;ipv6 unicast routing&lt;/strong&gt; command, then the router is essentially acting as an IPv6 host.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Bidirectional Forwarding Detection</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/10/BFD/"/>
   <updated>2017-04-10T14:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/10/BFD</id>
   <content type="html">&lt;p&gt;Bidirectional Forwarding Detection (BFD) is a protocol that is able to detect link failures within milliseconds or even microseconds between two adjacent routers. Most of the routing protocols have some mechanism to detect down links. OSPF has hello packets and the dead interval, EIGRP uses hello packets and a holddown timer, etc. Unfortunately since these mechanisms depend on the control plane, they are not very fast at determining a failure has occurred. But networks that support real-time traffic such as VoIP require fast convergence times. The closest comparison is reducing timer mechanisms of the routing protocols, but BFD is still faster in every situation.&lt;/p&gt;

&lt;p&gt;BFD was designed to be fast. Its packets can be processed by some interface modules or line cards so there isn’t much overhead. BFD runs independent of routing protocols, but once it is up you can configure the routing protocols to use BFD for link failure detection instead of their own mechanisms. BFD operates in the forwarding place as compared to the control plane mechanisms of routing protocols.&lt;/p&gt;

&lt;p&gt;BFD has two operating modes, asynchronous and demand modes. The asynchronous mode is similar to the hello and holddown timers where BFD will keep sending hello packets (called BFD control packets) and when you don’t receive some of them, the session is torn down. Right now, no vendors support demand mode which relies on polling. Asynchronous mode requires that BFD be enabled and operational on both sides of the link.&lt;/p&gt;

&lt;p&gt;In the Cisco implementation, there is one BFD process that runs, regardless of the number of Layer 3 routing protocols that are dependent upon it. Cisco BED also requires CEF to be enabled.&lt;/p&gt;

&lt;p&gt;Both modes support &lt;strong&gt;echo mode&lt;/strong&gt;. When a device sends BFD echo packets along the forwarding path, the BFD session at the other end does not participate in the actual forwarding of the echo packets. This reduces the number of control packets that have to be sent out and also may slightly increase the link failure detection time as no processing has to occur at the remote end. BFD echo mode is enabled by default.&lt;/p&gt;

&lt;p&gt;You first enable BDF on an interface as below.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(conf)# interface GigabitEthernet0/1
R1(conf-if)# bfs interval *milliseconds* `min_rx` *milliseconds* multiplier *interval-multiplier*
R1(conf-if)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`Really BFD by itself is not useful. You must enable another client or protocol to use BFD for link failure notification for BFD to be of any use. Optional protocols include OSPF, EIGRP, BGP, IS-IS, and HSRP.&lt;/p&gt;

&lt;h4 id=&quot;bgp&quot;&gt;BGP&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# router bgp 2828
R1(config-router)# neighbor 27.143.12.88 **fall-over bfd**
R1(config-router)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#### EIGRP
R1(config)# router eigrp 100
R1(config)# log-adjacency-changes
R1(config-router)# bfd all-interfaces **or**
R1(config-router)# bfd interface GigabitEthernet0/1
R1(config-router)# end
&lt;/code&gt;``
`#### OSPF
There are two methods for enabling BFD support for OSPF:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;You can enable BFD for all interfaces for which OSPF is routing by using the &lt;code class=&quot;highlighter-rouge&quot;&gt;bfd all-interfaces&lt;/code&gt; command in router configuration mode. You can then disable BFD support on individual interfaces using the &lt;code class=&quot;highlighter-rouge&quot;&gt;ip ospf bfd disable&lt;/code&gt; command.&lt;/li&gt;
  &lt;li&gt;You can enable BFD on a per interface basis with &lt;code class=&quot;highlighter-rouge&quot;&gt;ip ospf bfd&lt;/code&gt; command in interface configuration mode.
    &lt;h4 id=&quot;hsrp&quot;&gt;HSRP&lt;/h4&gt;
    &lt;p&gt;You enable bfd to register with HSRP by issuing the &lt;code class=&quot;highlighter-rouge&quot;&gt;standby bfd&lt;/code&gt; interface command or by issuing the &lt;code class=&quot;highlighter-rouge&quot;&gt;standby bfd all-interfaces&lt;/code&gt; command in global configuration mode.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>VRF Lite</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/10/VRF-Lite/"/>
   <updated>2017-04-10T13:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/10/VRF-Lite</id>
   <content type="html">&lt;p&gt;By default, a Cisco router will run using one global routing and forwarding table. VRF Lite gives us the ability to virtualize the physical router into logical routers with their own independent IP routing tables. You can designate interfaces or sub interfaces to be associated with a particular VRF.&lt;/p&gt;

&lt;p&gt;Here is a simple VRF configuration.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# ip vrf red
R1(config-vrf)# exit
R1(config)# ip vrf blue
R1(config-vrf)# exit
R1(config)# interface FastEthernet0/0
R1(config-if)# ip vrf forwarding Blue
R1(config-if)# exit
R1(config)# interface FastEthernet0/1
R1(config-if)# ip vrf forwarding Red
R1(config-if)# exit
R1(config)# router ospf 1 vrf Blue
R1(config-router)# network 192.168.0.0 0.0.0.255 area 0
R1(config-router)# exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
To use ping, you will have to remember to specify the VRF or else the router will use the global routing table.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`ping vrf Blue 1.1.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>On Demand Routing</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/10/On-Demand-Routing/"/>
   <updated>2017-04-10T12:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/10/On-Demand-Routing</id>
   <content type="html">&lt;p&gt;ODR allows you to easily install IP stub networks where the hubs dynamically maintain routes to the stub networks. With ODR, this installation is accomplished without requiring the configuration of an IP routing protocol on the stubs.&lt;/p&gt;

&lt;p&gt;A stub router supporting ODR advertises IP prefixes corresponding to the IP networks configured on all directly connected interfaces. If the network has multiple logical IP networks configured, only the primary IP network is advertised through ODR. ODR is able to pass VLSM information since it sends prefixes. Once ODR is enabled on a hub router, the hub router begins installing sub network routes in the IP forwarding table. The hub router can also be configured to distribute these routes into any configured dynamic IP routing protocols.&lt;/p&gt;

&lt;p&gt;ODR uses Cisco Discovery Protocol (CDP) to carry minimal routing information between the hub and stub routers. The hub router provides default route information to the stubs routers, thereby eliminating the need to configure a default route on each stub router.&lt;/p&gt;

&lt;p&gt;To disallow a particular interface from sending its prefix, disable CDP on that interface.&lt;/p&gt;

&lt;p&gt;To enable ODR, simply issue the following.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(conf)# router odr
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Tunnels and Recursive Routing Errors</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/10/Tunnels-Recursive-Routing-Errors/"/>
   <updated>2017-04-10T11:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/10/Tunnels-Recursive-Routing-Errors</id>
   <content type="html">&lt;p&gt;A recursive routing error occurs when a lookup for prefix X points to prefix Y, and a lookup for prefix Y points to prefix X. This happens with tunnels when the router has learned the destination IP address for the tunnel interface through the tunnel itself. What usually triggers it is enabling the IGP on the tunnel interface. Let’s say the tunnel destination is the loopback of the far end device, and the tunnel IP address is 192.168.13.1. Let there be a router between the two tunnel devices. Normally, the routing table will have a route to reach the loopback via the router in the middle. But once the IGP starts advertising the Tunnel routes, the route for the loopback will be the Tunnel IP address. The route for the Tunnel IP address will be the loopback. This is where our recursion exists.&lt;/p&gt;

&lt;p&gt;The easiest solution is to not advertise the tunnel destination interface in the IGP. Either don’t advertise it or use route filtering.&lt;/p&gt;

&lt;p&gt;The other options to solve are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Ensure the administrative distance of the tunnel destination IP address through the tunnel is higher than what you have in the routing table now&lt;/li&gt;
  &lt;li&gt;Ensure the metric to the tunnel destination IP address through the tunnel is worse than what you have in the routing table now.&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>IP in IP Tunnels</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/10/IP-in-IP-Tunneling/"/>
   <updated>2017-04-10T10:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/10/IP-in-IP-Tunneling</id>
   <content type="html">&lt;p&gt;With GRE Tunnels, IPv4 (or other protocols) are encapsulated in GRE packets. With IP in IP tunnels, IPv6 or IPv4 packets are encapsulated inside IPv4 or IPv6 packets. In IOS, three combinations are possible:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;IPv4 in IPv4 (ipip)&lt;/li&gt;
  &lt;li&gt;IPv6 in IPv6 (ipv6)&lt;/li&gt;
  &lt;li&gt;IPv6 in IPv4 (ipv6ip)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So there is no combination for IPv4 in IPv6. GRE adds the extra capability of encapsulating other protocols other than IP. GRE also allows you to enforce packet sequencing, add an additional checksum, and to specify a tunnel key. Of course, all of these features come at the cost of additional overhead.&lt;/p&gt;

&lt;p&gt;IP in IP tunnels are created the same way as GRE tunnels, you just select a different tunnel mode.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Backup Interface and Keepalives</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/10/Backup-Interface-Keepalive/"/>
   <updated>2017-04-10T09:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/10/Backup-Interface-Keepalive</id>
   <content type="html">&lt;p&gt;By default, the state of a point-to-point GRE interface is determined by routing availability for the tunnel destination, thus as long as the router has a route for the tunnel destination, the tunnel interface state will be UP. However, this does not account for possible transit issues. To fix the problem, GRE keepalives can be enabled on the point-to-point GRE tunnels. The format of the command is &lt;code class=&quot;highlighter-rouge&quot;&gt;keepalive &amp;lt;interval&amp;gt; &amp;lt;number_of_retries&amp;gt;&lt;/code&gt;. The interval defines the frequency in seconds for sending keepalives and the number of retries defines the maximum number of keepalives being sent after the first failed keepalive, before the router changes the tunnel state to DOWN.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>GRE Tunnels</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/09/GRE-Tunnels/"/>
   <updated>2017-04-09T13:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/09/GRE-Tunnels</id>
   <content type="html">&lt;p&gt;A GRE Tunnel is an encapsulated tunnel between two devices that makes the connection act like a point-to-point interface. We are essentially putting packets inside packets; in other words, we are encapsulating the IP packets into GRE packets.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://networklessons.com/wp-content/uploads/2013/04/three-cisco-routers-with-tunnel.png&quot;&gt;link&lt;/a&gt;
We will use the above figure to create a sample tunnel between the HQ and Branch routers.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`HQ(config)#interface tunnel 1     
HQ(config-if)#tunnel source fastEthernet 0/0
HQ(config-if)#tunnel destination 192.168.23.3
HQ(config-if)#ip address 192.168.13.1 255.255.255.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-`&quot;&gt;`Branch(config)#interface tunnel 1
Branch(config-if)#tunnel source fastEthernet 0/0
Branch(config-if)#tunnel destination 192.168.12.1
Branch(config-if)#ip address 192.168.13.3 255.255.255.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;`
The default tunneling mode is GRE so it is not required to set it explicitly in this case.&lt;/p&gt;

&lt;p&gt;Notice we are setting the destination address to be the outside interface that is reachable over the un-encapsulated network. You can also use loopback addresses.&lt;/p&gt;

&lt;p&gt;Some options that GRE tunneling supports are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;add an additional checksum&lt;/li&gt;
  &lt;li&gt;specify a tunnel key&lt;/li&gt;
  &lt;li&gt;enforce packet sequencing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Those options are seen under the &lt;strong&gt;tunnel&lt;/strong&gt; subcommand in interface configuration mode.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`Router(config-if)# tunnel ?
  bandwidth           Set tunnel bandwidth informational parameter
  **checksum            enable end to end checksumming of packets**
  destination         destination of tunnel
  flow                flow options
  **key                 security or selector key**
  mode                tunnel encapsulation method
  mpls                MPLS tunnel commands
  path-mtu-discovery  Enable Path MTU Discovery on tunnel
  protection          Enable tunnel protection
  rbscp               Set tunnel RBSCP parameters
  route-via           Select subset of routes for tunnel transport
  **sequence-datagrams  drop datagrams arriving out of order**
  source              source of tunnel packets
  tos                 set type of service byte
  ttl                 set time to live
  udlr                associate tunnel with unidirectional interface
  vrf                 set tunnel vrf membership
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Policy Routing Order of Operation</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/09/Policy-Routing-Order-Of-Operation/"/>
   <updated>2017-04-09T12:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/09/Policy-Routing-Order-Of-Operation</id>
   <content type="html">&lt;p&gt;A route-map can have multiple set operations on a single match clause. The list below shows the order of operations, regardless of the sequence number we use or the order we input them.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set ip next-hop verify-availability track&lt;/code&gt; - first when used with object tracking&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set ip next-hop&lt;/code&gt; - alone or with the CDP (but without default) version of &lt;code class=&quot;highlighter-rouge&quot;&gt;verify-availability&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set ip next-hop recursive&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;set interface&lt;/li&gt;
  &lt;li&gt;Route table&lt;/li&gt;
  &lt;li&gt;set ip default next-hop&lt;/li&gt;
  &lt;li&gt;set default interface&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Policy Routing using next-hop, default, and recursive</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/09/Policy-Routing-Default-Next-Hop/"/>
   <updated>2017-04-09T11:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/09/Policy-Routing-Default-Next-Hop</id>
   <content type="html">&lt;p&gt;When using policy routing and the &lt;code class=&quot;highlighter-rouge&quot;&gt;ip next-hop&lt;/code&gt; set option in a route map, you can optionally use the &lt;em&gt;default&lt;/em&gt; keyword. The difference is simple.&lt;/p&gt;

&lt;p&gt;When you do not use the default keyword, routing utilizes PBR first and consults the routing table if there is no match or non reachability. If you use the default keyword, then routing uses the routing table first and if no route can be found then attempts to use the Policy Based Routing process.&lt;/p&gt;

&lt;p&gt;Both the &lt;code class=&quot;highlighter-rouge&quot;&gt;set ip next-hop&lt;/code&gt; and the &lt;code class=&quot;highlighter-rouge&quot;&gt;set ip default next-hop&lt;/code&gt; commands require that the next-hop be found on a directly-connected subnet, otherwise PBR will fail and normal forwarding will be used. However, we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;set ip next-hop recursive&lt;/code&gt; to use an address off a subnet that &lt;em&gt;is not&lt;/em&gt; directly connected.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PBR - verify-availability</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/09/Policy-Routing-Verify-Availability/"/>
   <updated>2017-04-09T10:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/09/Policy-Routing-Verify-Availability</id>
   <content type="html">&lt;p&gt;Within the route-map statement, there is an option when using &lt;code class=&quot;highlighter-rouge&quot;&gt;ip next-hop&lt;/code&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;verify-availability&lt;/code&gt;. This article will describe what it does and the two flavors of utilization.&lt;/p&gt;

&lt;p&gt;If used solely by itself, &lt;code class=&quot;highlighter-rouge&quot;&gt;verify-availabilty&lt;/code&gt; uses CDP to establish that the next-hop IP address is reachable. If the IP address used is in the CDP neighbor table, then the next-hop is deemed accessible, otherwise it is not.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;verify-availability&lt;/code&gt; can be extended to also use a tracking object. Here is an example of that configuration.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R2(config)#route-map PBR permit 10
R2(config-route-map)#match ip address HTTP-SERVER
R2(config-route-map)#set ip next-hop verify-availability 192.168.24.4 1 track 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
If using either of these methods to implement &lt;/code&gt;verify-reachability`, if the next-hop IP address is not reachable then routing is not performed based on the policy but is routed according to the the routing table.&lt;/p&gt;

&lt;p&gt;We can use a combination of commands to route a different way if our &lt;code class=&quot;highlighter-rouge&quot;&gt;verify-reachability&lt;/code&gt; fails.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# route-map RM1
R1(config-route-map)# match ip address AL1
R1(config-route-map)# set ip next-hop 155.1.0.5
R1(config-route-map)# set ip next-hop verify reachability
R1(config-route-map)# set ip default next-hop 155.1.13.3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`In this example, if we match to AL1 AND 155.1.0.5 is reachable (CDP check), then we route to 155.1.0.5. However if we match AL1 and 155.1.0.5 is not in the CDP neighbor table, then we route to 155.1.13.3.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Local Policy Routing</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/08/Local-Policy-Routing/"/>
   <updated>2017-04-08T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/08/Local-Policy-Routing</id>
   <content type="html">&lt;p&gt;In a previous post, we saw how policy based routing can be used to change the next hop IP address for traffic matching certain criteria that is passing through the router. But what about traffic that originates on the router?&lt;/p&gt;

&lt;p&gt;It is very similar but we use a different source on our access-lists (obviously) and we use a different command (global instead of sub-interface) to activate it.&lt;/p&gt;

&lt;p&gt;Let’s assume our router has interfaces on the 192.168.12.0/24 and 192.168.13.0/24 subnets. Let’s set up Local Policy Routing to ensure that traffic originated on these interfaces and destined for 4.4.4.4 is sent to a next-hop IP address of 192.168.13.3. First, we set up our access lists.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# ip access-list extended ICMP-R1
R1(config-ext-nacl)# permit imp host 192.168.12.1 host 4.4.4.4
R1(config-ext-nacl)# permit imp host 192.168.13.1 host 4.4.4.4
R1(config)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`Now the next step would be to use a route map to set the next hop IP when we have a match.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# route-map PBR-R1 permit 10
R1(config-route-map)# match ip address ICMP-R1
R1(config-route-map)# set ip next-hop 192.168.13.3
R1(config)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`Now, we must make sure we activate it. Unlike with policy based routing, for local policy routing we enable it globally.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(conf)# ip local policy route-map PBR-R1
R1(conf)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
That is all!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Policy Based Routing</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/07/Policy-Routing/"/>
   <updated>2017-04-07T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/07/Policy-Routing</id>
   <content type="html">&lt;p&gt;Policy-based routing can be used to change the next-hop IP address for traffic matching certain criteria. This can be useful to overrule the routing table for certain types of traffic. For example you may want to force all traffic from a certain host to use an alternate link. The key to making this work is an access-list and a route map.&lt;/p&gt;

&lt;p&gt;For example, let’s assume that we want all ICMP traffic from host 192.168.1.100 to traverse a link whose next hop is 192.168.13.3 if the destination IP address is 4.4.4.4. We can use an extended access list to classify the traffic.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# ip access-list extended ICMP-H1
R1(config-ext-nacl)# permit imp host 192.168.1.100 host 4.4.4.4
R1(config)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`Now the next step would be to use a route map to set the next hop IP when we have a match.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# route-map PBR-H1 permit 10
R1(config-route-map)# match ip address ICMP-H1
R1(config-route-map)# set ip next-hop 192.168.13.3
R1(config)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`Now, we must make sure we activate it on the ingress interface.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# interface GigabitEthernet0/1
R1(config-if)# ip policy route-map PBR-H1
R1(config)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
&lt;/code&gt;debug ip policy` will turn debugging on for policy routing.&lt;/p&gt;

&lt;p&gt;This configuration is for traffic passing &lt;em&gt;through&lt;/em&gt; the router. To apply policy based routing for traffic that is 8originated8 by the router, see the next post “Local Policy Routing”.&lt;/p&gt;

&lt;p&gt;One thing to remember is that there can only be one ip policy on the interface, so if you need to perform multiple actions, you may have to use a route map with multiple sections like this.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# route-map RM-R4-R6 permit 20
R1(config-route-map)# match ip address FROM-R4
R1(config-route-map)# set ip next-hop 155.146.13.1
R1(config-route-map)# route-map RM-R4-R6 permit 20
R1(config-route-map)# match ip address FROM-R6
R1(config-route-map)# set ip next-hop 155.1.0.5
R1(config-route-map)# exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
Some important show commands are listed below:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1#sh ip policy
Interface      Route map
Gi0/1.146      RM-R4-R6
R1\#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-`&quot;&gt;`R1#show route-map
route-map RM-R4-R6, permit, sequence 10
  Match clauses:
ip address (access-lists): FROM_R4
  Set clauses:
ip next-hop 155.1.13.3
  Policy routing matches: 18 packets, 1116 bytes
route-map RM-R4-R6, permit, sequence 20
  Match clauses:
ip address (access-lists): FROM_R6
  Set clauses:
ip next-hop 155.1.0.5
  Policy routing matches: 9 packets, 564 bytes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;`&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Enhanced Object Tracking</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/06/Enhanced-Object-Tracking/"/>
   <updated>2017-04-06T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/06/Enhanced-Object-Tracking</id>
   <content type="html">&lt;p&gt;Enhanced Object Tracking is a sort of glue that binds the tracking of objects with upper layer protocols such as HSRP. Before Enhanced Object Tracking, HSRP could only look at interface line-protocol state for simple up / down status. Now you can create an advanced object (such as  an IP SLA object) and keep HSRP informed of the state of that object by using Enhanced Object Tracking.&lt;/p&gt;

&lt;p&gt;Enhanced Object Tracking provides complete separation between the objects to be tracked and the action to be taken by a client when a tracked object changes. The tracking process periodically polls the tracked object and notes any change of value. The changes can be communicated immediately or after a delay to the interested client process.&lt;/p&gt;

&lt;p&gt;Enhanced Object Tracking is used with IP SLA to track the output from IP SLA objects and use the provided information to trigger an action. Every IP SLA operation maintains a return-code value. Two aspects of an IP SLA operation can be tracked, state and reachability. The difference between these is the acceptance of the OverThreshold return code. The table below shows the state and reachability aspects of IP SLA operations that can be tracked.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Tracking&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Return Code&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;Track State&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;State&lt;/td&gt;
      &lt;td&gt;OK&lt;/td&gt;
      &lt;td&gt;Up&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Reachability&lt;/td&gt;
      &lt;td&gt;OK or OverThreshold&lt;/td&gt;
      &lt;td&gt;Up&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;For both State and Reachability, all other return codes return down.&lt;/p&gt;

&lt;h4 id=&quot;examples&quot;&gt;Examples&lt;/h4&gt;

&lt;p&gt;The first example is IP-Route Reachability. This tracks the reachability of a particular IP Route. A tracked object is considered up when a routing table entry exists for the route and the route is accessible.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# track timer ip route 20
R1(config)# track 4 ip route 10.16.0.0/16 reachability
R1(config-track)# delay up 30
R1(config)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;In the above example, the &lt;/code&gt;track timer` is an optional command that specifies an interval in which the tracking object polls the tracked object. The default for IP-Route Reachability is 15 seconds.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;delay&lt;/code&gt; option specifies a period of time to delay communicating state changes of a tracked object.&lt;/p&gt;

&lt;p&gt;The next example is using Tracking to poll an IP SLA operation. First we set up the IP SLA operation.&lt;/p&gt;

&lt;p&gt;R1(config)# ip sla 1
R1(config-ip-sla)# icmp-echo 150.1.3.3
R1(config-ip-sla-echo)# frequency 30
R1(config-ip-sla-echo)# exit
R1(config)# ip spa schedule 1 start-time now life 10800
R1(config)# exit&lt;/p&gt;

&lt;p&gt;Next, we set up the tracking.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`R1(config)# track 1 ip sla 1 state
R1(config)# delay up 60 down 30
R1(config)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
Now the tracking object can be used by other clients to monitor the IP SLA object we set up earlier. One interesting note here. We could have used state or reachability for our tracking object. The only difference with ICMP echo operation is that reachability also ensures that the latency is less than 5000ms&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Backup Interface</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/05/Backup-Interface/"/>
   <updated>2017-04-05T12:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/05/Backup-Interface</id>
   <content type="html">&lt;p&gt;Backup Interface is a Cisco feature that can be used in place of floating static routes on point-to-point interfaces.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Serial0/0/0
  backup interface Serial0/0/1
  backup delay 10 30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;In the example above interface Serial0/0/1 is the backup for interface Serial0/0/0. If Serial0/0/0 is down for 10 seconds, then Serial0/0/1 will take over as the primary interface. After Serial 0/0/0 has been up for 30 seconds, it will resume its role as the primary interface.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Floating Static Routes</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/05/Floating-Static-Routes/"/>
   <updated>2017-04-05T11:46:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/05/Floating-Static-Routes</id>
   <content type="html">&lt;p&gt;A Floating Static route is a static route whose administrative distance has been increased in order to make the route function as a backup route. The global command would look like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip route 192.168.23.0 255.255.255.0 192.168.13.3 121
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;This would set the administrative distance to this route as 121, which would make it’s AD higher than a RIP, OSPF, or EIGRP learned route.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CEF</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/05/CEF/"/>
   <updated>2017-04-05T11:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/05/CEF</id>
   <content type="html">&lt;p&gt;Routing is the process by which the router finds the interface to send outgoing packets out of. Switching is the actual process of physically transferring this packets from the ingress interface to the degree interface,&lt;/p&gt;

&lt;p&gt;Process Switching is the oldest of the switching methods available in Cisco devices. When a packet arrives, the switching process relies on the CPU to do start at the top of the RIB and for each route do a binary AND against the destination to determine the longest match. It has to do this for every packet as it arrives. The time it may take for a lookup is dependent on where the route sits in the forwarding table, so your worst case scenario is the router would have to do 100,000 lookups.&lt;/p&gt;

&lt;p&gt;Fast Switching is an improvement on Process Switching where a lookup only has to be done on the first inbound packet. The rest of the “flow” knows the switching path and utilizes what was learned from the lookup on the first packet.&lt;/p&gt;

&lt;p&gt;Cisco Express Forwarding is the modern switching process found in Cisco devices. Once the router builds the RIB, the router pre calculates the routes and then stores these calculations in working memory, or in the case of devices that perform hardware acceleration, in port based ASICs.&lt;/p&gt;

&lt;p&gt;To see the CEF calculated for a given route, use &lt;code class=&quot;highlighter-rouge&quot;&gt;show ip cef 192.168.1.10&lt;/code&gt;, for example.&lt;/p&gt;

&lt;p&gt;One thing to remember is that the switching process is responsible for load balancing. This is done on a flow basis, not on a per packet basis as that would be too inefficient and packets would almost always arrive out of order on the other end.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;show ip interface&lt;/code&gt; will tell you if CEF has been enabled. A key indicator of a router that does not have CEF enabled is one that has high CPU usage. It is also important to remember that packets that are logged do not get CEF switched, so any logging requires a lot of available CPU.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Egress Interface vs Next Hop Static Routing</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/04/Egress-Interface-vs-Next-Hop/"/>
   <updated>2017-04-04T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/04/Egress-Interface-vs-Next-Hop</id>
   <content type="html">&lt;p&gt;There are some difference on router behavior depending on if you use a Next Hop IP address or an Egress Interface as the destination in your static route. This article will describe some of this e differences.&lt;/p&gt;

&lt;p&gt;If you use the Next Hop IP address, the router will have to find the interface leading towards the destination address before the route will be installed in the forwarding table. When the router finds the egress interface it will then check to see if the interface is point-to-point or multipoint. If it is multipoint, then the router will need the MAC address of the Next Hop address. If it doesn’t have it, then it will need to use ARP.&lt;/p&gt;

&lt;p&gt;If you use the outgoing interface the router does not have to do the recursive lookup to find the correct outgoing interface. But the problem is the router doesn’t know which layer 2 neighbor routers exist on that link. So the only choice the router has is to ARP for the final destination address (rather than next hop as above). Where this can get outrageous is that the router will need to have MAC addresses resolved for &lt;em&gt;all hosts&lt;/em&gt; in the subnet and you will need proxy ARP enabled on all routers in the segment. The example gets even more outrageous if you define a default route that points to a multipoint interface. So it should be clear this should only be used on point-to-point interfaces.&lt;/p&gt;

&lt;p&gt;Point-to-point interfaces do not have the same problem as the router knows there is only one host to receive the traffic on the other end. In other words, recursion will not be required nor will Layer 2 resolution be required.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Default Routing</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/04/Default-Routing/"/>
   <updated>2017-04-04T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/04/Default-Routing</id>
   <content type="html">&lt;p&gt;Because of route recursion and the need for Layer 2 lookups on multipoint interfaces, default routing should be set up in one of two ways:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;to a next hop IP address if the interface is multipoint or point-to-point&lt;/li&gt;
  &lt;li&gt;to an interface ONLY if the interface is point-to-point.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One issue with default routes is that you lose a lot of the routing detail. One way this shows itself is the fact that sites with default routes will have no idea if the end destination network is available. Another issue with the loss of detail has to do with having multiple default routes. With only having default routes, there is no routing details to show which is the better path to reach the end destination.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Route Recursion</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/03/Route-Recursion/"/>
   <updated>2017-04-03T11:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/03/Route-Recursion</id>
   <content type="html">&lt;p&gt;Every time a router has to do a router lookup, a recursive lookup will be performed, unless the destination is directly connected. When a route lists an IP address as the next hop, unless that next hop is directly connected the router must find the path to that route. It may have to work through multiple recursions in order to eventually find the correct interface to route out of.&lt;/p&gt;

&lt;p&gt;When a particular interface goes down, all routes depending on that interface are removed from the RIB. One important thing to remember here is that the route is only removed if the next hop IP address is not reachable - if there is a secondary path via another interface, then that route will remain valid. However, if you use the interface as the destination for the static route, then the route will fail.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Static Routing</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/03/Static-Routing/"/>
   <updated>2017-04-03T10:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/03/Static-Routing</id>
   <content type="html">&lt;p&gt;Static routes do have some advantages over dynamic routing:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;static routes are not advertised over the network by default, resulting in better security&lt;/li&gt;
  &lt;li&gt;static routes use less bandwidth than dynamic routing protocols, as there is no exchange of routes&lt;/li&gt;
  &lt;li&gt;no CPU cycles are used to calculate and communicate routes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Static routes have some disadvantages as well:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;initial configuration and maintenance is time consuming&lt;/li&gt;
  &lt;li&gt;does not scale well&lt;/li&gt;
  &lt;li&gt;requires complete knowledge of the whole network for proper implementation.&lt;/li&gt;
  &lt;li&gt;can interfere with the use of backup routes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With backup routes, if the outage occurs downstream in the network, a router with a static route to a destination will never utilize the backup route, because it still sees a path to the destination from the backup route. To get around this, use an outbound interface as well as the destination IP in the static route as in &lt;code class=&quot;highlighter-rouge&quot;&gt;R1(config)# ip route 10.0.0.0 255.255.255.0 FastEthernet0/1 192.168.10.1&lt;/code&gt;. The other option is to of course use a dynamic routing protocol and then the route will be removed&lt;/p&gt;

&lt;p&gt;To set up a static route, use the following syntax:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip route 192.168.18.0 255.255.255.0 192.168.17.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;This would route any traffic destined for 192.168.18.0/24 to 192.168.17.1.&lt;/p&gt;

&lt;p&gt;To set up a default route, use the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip route 0.0.0.0 0.0.0.0 192.168.17.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;You could also specify an interface, but the better way is to use an IP address so no lookups are required.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Administrative Distance</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/02/Administrative-Distance/"/>
   <updated>2017-04-02T11:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/02/Administrative-Distance</id>
   <content type="html">&lt;p&gt;Administrative Distance is used to determine which route should be installed into the IP routing table when there is a tie between different sources for the route (static vs EIGRP vs OSPF, etc). Administrative Distance is sometimes called the trustworthiness of the source. When a decision has to be made, the table containing Administrative Distance is consulted to choose the best route, with lower being better. Administrative Distance is only local and can be different for each router.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;distance&lt;/code&gt; command is used with the different routing protocols to change its Administrative Distance. Here is a list&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Routing Protocol&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;AD&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Directly connected&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Static route&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EIGRP Summary&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;External BGP&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EIGRP&lt;/td&gt;
      &lt;td&gt;90&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IGRP&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OSPF&lt;/td&gt;
      &lt;td&gt;110&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IS-IS&lt;/td&gt;
      &lt;td&gt;115&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RIP&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ODR&lt;/td&gt;
      &lt;td&gt;160&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;External EIGRP&lt;/td&gt;
      &lt;td&gt;170&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Internal BGP&lt;/td&gt;
      &lt;td&gt;200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Unknown&lt;/td&gt;
      &lt;td&gt;255&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</content>
 </entry>
 
 <entry>
   <title>Longest Match Routing</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/02/Longest-Match-Routing/"/>
   <updated>2017-04-02T10:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/02/Longest-Match-Routing</id>
   <content type="html">&lt;p&gt;Longest Match Routing is the idea that a packet will follow the most specific route entry that it matches. So if there was a host route (/32) that existed for the destination, the host route would have precedence over any shorter prefix such as a /24.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>IPv4 ARP</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/02/ARP/"/>
   <updated>2017-04-02T09:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/02/ARP</id>
   <content type="html">&lt;p&gt;Address Resolution Protocol (ARP) is used to determine the data-link identifier (MAC address) of a host with a known IPv4 address. The ARP request packet contains the IPV4 address of the device in question (the target), as well as the IPv4 and MAC address of the device making the request (the sender). The ARP packet is then encapsulated in a frame with the sender’s MAC address as the source and a broadcast address for the destination. The target will send an ARP Reply to the source address, supplying its MAC address. The ARP reply will lest the target as the original sender.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1# show arp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The command above will display the ARP table on a Cisco router.&lt;/p&gt;

&lt;p&gt;Cisco routers hold ARP entries for 4 hours by default. It can be changed on a per-interface basis with the &lt;code class=&quot;highlighter-rouge&quot;&gt;arp timeout seconds&lt;/code&gt; interface subcommand.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clear arp-cache&lt;/code&gt; can be used to delete all dynamic entries from the ARP table. It will also clear the fast-switching cache as well as the IP route cache.&lt;/p&gt;

&lt;p&gt;Proxy ARP is a variation of ARP that is sometimes called promiscuous ARP. This is the method of how router’s will replay to an ARP request if they have a route to a host on another subnet. The router will send it’s own MAC address as a reply to the ARP request to trick the host into thinking it is the actual host in question. Proxy ARP is enabled by default in Cisco IOS and can be disabled on a per-interface basis with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;no ip proxy-arp&lt;/code&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>IPv4 Addressing</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/04/02/IPv4-Addressing/"/>
   <updated>2017-04-02T08:40:45-04:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/04/02/IPv4-Addressing</id>
   <content type="html">&lt;p&gt;IP is a logical addressing method as compared to MAC layer physical addresses. It operates at the Network Layer (Layer 3) of the OSI model.&lt;/p&gt;

&lt;p&gt;An address mask is used to identify the network and host portions of the address.  It is 32-bits long, the same length as an IPv4 address. In general, an address mask is assigned to a network or an organization. The organization then subnets that address mask into per data-link subnet masks for assignment.&lt;/p&gt;

&lt;p&gt;The number of available subnets under a major address mask and the number of hosts on each subnet are both calculated with the same formula 2^n-2.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PPPoE</title>
   <link href="http://bsrandall.github.io/layer%202%20wan/2017/04/01/PPPoE/"/>
   <updated>2017-04-01T14:40:45-04:00</updated>
   <id>http://bsrandall.github.io/layer%202%20wan/2017/04/01/PPPoE</id>
   <content type="html">&lt;p&gt;PPPoE allows us to establish a PPP link over an Ethernet connection. ISPs were the main ones to use this as it gave them authentication capabilities over Ethernet, in a manner that was familiar to them from their dial-up days. There are two sides to the configuration, both a client and a server. We will start with the server side first.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Server(config)# bba-group pope global
Server(config-bba-group)# virtual-template 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The BBA group (Broadband Access) above is only needed if you want to run more than one PPPoE session.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Server(config)# interface virtual-template 1
Server(config-if)# ip address 192.168.12.2 255.255.255.0
Server(config-if)# mtu 1492
Server(config-if)# peer default address pool CLIENT
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Notice we have to reduce the MTU by 8 bytes due to the PPPoe overhead. Next we create the CLIENT IP address pool:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Server(config)# ip local pool CLIENT 192.168.12.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Finally, we just need to activate the BBA group on the interface.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Server(config)# interface FastEthernet0/0
Server(config-if)# pppoe enable group global
Server(config-if)# exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now we move on to the Client:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Client(config)# interface dialer 1
Client(config-if)# mtu 1492
Client(config-if)# encapsulation ppp
Client(config-if)# ip address negotiated
Client(config-if)# dialer persistent
Client(config-if)# dialer pool 1

Client(config)# interface FastEthernet0/0
Client(config-if)# pppoe-client dial-pool-number 1
Client(config-if)# exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The dialer persistent command nails the connection up.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PPP Multilink</title>
   <link href="http://bsrandall.github.io/layer%202%20wan/2017/04/01/Multilink-PPP/"/>
   <updated>2017-04-01T13:40:45-04:00</updated>
   <id>http://bsrandall.github.io/layer%202%20wan/2017/04/01/Multilink-PPP</id>
   <content type="html">&lt;p&gt;Multilink PPP is a method used to aggregate multiple single PPP links and utilize them as one. It is not that dissimilar from EtherChannel used with Ethernet. PPP frames can be fragmented, sent down different links, and then reassembled in order on the far side of the link. Multilink PPP uses a 2 or 4 byte sequencing header in each packet, and the remote MLPPP recover is tasked with reconstructing the frames in the correct order. The configuration is pretty straightforward.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Serial0/1
  description Link to R1
  no ip address
  encapsulation ppp
  ppp multilink
  ppp multilink group 1
  serial restart-delay 0
end

interface Serial1/1
  description Link to R1
  no ip address
  encapsulation ppp
  ppp multilink
  ppp multilink group 1
  serial restart-delay 0
end

interface Multilink 1
  ip address 192.168.12.2 255.255.255.0
  ppp multilink
  ppp multilink group 1
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Some optional parameters include &lt;code class=&quot;highlighter-rouge&quot;&gt;ppp multilink interleave&lt;/code&gt;. Interleaving allows large packets to be multilink encapsulated and fragmented into a small enough size to satisfy the delay requirements of real-time traffic. The interleaving feature also provides a special transmit queue for the smaller, delay-sensitive packets, enabling them to be sent earlier than other flows. &lt;code class=&quot;highlighter-rouge&quot;&gt;ppp multilink fragement delay 10&lt;/code&gt; is the command that determines the maximum delay - MLPPP will then chose a fragment size based on the configured delay.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>PPP Authentication</title>
   <link href="http://bsrandall.github.io/layer%202%20wan/2017/04/01/PPP-Authentication/"/>
   <updated>2017-04-01T12:40:45-04:00</updated>
   <id>http://bsrandall.github.io/layer%202%20wan/2017/04/01/PPP-Authentication</id>
   <content type="html">&lt;p&gt;There are two forms of authentication available for PPP, PAP and CHAP. It is important to remember that these technologies are one way in nature, and therefore do not need to be configured bidirectionally. You really should think of this as a Client / Server model.&lt;/p&gt;

&lt;p&gt;With PAP authentication, a two-way handshake is used to establish identity. After the PPP link establishment is complete, a username and password pair is repeatedly sent by the remote node (in clear text) until authentication is acknowledged, or the connection is terminated. PPP is not secure as passwords are sent across the link in clear text.&lt;/p&gt;

&lt;p&gt;PAP supports either unidirectional or bidirectional authentication. This is the configuration for unidirectional, where R1 is the called device and R2 is the calling device:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1(config)# username ROUTER2 password cisco
R1(config)# interface serial0/0
R1(config-if)# encapsulation ppp
R1(config-if)# ppp authentication pap
R1(config-if)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;And here is the configuration for R2, the client:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R2(config)# interface serial0/0
R2(config-if)# encapsulation ppp
R2(config-if)# ppp pap sent-username ROUTER2 password cisco
R2(config-if)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CHAP identifies peers by use of a three-way handshake. The general steps are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;After the LCP phase is complete, and CHAP is established as the authentication protocol between devices, the authenticator sends a challenge message to the peer&lt;/li&gt;
  &lt;li&gt;The peer responds with a value calculated through a one-way hash function (MD5)&lt;/li&gt;
  &lt;li&gt;The authenticator checks the response against its own calculation of the expected hash value. If the values match, the authentication is successful, otherwise the connection is terminated.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Like PAP, authentication is one-way but can be configured bidirectionally. In this example, R1 is the CHAP server and R2 is the CHAP client.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1(config)# username ROUTER2 password cisco
R1(config)# interface serial0/0
R1(config-if)# encapsulation ppp
R1(config-if)# ppp authenticate chap
R1(config-if)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;And now,  R2 (the client) configuration:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R2(config)# username ROUTER1 password cisco
R2(config)# interface serial0/0
R2(config-if)# encapsulation ppp
R2(config-if)# end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>PPP</title>
   <link href="http://bsrandall.github.io/layer%202%20wan/2017/04/01/PPP/"/>
   <updated>2017-04-01T11:40:45-04:00</updated>
   <id>http://bsrandall.github.io/layer%202%20wan/2017/04/01/PPP</id>
   <content type="html">&lt;p&gt;PPP stands for point-to-point protocol - it is  a very popular method for establishing a serial connection over which to pass IP traffic. PPP is composed of Link Control Protocol (LCP) as well as a family of NCPs used to establish network-layer links for various protocols (such as IPv4) after LCP has established the basic link. The steps to enable PPP on a Cisco router are shown below.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1(config)# interface serial0/0
R1(config-if)# encapsulation ppp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>HDLC</title>
   <link href="http://bsrandall.github.io/layer%202%20wan/2017/04/01/HDLC/"/>
   <updated>2017-04-01T10:40:45-04:00</updated>
   <id>http://bsrandall.github.io/layer%202%20wan/2017/04/01/HDLC</id>
   <content type="html">&lt;p&gt;HDLC is a Layer 2 protocol - the Cisco version is a slight tweak from the original ISO version, so Cisco HDLC will not operate with HDLC implementations from other vendors. It is used on serial interfaces to make direct connections between routers. It is actually the default point-to-point serial protocol for Cisco routers, but PPP is more commonly used.&lt;/p&gt;

&lt;p&gt;You must always remember when connecting two serial interfaces, the DCE side must set a clock rate.&lt;/p&gt;

&lt;p&gt;If you are changing back from PPP to HDLC, the following shows how you would accomplish it.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1(config)# interface serial0/0
R1(config-if)# encapsulation hdlc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Voice VLAN</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/30/Voice-VLAN/"/>
   <updated>2017-03-30T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/30/Voice-VLAN</id>
   <content type="html">&lt;p&gt;On Cisco switch’s, you can configure a particular VLAN known as the voice VLAN. It is a special VLAN that Cisco developed that is meant to lead from the switch the the 3 port switch on the back of an IP Phone. The traffic from the computer will be sent untagged, regardless of whether the access VLAN for that port is the default VLAN. All traffic from the phone gets tagged to its assigned voice VLAN. It behaves in many way like a trunk, but from an operational perspective it is still a port in access mode. The configuration looks like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface GigabitEthernet0/1
SW1(config-if)# switchport mode access
SW1(config-if)# switchport access vlan 100
SW1(config-if)# switchport voice vlan 101
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;If you you show commands, you will not find the interface to be in trunk operational mode, but remember it works like a rudimentary trunk.&lt;/p&gt;

&lt;p&gt;As soon as you apply the &lt;code class=&quot;highlighter-rouge&quot;&gt;switchport voice vlan&lt;/code&gt; command, Portfast is enabled on the interface, though you will not see it in the running-config.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Storm Control</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/30/Storm-Control/"/>
   <updated>2017-03-30T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/30/Storm-Control</id>
   <content type="html">&lt;p&gt;Broadcast storms can create havoc on a Layer 2 network, quickly bringing the network to an unusable state. Software solutions to storm control are inefficient, because by the time the software has identified the storm, the hardware resources are at max utilization and there is no resources available to abate the storm.&lt;/p&gt;

&lt;p&gt;Cisco has a storm control feature built into its switches. It is a hardware based solution that allows us to set a threshold on interfaces to limit the amount of broadcast, multicast, or unknown unicast traffic an interface receives. It also allows us to select a couple of actions to take when that threshold is met.&lt;/p&gt;

&lt;p&gt;Let’s jump right into a configuration example.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface GigabitEthernet0/1
SW1(config-if)# storm-control broadcast level 30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The ’30’ in the example above designates the rising threshold. When broadcast traffic exceeds 30% of the interface bandwidth, storm control will kick in and take action. The default action is to drop exceeding traffic.&lt;/p&gt;

&lt;p&gt;You can also specify bps as below. Adding k, m, or g identifies the value as Kbps, Mbps, or Gbps respectively. The example below would limit broadcast traffic to 30 Mbps on the Gigabit interface.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface GigabitEthernet0/1
SW1(config-if)# storm-control broadcast level bps 30m
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can also designate a falling threshold. The falling threshold sets a value to which the traffic has to fall before that type of traffic is allowed again.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface GigabitEthernet0/1
SW1(config-if)# storm-control broadcast level bps 30m 20m
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;In the example above the broadcast traffic would have to drop below 20 Mbps before any broadcast traffic would be allowed into the port.&lt;/p&gt;

&lt;p&gt;We can also control the action. &lt;code class=&quot;highlighter-rouge&quot;&gt;storm-control action shutdown&lt;/code&gt; shuts the interface down in case the level is exceeded. &lt;code class=&quot;highlighter-rouge&quot;&gt;storm-control action trap&lt;/code&gt; sends an SNMP trap if the level is exceeded.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;show storm-control [unicast | multicast | broadcast]&lt;/code&gt; is used to see the configuration as well as the current amount of traffic passing through the port.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Static MAC Address Entries</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/30/Static-MAC-Address/"/>
   <updated>2017-03-30T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/30/Static-MAC-Address</id>
   <content type="html">&lt;p&gt;Sometimes you may need to add static MAC address entries to the CAM table. This is easily achieved with the following global configuration command:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(cone)# mac address-table static 0022.5627.1fc1 vlan 10 interface GigabitEthernet0/1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;You can also force traffic to a particular MAC address to be dropped, by either specifying an unused interface or with the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(conf)# mac address-table static 0022.5627.1fc1 vlan 10 drop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Smartport Macros</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/30/Smartport-Macros/"/>
   <updated>2017-03-30T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/30/Smartport-Macros</id>
   <content type="html">&lt;p&gt;Smartport Macros are used to define a well-known template of configuration onto multiple interfaces. Several Smartport Macros come predefined in the switch. To see them, use &lt;code class=&quot;highlighter-rouge&quot;&gt;show parser macro&lt;/code&gt;. To expand one of the macros use &lt;code class=&quot;highlighter-rouge&quot;&gt;show parser macro name ___________&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is the old style of configuring switchport macros:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(conf)# macro name VLAN146
Enter macro commands one per line. End with the character '@'.
switchport mode access
switchport access vlan 146
spanning-tree bpdufilter enable
@
SW1(conf)\#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The # symbol can be used at the beginning of a line to designate comments. Then to apply the macro to an interface or interface range:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(conf)# interface range gig0/1-2
SW1(conf-if-range)# macro apply VLAN146
SW1(conf-if-range)# exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The modern style to define a switchport macro is here:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(conf)# define interface-range VLAN146 gig0/1-2
SW1(conf)# interface range macro VLAN146
SW1(conf-if-range)# switchport mode access
SW1(conf-if-range)# switchport access vlan 146
SW1(conf-if-range)# spanning-tree bpdufilter enable
SW1(conf-if-range)# exit
SW1(conf)# 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Private VLANs</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/30/Private-VLANs/"/>
   <updated>2017-03-30T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/30/Private-VLANs</id>
   <content type="html">&lt;p&gt;Protect Ports (discussed earlier) are a nice security feature of Cisco switches. When two ports are protected, they are not allowed to have direct communication with each other. But one limitation of protected ports is that they are only locally significant, so there is no way for protected ports to exist on different switches and follow the protection rules.&lt;/p&gt;

&lt;p&gt;The Private VLAN feature was created to solve this limitation. Private VLANs are more complex and can span multiple physical switches. Private VLANs split what would normally be a single broadcast domain defined by a single VLAN into multiple isolated broadcast subdomains, that are defined by a primary VLAN and its secondary VLANs. In essence it allows us to create VLANs inside VLANs, and is not un-similar to the concept of Confederations in BGP.&lt;/p&gt;

&lt;p&gt;Private VLANs are used to increase security. We most often see them in a shared color facility. This allows the color provider to have the customers exist on the same VLAN (and thus the same subnet), without allowing the different customers to communicate directly with each other.&lt;/p&gt;

&lt;p&gt;One pitfall you have to remember with Private VLANs is that it requires VTP to either be in Transparent mode or to be off.&lt;/p&gt;

&lt;p&gt;There is some terminology to remember when dealing with Private VLANs:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Promiscuous ports&lt;/em&gt; are allowed to talk to all other ports within the primary VLAN&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Isolated ports&lt;/em&gt; are only allowed to talk with promiscuous ports&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Community ports&lt;/em&gt; are allowed to talk with other ports in their own community as well as any promiscuous ports,  but they are not allowed to talk to ports in other communities&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The configuration steps are a little unnatural as well. The port roles are defined by the interface’s association to a primary VLAN and one or more secondary VLANs. First the secondary VLANs are created and defined as either community or isolated. Then the primary VLAN is defined, and the secondary VLANs are associated with the primary VLAN.&lt;/p&gt;

&lt;p&gt;Here is an example configuration with VLAN 500 as the primary VLAN, 501 a secondary community VLAN, and VLAN 502 a secondary isolated VLAN. Ports FastEthernet0/1 and FastEthernet0/2 are associated to VLAN 501, while FastEthernet03 and FastEthernet0/4 are associated with the secondary isolated VLAN 502.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# vtp mode transparent
SW1(config)# vlan 501
SW1(config-vlan)# private-vlan community
SW1(config-vlan)# vlan 500
SW1(config-vlan)# private-vlan primary
SW1(config-vlan)# private-vlan association add 501
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, let’s go ahead and associate FastEthernet0/1 and FastEthernet0/2 to the 501 Secondary Community we just created:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface range fa0/1-2
SW1(config-if-range)# switchport mode private-vlan host
SW1(config-if-range)# switchport private-vlan host-association 500 501
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now, we can go ahead and configure FastEthernet0/24 as a promiscuous port.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface fa0/24
SW1(config-if)# switchport mode private-vlan promiscuous
SW1(config-if)# switchport private-vlan mapping 500 501
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now we turn our attention to the creation of the isolated VLAN, VLAN 502.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# vlan 502
SW1(config-vlan)# private-vlan isolated
SW1(config-vlan)# vlan 500
SW1(config-vlan)# private-vlan primary
SW1(config-vlan)# private-vlan association add 502
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now we must associate our interfaces:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface range fa0/3-4
SW1(config-if-range)# switchport mode private-vlan host
SW1(config-if-range)# switchport private-vlan host-association 500 502
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And finally, we must add another association for our promiscuous port:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface fa0/24
SW1(config-if)# switchport mode private-vlan promiscuous
SW1(config-if)# switchport private-vlan mapping 500 502
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;One great way to test your Private VLAN setup is to send a single ping to the broadcast address with &lt;code class=&quot;highlighter-rouge&quot;&gt;ping 255.255.255.255 repeat 1&lt;/code&gt;.  The replies will only be from the hosts in your broadcast domain.&lt;/p&gt;

&lt;p&gt;One other thing to note. If you are configuring a Primary VLAN SVI to operate with secondary private VLANs, you need to map the secondary VLANs onto the SVI as in the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`SW1(config)# interface Vlan 100
SW1(config-if)# private-vlan mapping 1000,2000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Protected Port (PVLAN)</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/29/Protected-Port/"/>
   <updated>2017-03-29T11:40:45-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/29/Protected-Port</id>
   <content type="html">&lt;p&gt;The protected port, also known as PVLAN edge, is a security feature used to prevent traffic from being directly exchanged at Layer 2 between two or more hosts that are within the same VLAN. Protected ports only have local switch significance. A protected port does not forward any traffic (unicast, multicast, or broadcast) to any other protected port in the same switch. If you need to pass traffic between protected ports, the only possible way is through a L3 device.&lt;/p&gt;

&lt;p&gt;By default, all switch ports are unprotected. The configuration is as simple as below:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface gig0/1
SW1(config-if)# switchport protected
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree Loop Guard</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/29/STP-Loop-Guard/"/>
   <updated>2017-03-29T10:40:45-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/29/STP-Loop-Guard</id>
   <content type="html">&lt;p&gt;Loop Guard is a Spanning Tree feature that was added to prevent loops from forming due to hardware issues or STP software problems. A Spanning Tree loop occurs when a port that was previously in the blocking state is erroneously  transitioned to the Forwarding state.&lt;/p&gt;

&lt;p&gt;When a non-designated port stops receiving BPDUs, it will eventually transition itself to a designated port and begin forwarding BPDUs. Loop Guard works by preventing that non-designated port from transitioning to a forwarding state. Instead, it transitions the port to STP loop-inconsistent blocking state. So Loop Guard prevents a non-designated port from becoming a designated port, while Root Guard prevents a designated port from transitioning to a Root Port.&lt;/p&gt;

&lt;p&gt;Loop Guard is very similar to UDLD, but Loop Guard uses STP BPDUs to determine if there is a loop.&lt;/p&gt;

&lt;p&gt;Loop Guard is enabled on a per-port basis with the interface subcommand &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree guard loop&lt;/code&gt;. To be completely effective, Loop Guard should be enabled on &lt;em&gt;all&lt;/em&gt; non-designated ports, including root ports and alternate ports. Loop Guard can also be enabled globally with the &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree loopguard default&lt;/code&gt; global configuration command. You can then disable Loop Guard on a per-port basis with &lt;code class=&quot;highlighter-rouge&quot;&gt;no spanning-tree guard loop&lt;/code&gt;.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Spanning Tree Root Guard</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-Root-Guard/"/>
   <updated>2017-03-28T12:40:45-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-Root-Guard</id>
   <content type="html">&lt;p&gt;Root Guard is an enhancement to STP developed by Cisco. One issue with standard STP is that there is no way to ensure root bridge placement within the network. Even if you set a switch’s bridge priority to 0, another switch can come behind it with a priority of 0 and a lower MAC address and immediately take over the Root Bridge role.&lt;/p&gt;

&lt;p&gt;Root Guard is enabled on a per port basis. Root Guard ensures that the port on which it is configured remains a designated port. If the bridge receives superior BPDUs on that designated port, Root Guard moves the port to root-inconsistent state, which is effectively equivalent to the STP listening state so no frames are forwarded.&lt;/p&gt;

&lt;p&gt;The difference between BPDU Guard and Root Guard is that Root Guard allows the port to participate in STP, so long as the port does not receive a &lt;em&gt;superior&lt;/em&gt; BPDU. With BPDU Guard, &lt;em&gt;any&lt;/em&gt; BPDU will put the port into an err-disabled state.&lt;/p&gt;

&lt;p&gt;Again, Root Guard is enabled on a per interface basis as below.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface gig0/1
SW!(config-if)# spanning-tree rootguard
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The Cisco explanation is located &lt;a href=&quot;http://www.cisco.com/c/en/us/support/docs/lan-switching/spanning-tree-protocol/10588-74.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Spanning Tree BPDU Guard</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-BPDU-Guard/"/>
   <updated>2017-03-28T11:40:45-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-BPDU-Guard</id>
   <content type="html">&lt;p&gt;BPDU Guard is a STP PortFast safety enhancement. It works by disabling a port any time the interface hears a BPDU. PortFast by itself will not do that, so if you have PortFast enabled on an interface, and an end user plugs a switch into that link, all kinds of events can happen (including the plugged in switch becoming the Root Bridge!). BPDU Guard ensures that unauthorized switches cannot be plugged into the network. A sample configuration is below.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface gig0/1
  spanning-tree bpduguard enable

errdisable recovery cause bpduguard
errdisable recovery interval 120
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The errdisable section enables the port after 120 seconds, in case the port is placed into err disabled state to due BPDU Guard.&lt;/p&gt;

&lt;p&gt;Optionally, you can set BPDU Guard as the default configuration on all interfaces with the following global commands:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;spanning-tree portfast bpduguard default
spanning-tree portfast default
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree BPDU Filter</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-BPDU-Filter/"/>
   <updated>2017-03-28T10:40:45-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/28/STP-BPDU-Filter</id>
   <content type="html">&lt;p&gt;BPDU Filter is another optional feature of STP. It is similar to BPDU Guard, in that it is used to terminate the STP domain. Like BPDU Guard, it can be enabled globally or per interface, but unlike BPDU Guard, BGPU filter behaves differently depending on how it is enabled.&lt;/p&gt;

&lt;p&gt;If BPDU Filter is enabled at the interface level, it silently drops all received inbound BPDUs and does not send outbound BPDUs. Unlike BPDU Guard, there is no err-disabled option for BPDU Filter. Here is an example of BPDU Filter enabled at the interface level:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config-if)# switchport mode access
SW1(config-if)# switchport access vlan 10
SW1(config-if)# spanning-tree bpdufilter enable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When BPDU Filter is enabled globally, it will only affect PortFast enabled ports. The switch will send out exactly 11 BPDUs, and inbound BPDUs are not filtered. The reason 11 BPDUs are sent is the default Hello timer is 2 seconds and the default Max Age timer is 20 seconds. If the switch receives inbound BPDUs, the port loses its PortFast status and STP is negotiated normally on that port. For this reason, you can say that BPDU Filter enabled globally is a safer option than BPDU enabled at the interface level, as STP loops cannot form.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree BackboneFast</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-BackboneFast/"/>
   <updated>2017-03-27T13:40:45-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-BackboneFast</id>
   <content type="html">&lt;p&gt;BackboneFast enables fast reconvergence due to indirect link failures. The key operation happens when a switch begins receiving inferior BPDUs.  When a switch loses the link off its Root Port, it immediately starts sending BPDUs announcing itself as the new Root. Usually, when a switch receives inferior BPDUs, it will wait for its Max Age timer to expire before beginning STP convergence. Once its Max Age timer expires, the inferior BPDU ages out and the switch will then forward its superior BPDU to the neighbor switch who was sending the inferior BPDU.&lt;/p&gt;

&lt;p&gt;When BackboneFast is enabled, as soon as a switch receives an inferior BPDU, it will send RLQ (Root Link Query) messages out all it’s non-designated ports. The RLQ asks other switches if the current Root Bridge is accessible via that switch. Note it doesn’t wait for its Max Age timer to expire - it begins sending RLQ messages immediately. The RLQ is a new type of PDU defined within the BackboneFast specification. The RLQ is essentially a proactive way to age out ports compared to just waiting on the Max Age timer to expire.&lt;/p&gt;

&lt;p&gt;Based on the received RLQ responses, the switch will update its root ports and designated ports accordingly.. However all ports still transition through the regular IEEE 802.1D STP port states - listening, learning, and forwarding/blocking.&lt;/p&gt;

&lt;p&gt;To enable BackboneFast use the command &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree backbonefast&lt;/code&gt; on all switches in the Layer 2 domain. The easiest way to verify that BackboneFast is enabled is to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;show spanning-tree summary&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;This is a great Cisco article describing the operation: &lt;a href=&quot;http://www.cisco.com/c/en/us/support/docs/lan-switching/spanning-tree-protocol/12014-18.html&quot;&gt;BackboneFast&lt;/a&gt;.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>STP UplinkFast</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-UplinkFast/"/>
   <updated>2017-03-27T12:40:45-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-UplinkFast</id>
   <content type="html">&lt;p&gt;UplinkFast provides fast convergence in case the link on which the root port is connected suffers a failure. It does this with the use of an uplink group. An uplink group is a set of Layer 2 interfaces, of which only one is forwarding at a particular time. If the root port (forwarding port) goes down, then a successor root port is chosen which immediately goes into Forwarding state, bypassing the Listening and Learning phases.&lt;/p&gt;

&lt;p&gt;UplinkFast functionality is built into RSTP, so UplinkFast is only applicable with legacy IEEE 802.1D.&lt;/p&gt;

&lt;p&gt;When UplinkFast is enabled on a switch, that switch’s bridge priority will automatically be increased to 49152 and its port cost will be increased to 3000. This is to ensure that the switch does not become a transit switch.&lt;/p&gt;

&lt;p&gt;To enable UplinkFast, go to the switch on which you want it to run and run &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree uplinkfast&lt;/code&gt; in global configuration mode.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>STP PortFast</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-Portfast/"/>
   <updated>2017-03-27T11:40:45-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/27/STP-Portfast</id>
   <content type="html">&lt;p&gt;PortFast is used in Spanning Tree to avoid the lengthy delay of the Listening and Learning phases during STP convergence. When PortFast is enabled on an interface, the interface skips the Listening and Learning phases and goes straight into the Forwarding state. PortFast should be used on access switches on ports where you know end devices will be plugged in.&lt;/p&gt;

&lt;p&gt;To enable PortFast on an interface, in interface sub configuration mode use &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree portfast&lt;/code&gt;. If it is a trunk you must append the &lt;code class=&quot;highlighter-rouge&quot;&gt;trunk&lt;/code&gt; keyword after the command, and if it is an access port you should use the &lt;code class=&quot;highlighter-rouge&quot;&gt;edge&lt;/code&gt; keyword.&lt;/p&gt;

&lt;p&gt;Another way to enable PortFast for access ports is to use &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree portfast default&lt;/code&gt; in global configuration mode. Once enabled, all access ports will automatically have PortFast enabled.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Debugging Spanning Tree Events</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/27/Debugging-STP/"/>
   <updated>2017-03-27T10:40:45-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/27/Debugging-STP</id>
   <content type="html">&lt;p&gt;Here is a configuration for debugging Spanning Tree events:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# debug spanning-tree events
SW1# debug condition vlan 2
SW1# config t
SW1(config)# service timestamps debug datetime msec
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>STP Convergence Timers</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/26/STP-Timers/"/>
   <updated>2017-03-26T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/26/STP-Timers</id>
   <content type="html">&lt;p&gt;There are 3 timers we need to be concerned with in Spanning Tree: the Hello Time, the Forward Delay, and the Max-Age Time.&lt;/p&gt;

&lt;p&gt;The Hello Time is the frequency with which BPDUs are transmitted from the root bridge. It can be adjusted with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;spanning-tree vlan 1-4094 hello-time 3&lt;/code&gt; where 3 is in seconds. The default is 2 seconds, but in can be adjusted between 1 and 10 seconds. Non-root bridges will never generate BPDUs, but only relay BPDUs they receive on their root port.&lt;/p&gt;

&lt;p&gt;The Forward Delay is the time that is spent in the listening and learning states. Its value is 15 seconds by default, but it can be adjusted to anywhere between 4 and 30 seconds.&lt;/p&gt;

&lt;p&gt;The Max Age timer controls the maximum length of time that passes before a bridge port saves its configuration BPDU. This time is 20 seconds by default, but it can be tuned to be anytime between 6 and 40 seconds.&lt;/p&gt;

&lt;p&gt;There is another item that is not a timer but is related. This is the &lt;em&gt;message age&lt;/em&gt;. The root bridge sends all of its BPDUs with a message age of 0. Each downstream switch then adds 1 to this message age value. The actual age out time of the downstream switches is then (max age - message age).&lt;/p&gt;

&lt;p&gt;Here is a good article that describes the Max Age timer as it relates to superior BPDUs:  &lt;a href=&quot;https://packetmagnifier.wordpress.com/2013/09/09/understanding-stp-max-age/&quot;&gt;Max Age&lt;/a&gt;. If a switch’s root port goes down, there is no need for it to go through the Max Age timer process - if there are no better BPDUs received, the switch will immediately start announcing itself as root and begin sending BPDUs. In the scenario in the article, the switch that went down is sending inferior BPDUs, but yet the receiving switch goes through the Max Age process before it transforms its non-designated port to a Designated Port and begins sending the superior BPDUs towards the switch that suffered the down link.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>STP Path Selection with Port Cost</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/21/STP-Port-Cost/"/>
   <updated>2017-03-21T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/21/STP-Port-Cost</id>
   <content type="html">&lt;p&gt;There are two ways we can alter STP Path selection. We can alter the cost of a port, or we can change the priority of a port.&lt;/p&gt;

&lt;p&gt;When a switch receives a BPDU, that BPDU contains the root path cost from the previous switch. The receiving switch then adds the cost of the link between it and the sending switch from which it received the BPDU. That is very important - it is the receiving switch that adds the cost associated with its interface to the Root Path Cost it received from the sending switch.&lt;/p&gt;

&lt;p&gt;Cost is used for the selection of the root port to the upstream switch. But cost is carried along the path and accumulated in the root cost, which is the cost that is used to elect root ports. So changing the cost on a port may have implications on ports further downstream than the one you are affecting.&lt;/p&gt;

&lt;p&gt;Priority is used for influencing the root port of the downstream switch, and as such, it is set up on a port in Designated state. Cost has a higher precedence than priority. You will see priority on the local switch &lt;code class=&quot;highlighter-rouge&quot;&gt;show spanning-tree vlan 2&lt;/code&gt; but it will actually affect the forwarding decision on the downstream connected switch.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>STP Port Election</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/20/STP-Port-Election/"/>
   <updated>2017-03-20T11:40:45-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/20/STP-Port-Election</id>
   <content type="html">&lt;p&gt;After the election of the STP Root Bridge, all ports in the Layer 2 Switch topology will need to be assigned a state. The steps can be listed as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;All ports on the Root Bridge become Designated Ports&lt;/li&gt;
  &lt;li&gt;On each non-root switch, exactly ONE port is elected as the &lt;em&gt;Root Port&lt;/em&gt; which is the port having the lowest path-cost to the Root Bridge.&lt;/li&gt;
  &lt;li&gt;Each segment between switches will have one Designated Port which is the port on the segment that has the lowest path-cost to reach the root bridge.&lt;/li&gt;
  &lt;li&gt;The Root and Designated Ports are placed into a Forwarding State.&lt;/li&gt;
  &lt;li&gt;The ports that are not Root ports or Designated Ports will be placed in the Blocking State. These are displayed in show commands with an A for Alternate.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is helpful to remember that Designated Ports lead away from the Root Bridge, while Root Ports lead toward the Root Bridge.&lt;/p&gt;

&lt;p&gt;What are the tiebreakers for Root Ports and Designated Ports?&lt;/p&gt;

&lt;p&gt;The tiebreaker for Spanning Tree decisions is as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Lowest root bridge ID (used for root bridge election)&lt;/li&gt;
  &lt;li&gt;Lowest path cost to root bridge&lt;/li&gt;
  &lt;li&gt;Lowest sender bridge ID (used when a switch is connected to two switches through which it has equal cost to reach the root bridge)&lt;/li&gt;
  &lt;li&gt;Lowest sender port ID (when the switch has two interfaces connecting to the same switch and the cost to reach the root bridge is the same through either interface, it will use the interface with the lowest number as the root port (or designated port).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is helpful to keep in mind for elections that there is only one bridge that originates BPDUs - the root bridge. Other bridges update some fields (such as Sending Bridge ID, Message Age, etc) when retransmitting out their designated ports.&lt;/p&gt;

&lt;p&gt;The access ports will be designated ports typically and will send BPDUs toward the host, unless BPDU Filter is set.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>STP Root Bridge Election</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/20/STP-Root-Bridge-Election/"/>
   <updated>2017-03-20T10:40:45-04:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/20/STP-Root-Bridge-Election</id>
   <content type="html">&lt;p&gt;STP Root Bridge Election is based on the Bridge ID of the switches in the active Layer 2 domain. The Bridge ID is made up of the 4-bit bridge priority, a 12-bit Systems ID, and the 48-bit MAC address. The bridge priority is configurable from 0 to 61440. The default is 32768. The System ID is taken from the VLAN number (IEEE 802.1t).&lt;/p&gt;

&lt;p&gt;The election process is very simple. Each bridge starts off assuming it is the Root Bridge and sends BPDUs out advertising itself as such. If it receives a superior BPDU (a BPDU that has a Bridge ID lower than its current root bridge Bridge ID), it ceases advertising that Root Bridge and begins advertising the new Root Bridge with the lower Bridge ID. This process continues until all switches in the domain agree to the same Root Bridge.&lt;/p&gt;

&lt;p&gt;Note that since MAC addresses are guaranteed to be unique, there will always be 1 Root Bridge elected. If all switches are set to the default priority, then the switch with the lowest MAC Address will become the Root Bridge. this is a bad idea for many reasons. One, you typically want your distribution layer switch to be the Root Bridge. Second, older switches will have lower MAC addresses, so your switch with the least resources ends up having a heavier load along with a higher chance for failure&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree Types</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/17/Spanning-Tree-Types/"/>
   <updated>2017-03-17T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/17/Spanning-Tree-Types</id>
   <content type="html">&lt;p&gt;There are several different versions of the Spanning Tree Protocol that we will come across. We will review them in chronological order today.&lt;/p&gt;

&lt;p&gt;The original spanning tree is Common Spanning Tree, or CST. It was defined with IEEE 802.1D. The basic premise is to create a logical loop free topology for Ethernet networks by building a spanning tree of connected layer-2 bridges. The links that are not part of the spanning tree are disabled, leaving a single active path between any two network nodes.&lt;/p&gt;

&lt;p&gt;PVST and PVST+ are both Cisco proprietary protocols. Cisco developed them as they believed we may need different spanning-trees on a per-VLAN basis for  the best path flow. PVST only ran over ISL trunks, but with PVST+ compatibility with 802.1q trunks arrived. The + version also added new features such as UplinkFast, BackboneFast, and PortFast.&lt;/p&gt;

&lt;p&gt;RSTP is the IEEE’s answer to Cisco’s PVST+ implementation. RSTP took many of the added features of PVST+ and standardized them into IEEE 802.1w. RSTP added new bridge port roles and port states.&lt;/p&gt;

&lt;p&gt;Cisco then responded to the IEEE 802.1w Rapid Spanning Tree Protocol with RPVST+, which is just RSTP with per-vlan support. RPVST+ supports both ISL and 802.1Q trunks.&lt;/p&gt;

&lt;p&gt;When the concept of VLANs finally hit home when VoIP hit the LAN, everyone finally agreed that we needed VLAN support for STP. However, it was also determined that there are usually on three paths needed to support redundancy with Spanning Tree designs. But yet with Spanning Trees based on a per-VLAN approach, we may end up with way more than 3 instances of Spanning Tree running on the router.&lt;/p&gt;

&lt;p&gt;This led to the introduction of Multiple Spanning Tree Protocol. It was originally defined with 802.1s and was later merged into IEEE 802.1Q-2005. MSTP creates on common Spanning Tree for the entire Layer 2 network. If a network contains multiple VLANs, we can create multiple Spanning Trees and then assign specific VLANs to specific Spanning Tree instances. Since most networks will need a maximum of two Spanning Tree instances, MSTP greatly reduces the overhead on the router compared to RPVST which needed a separate instance per VLAN.&lt;/p&gt;

&lt;p&gt;Cisco MST supports both 802.1Q and ISL trunks.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Virtual Switch System</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/13/VSS/"/>
   <updated>2017-03-13T00:00:00-04:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/13/VSS</id>
   <content type="html">&lt;p&gt;VSS, or Virtual Switch System, exists in Cisco Catalyst 6500 and 4500 switches running IOS-XE. VSS simplifies the network by reducing the number of network elements. VSS can combine multiple Catalyst Switches into a single logical device. VSS logically combines a pair of switches into a single network element.&lt;/p&gt;

&lt;p&gt;The two switches in the pair negotiate their roles - one will assume the role of the active switch while the other assumes the role of the standby switch. The VSS active switch controls the VSS, running the Layer 2 and Layer 3 protocols for both switches. Both switches perform packet forwarding as needed, but the standby switch sends all control traffic to the VSS active switch for processing.&lt;/p&gt;

&lt;p&gt;The virtual switch link (VSL) is the link which ties the active and standby switches together. It is typically implemented as an EtherChannel, and therefore can support up to 8 links in the bundle. The attached devices (such as access switches) can then connect to the VSS using Multichassis EtherChannel. Unlike normal EtherChannel witch connects multiple links between two switches, MultiChassis EtherChannel can connect one switch over multiple links to two switches. In total, a VSS can support up to 256 EtherChannels in a combination of regular EtherChannels and MultiChassis EtherChannels (MEC).&lt;/p&gt;

&lt;h4 id=&quot;configuration&quot;&gt;Configuration&lt;/h4&gt;

&lt;p&gt;Both switches in a VSS pair need to belong to the same VSS domain. This domain is a number between 1 and 255. After creating the domain, you must configure one switch to be switch number 1 and the other switch to be switch number 2.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# switch virtual domain 10
SW1(config-vs-domain)# switch 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2(config)# switch virtual domain 10
SW2(config-vs-domain)# switch 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next you should create the VSL between the two VSS switches.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# interface port-channel 5
SW1(config-if)# switchport
SW1(config-if)# switch virtual link 1
SW1(config-if)# no shutdown
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2(config)# interface port-channel 10
SW2(config-if)# switchport
SW2(config-if)# switch virtual link 2
SW2(config-if)# no shutdown
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, you have to put the physical interfaces into the appropriate port-channels created for the VSL.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# int range gig1/0-3
SW1(config-if-range)# switchport mode trunk
SW1(config-if-range)# channel-group 5 mode on
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# int range gig1/0-3
SW1(config-if-range)# switchport mode trunk
SW1(config-if-range)# channel-group 10 mode on
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next, to complete the switch conversion process you need to run the following command on each switch:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# switch convert mode virtual
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2# switch convert mode virtual
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The switch will reload and when they come back up they will now be part of the VSS domain.&lt;/p&gt;

&lt;p&gt;Some sample show commands are:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# show switch virtual

SW1# show switch virtual role

SW1# show switch virtual link

SW1# show switch virtual link port-channel
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>SPAN Configuration</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/11/SPAN-Configuration/"/>
   <updated>2017-03-11T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/11/SPAN-Configuration</id>
   <content type="html">&lt;p&gt;Basic SPAN Configuration:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# monitor session 1 source interface fa0/12
SW1(config)# monitor session 1 destination interface fa0/24
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Here is an example where we will only monitor respective traffic from fa0/18 and only monitor sent traffic from interface fa0/19. Additionally we will filter (remove) VLANs 1 through 3. Finally, we will preserve the encapsulation from the sources:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# monitor session 1 source interface fa0/18 rx
SW1(config)# monitor session 1 source interface fa0/19 tx
SW1(config)# monitor session 1 filter vlan 1-3
SW1(config)# monitor session 1 destination interface fa0/24 encapsulation replicate
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next we have a RSPAN sample configuration. We will monitor all traffic on VLANs 66-68 on SW1 and send it to VLAN 199, which will then be delivered to port fa0/24 on SW2:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# vlan 199
SW1(config-vlan)# remote span
SW1(config-vlan)# exit
SW1(config)# monitor session 1 source vlan 66-68
SW1(config)# monitor session 1 destination remote van 199
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2(config)# vlan 199
SW2(config-vlan)# remote span
SW2(config-vlan)# exit
SW2(config)# monitor session 2 source remote vlan 199
SW2(config)# monitor session 2 destination interface fa0/24
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Notice above that the monitor session numbers do not have to match on each switch.&lt;/p&gt;

&lt;p&gt;Finally, we have a ERSPAN example. We will configure R1 to capture received traffic and send it to SW1 gig2/1.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1(config)# monitor session 1 type erspan-source
R1(config-mon-erspan-src)# source interface gig1/1 rx
R1(config-mon-erspan-src)# no shutdown
R1(config-mon-erspan-src)# destination
R1(config-mon-erspan-src-dst)# erspan-id 101
R1(config-mon-erspan-src-dst)# ip address 10.1.1.1
R1(config-mon-erspan-src-dst)# origin ip address 172.16.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# monitor session 2 type erspan-destination
SW1(config-mon-erspan-dst)# destination interface gig2/1
SW1(config-mon-erspan-dst)# no shutdown
SW1(config-mon-erspan-dst)# source
SW1(config-mon-erspan-dst-src)# erspan-id 101
SW1(config-mon-erspan-dst)# ip address 10.1.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A couple of configuration notes. First, you must make sure the destination port is not in a shutdown state or else the SPAN session will not come up.&lt;/p&gt;

&lt;p&gt;If you want to leave the original encapsulation of the frames intact, use the &lt;code class=&quot;highlighter-rouge&quot;&gt;encapsulation replicate&lt;/code&gt; option on the monitor session destination command.&lt;/p&gt;

&lt;p&gt;One confusing option is the &lt;code class=&quot;highlighter-rouge&quot;&gt;ingress dot1q vlan 10&lt;/code&gt; option on the destination interface. This is actually telling the switch to accept incoming frames on the &lt;em&gt;destination&lt;/em&gt; monitor switch and place the frames in VLAN 10. This would let you use the destination port like a normal access port. Seems kind of silly to me as to why you would want to do that, but I am sure there is a reason.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`monitor session 1 destination interface gig0/24 ingress dot1q vlan 146
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`The above accepts inbound packets with 802.1Q encapsulation with the given VLAN as the default VLAN. Compare that to the example below, which accepts incoming packets with untagged encapsulation type with the specified VLAN as the default VLAN.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`monitor session 1 destination interface gig0/24 ingress vlan 146
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
To view the session, simply use &lt;/code&gt;show monitor session 1`.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>SPAN</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/09/SPAN/"/>
   <updated>2017-03-09T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/09/SPAN</id>
   <content type="html">&lt;p&gt;SPAN stands for Switch Port Analyzer. It is a way to direct all traffic from a source port or source VLAN to a single port. Some uses include IDS/IPS, VoIP Call recording, or troubleshooting / analysis.&lt;/p&gt;

&lt;p&gt;If the destination port is on the local switch, we say it is in SPAN operation mode. The destination port could also be mapped to a port on a remote switch, in which case we call it Remote SPAN or RSPAN. In RSPAN, a specific VLAN must be configured across the entire switching path from the source port or VLAN to the RSPAN destination port. So the source is still at least one port or at least one VLAN,  but the destination is always the RSPAN VLAN. At the switch where the RSPAN destination port exists, the RSPAN VLAN is delivered to the RSPAN port.&lt;/p&gt;

&lt;p&gt;Encapsulated Remote SPAN (ERSPAN) is a variant of RSPAN in which we are encapsulating the Remote SPAN information. ERSPAN creates a GRE tunnel for all captured traffic and allows it to be extended across Layer 3 domains. This became an option with IOS-XE.&lt;/p&gt;

&lt;p&gt;Regardless of the type of SPAN we are running, the source port can be any type of port including EtherChannel, trunk port, routed port, etc. When using a VLAN as the source, all active ports in that VLAN are monitored, and the monitored ports are updated dynamically as membership to that VLAN changes. A port configured as a SPAN destination cannot be part of a SPAN source VLAN.&lt;/p&gt;

&lt;p&gt;It is important to understand that when you configure a SPAN destination port, the existing configuration is removed but is restored if you later remove the SPAN configuration. The destination port does not support any security, nor does it support any Layer 2 protocols such as CDP, VTP, etc. If the destination port was part of an EtherChannel, it will be removed from the EtherChannel once the SPAN configuration is applied.&lt;/p&gt;

&lt;p&gt;There are a number of restrictions with SPAN including:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the source can be one or more ports or a VLAN, but not both&lt;/li&gt;
  &lt;li&gt;up to 64 destination ports can be configured on a switch&lt;/li&gt;
  &lt;li&gt;you must be careful not to overload the destination port, especially if a VLAN is being monitored.&lt;/li&gt;
  &lt;li&gt;within a single SPAN session, you cannot deliver traffic to a destination port when it is sourced by a mix of SPAN, RSPAN, or ERSPAN source ports or VLANs. This usually comes into play when you want to mirror source traffic to both a local port on a switch (SPAN mode) and a remote port on another switch (RSPAN mode).&lt;/li&gt;
  &lt;li&gt;only one SPAN/RSPAN/ERSPAN session can send traffic to a single destination port&lt;/li&gt;
  &lt;li&gt;if you use a trunk port as a SPAN or RSPAN source, then by default all VLANs on the trunk are monitored by default&lt;/li&gt;
  &lt;li&gt;traffic that is routed from another VLAN to a source VLAN cannot be monitored with SPAN&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, SPAN, RSPAN, and ERSPAN support three types of traffic: transmitted, received, and both (default). If you set a SPAN to monitor just receive or just transmit, some conditions apply:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;for Receive (RX) the goal is to deliver all traffic that is received by the SPAN source. As a result, each frame that is received by the source port or VLAN is copied to the destination port or VLAN &lt;em&gt;before&lt;/em&gt; any modifications are made to the frame (such as ACL filtering, QoS, etc)&lt;/li&gt;
  &lt;li&gt;for Transmit (TX), all relevant filtering or modification to the frame is done before the switch forwards the traffic to the SPAN or RSPAN destination.&lt;/li&gt;
  &lt;li&gt;SPAN usually ignores certain Layer 2 frames like CDP, BPDUs, etc. However, SPAN can be configured to forward that traffic to the destination port/VLAN with the &lt;code class=&quot;highlighter-rouge&quot;&gt;encapsulation replicate&lt;/code&gt; command&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Common Spanning Tree</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/08/CST/"/>
   <updated>2017-03-08T10:40:45-05:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/08/CST</id>
   <content type="html">&lt;p&gt;Common Spanning-Tree (CST) assumes one spanning-tree instance for the entire bridged network, regardless of the number of VLANs. Running only one instance reduces CPU load. All CST BPDUs are sent over trunks using the native VLAN with untagged frames.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Spanning Tree Intro</title>
   <link href="http://bsrandall.github.io/spanning%20tree/2017/03/08/Spanning-Tree-Intro/"/>
   <updated>2017-03-08T09:40:45-05:00</updated>
   <id>http://bsrandall.github.io/spanning%20tree/2017/03/08/Spanning-Tree-Intro</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;https://networklessons.com/wp-content/uploads/2013/01/switches-redundant-cable-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Imagine in the above diagram that H1 sends out an ARP request, which is a broadcast frame. SW1 will forward this broadcast frame on ports Fa0/0 and Fa1/0 toward SW2.&lt;/p&gt;

&lt;p&gt;SW2 will forward the broadcast frame it received on Fa0/0 out Fa1/0 and the interface connected to H2. This cycle will continue and continue. By introducing redundancy, we have created an environment that is friendly to Layer 2 loops. And since Ethernet frames do not have a TTL, they will loop around forever.&lt;/p&gt;

&lt;p&gt;Spanning Tree is a Layer 2 protocol that was created to deal with the possible loop creation that is introduced with redundant Layer 2 loops. Spanning Tree takes over the Layer 2 forwarding decisions, and places certain ports in a blocking state to prevent the possibility of these loops occurring.&lt;/p&gt;

&lt;p&gt;When Spanning Tree is enabled, switches send out a special frame called a BPDU (Bridge Protocol Data Unit). Included in this BPDU is the Switch’s Priority and MAC Address, which concatenated equals the Bridge Id. Among connected Switch’s, the Switch with the lowest Bridge Id becomes the Root Bridge.&lt;/p&gt;

&lt;p&gt;A Root Bridge marks all of its ports as Designated, which are placed in a forwarding state. Designated ports lead away from the Root bridge.&lt;/p&gt;

&lt;p&gt;For the remaining switches, we have to elect one root port on each switch. The root port will be the port whose path has the lowest cost to the root bridge&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>UDLD</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/07/UDLD/"/>
   <updated>2017-03-07T12:40:45-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/07/UDLD</id>
   <content type="html">&lt;p&gt;UDLD, or Unidirectional Link Detection, is a Cisco proprietary, Layer 2 protocol that helps detects if either the transmit or the receive fails on a link. It’s purpose is similar to LoopGuard, but it is completely independent of Spanning Tree. The operation of UDLD is fairly simple. A switch sends UDLD Hellos and if it receives echoes of those Hellos back it knows the link is an active two way link. As soon as it quits receiving the UDLD Hellos, it knows there must be a unidirectional link failure. UDLD operates at the physical port level, compared to say STP LoopGuard which works at the logical port level (EtherChannel). Also UDLD functions at linkup, while LoopGuard does not. It is recommended to enable both UDLD and LoopGuard.&lt;/p&gt;

&lt;p&gt;UDLD is mainly used on fiber connections, but it can also be useful on Ethernet connections that have dumb devices in the middle such as media converters.&lt;/p&gt;

&lt;p&gt;The default advertisement timer is 15 seconds and the hold time is 5 seconds. Upon detecting the loss of a UDLD neighbor, UDLD will send seven additional advertisements (one per second). If no reply is received, the link’s bidirectional status transitions to unknown.&lt;/p&gt;

&lt;p&gt;To set up UDLD globally, use &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1(config)# udld enable&lt;/code&gt; and use the &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1(config-if)# udld port enable&lt;/code&gt; command to enable per interface. Use &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1(config)# udld enable aggressive&lt;/code&gt; if you want the ports to be shut down upon UDLD neighbor failure.&lt;/p&gt;

&lt;p&gt;In order to reset an interface that was shut down by UDLD, use &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# udld reset&lt;/code&gt;, or the typical shut / no shut commands.&lt;/p&gt;

&lt;p&gt;You could also enable auto recovery of the interface if desired. It would look like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1(config)# errdisable recovery cause idled
SW1(config)# errdisable recovery interval 30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>LLDP</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/06/LLDP/"/>
   <updated>2017-03-06T11:40:45-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/06/LLDP</id>
   <content type="html">&lt;p&gt;LLDP is the IEEE equivalent of CDP. It’s development was due to Cisco’s deployment of CDP, so the IEEE sought to make a universal version. It is very similar to CDP and many of the Cisco commands for LLDP are the same commands as those for CDP, just substituting lldp for cdp. Like CDP, LLDP is a link layer protocol, but unlike CDP it is specifically for Ethernet networks. LLDP is described under IEEE 802.1AB LLDP.&lt;/p&gt;

&lt;p&gt;LLDP, like CDP, also uses TLVs to describe neighbor devices and capabilities.&lt;/p&gt;

&lt;p&gt;One additional feature LLDP includes is that LLDP has a TLV for an interface description, so if you set a description with &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1#(config-if) description LINK_SW1_SW2&lt;/code&gt;, that description would show up under Switch 2 LLDP like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2# show lldp neighbors detail

Chasis id: 0019.569d.571a
Port id: Fa0/24
Port Description: LINK_SW1_SW2
System Name: SW1.cisco.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;An enhancement was made to LLDP that allows you to use LLDP for VLAN assignment or POE requirements. This enhanced version is known as LLDP-MED (Media Endpoint Discovery).&lt;/p&gt;

&lt;p&gt;One difference between CDP and LLDP is that with LLDP the Hello timer is set to 30 seconds by default and the hold time is set to 4 times the Hello time. CDP is 60 seconds and the hold timer is 3 times the Hello time, as a reminder. Another difference is that LLDP has a reinitialization delay (default 2 seconds).  This is the time that an LLDP port waits before reinitializing LLDP transmission. The command to set the reinitialization period is &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1#(config) lldp reinit&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can also set LLDP up to only transmit and not receive LLDP packets. This is done by using the &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1#(config) no lldp receive&lt;/code&gt; command. You can also do this on a per-interface basis. Likewise, you can also disallow sending LLDP packets with the &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1#(config) no lldp transmit&lt;/code&gt; command, which can also be done at the interface level.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CDP Configuration</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/06/CDP-Configuration/"/>
   <updated>2017-03-06T10:40:45-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/06/CDP-Configuration</id>
   <content type="html">&lt;p&gt;To enable CDP globally we use &lt;code class=&quot;highlighter-rouge&quot;&gt;cdp run&lt;/code&gt;. To enable CDP on a per-interface basis, use &lt;code class=&quot;highlighter-rouge&quot;&gt;cdp enable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) cdp timer seconds&lt;/code&gt;  specifies the frequency of CDP update transmissions.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) cdp holdtime seconds&lt;/code&gt; specifies the amount of time a receiving device should hold the information sent by your device before discarding it.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) no cdp adertise-v2&lt;/code&gt; disables the advertisement of CDPv2 advertisements if for some crazy reason you need to.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) clear cdp counters&lt;/code&gt; resets the traffic counters to zero.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) clear cdp table&lt;/code&gt; deletes the CDP table of information about neighbors&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) show cdp&lt;/code&gt; displays the interval between CDP transmissions, the number of seconds a CDP advertisement is valid for a given port, and the version of the advertisement&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) show cdp interface [type number]&lt;/code&gt; displays information about interfaces on which CDP is enabled&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;R1#(config) show cdp entry device-name&lt;/code&gt; displays information about a specific neighbor&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CDP Basics</title>
   <link href="http://bsrandall.github.io/layer%202/2017/03/06/CDP-Basics/"/>
   <updated>2017-03-06T09:40:45-05:00</updated>
   <id>http://bsrandall.github.io/layer%202/2017/03/06/CDP-Basics</id>
   <content type="html">&lt;p&gt;CDP is a layer 2, Cisco proprietary device discovery protocol. Even though it is a Layer 2 protocol, it provides information about Layer 3 protocols (such as IP address). CDP operates by its member devices sending multicasts to the link-local multicast address 01:00:0c:cc:cc:cc (same as VTP). The member devices listen for multicasts at that address, process them accordingly, and store the information in a local table. The announcements are sent out every 60 seconds by default.&lt;/p&gt;

&lt;p&gt;SNAP (Subnetwork Access Protocol) is required to run CDP, so effectively CDP can run on any data-link protocol that supports SNAP. Ethernet, Frame Relay, and ATM are example medias that support SNAP and thus CDP.&lt;/p&gt;

&lt;p&gt;CDP relays the information about devices by Type-Length-Value (TLV) fields in the CDP packets. The &lt;em&gt;Length&lt;/em&gt; is the length (in bytes) of the Type-Value-Length fields. The Type and Value fields are described below.&lt;/p&gt;

&lt;h4 id=&quot;type&quot;&gt;Type&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Device ID - 0x0001&lt;/li&gt;
  &lt;li&gt;Address - 0x0002&lt;/li&gt;
  &lt;li&gt;Port ID - 0x0003&lt;/li&gt;
  &lt;li&gt;Capabilities - 0x0004&lt;/li&gt;
  &lt;li&gt;Version - 0x0005&lt;/li&gt;
  &lt;li&gt;Platform - 0x0006&lt;/li&gt;
  &lt;li&gt;IP Prefix - 0x0007&lt;/li&gt;
  &lt;li&gt;VTP Management Domain - 0x0009 {: .red}&lt;/li&gt;
  &lt;li&gt;Native VLAN - 0x000a {: .red}&lt;/li&gt;
  &lt;li&gt;Duplex Status - 0x000b {: .red}&lt;/li&gt;
  &lt;li&gt;Appliance ID - 0x000c {: .red}&lt;/li&gt;
  &lt;li&gt;Power consumption - 0x0010 {: .red}&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;value&quot;&gt;Value&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Device ID - MAC address in ASCII or the FQDN&lt;/li&gt;
  &lt;li&gt;Address&lt;/li&gt;
  &lt;li&gt;Port ID - ASCII string that names the port from which the message was sent&lt;/li&gt;
  &lt;li&gt;Capabilities - has a value describing the device capabilities:
    &lt;ul&gt;
      &lt;li&gt;0x01 - level 3 routing&lt;/li&gt;
      &lt;li&gt;0x02 - level 2 transparent bridging&lt;/li&gt;
      &lt;li&gt;0x04 - level 2 source-route bridging&lt;/li&gt;
      &lt;li&gt;0x08 - level 2 switching not running Spanning Tree&lt;/li&gt;
      &lt;li&gt;0x10 - sends and receives packets for a network layer protocol&lt;/li&gt;
      &lt;li&gt;0x20 - the device does not forward IGMP reports&lt;/li&gt;
      &lt;li&gt;0x40 - level 1 function&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Version - software version running the device&lt;/li&gt;
  &lt;li&gt;Platform - ASCII string describing the device (e.g. Cisco 7000)&lt;/li&gt;
  &lt;li&gt;IP Prefix - a set of 0 or more IP Prefixes&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Switches see the MAC multicast address used by CDP as a special address and will not forward it out of other interfaces on a switch. Routers do not forward layer 2 frames out of their interfaces ever, so therefore only directly connected neighbors receive the CDP advertisement.&lt;/p&gt;

&lt;p&gt;The beauty of CDP is that if you walk into a network and you do not know the topology, you can use CDP to quickly learn the entire layout of the network (as long as all the devices are Cisco!).&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MultiChassis EtherChannel</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/27/EtherChannel-MultiChassis/"/>
   <updated>2017-02-27T10:40:45-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/27/EtherChannel-MultiChassis</id>
   <content type="html">&lt;p&gt;A LAG bundle to the same access switch results in Fate Sharing for the links in the bundle. The alternative is to break the links out of the LAG, and have the NICs of a server connect to two different access switches. But by breaking the LAG, we now have half the available bandwidth for the server.&lt;/p&gt;

&lt;p&gt;With MultiChassis EtherChannel, we trick the server into running LAG between two different access switches. There are multiple ways to do this using different protocols made by different vendors. We generically call it MLAG.&lt;/p&gt;

&lt;p&gt;The protocol must take a physical triangle as seen below, and make it into a logical point-to-point. Many problems arise that the protocol must deal with. If NIC A sends traffic to Switch A, Switch A must know not to send that to Switch B, or else a loop might form.
&lt;img src=&quot;http://www.cisco.com/c/dam/en/us/td/i/200001-300000/220001-230000/226001-227000/226936.eps/_jcr_content/renditions/226936.jpg&quot; alt=&quot;&quot; /&gt;
The protocols are so customized, that different platforms from the same vendor cannot even run MLAG. The control place has to be identical. Cisco therefore has a couple of implementations.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Stackwise Cross-Stack EtherChannel&lt;/em&gt; has control plane over dedicated stacking cables. These stack cables create a bidirectional closed loop as seen below. One control plane is shared amongst members as well as one management plane. So if you were to log into one switch, you are actually viewing the configuration for the stack. This is used on the Access Platforms such as Catalyst 3750/3850. StackWise can have more than 2 members, up to the stack limit
&lt;img src=&quot;https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcRguQ7GRPRoSYAmPfJ4MCMN2r160qFDougT6yyluxFXu6n42Foxgg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Virtual Switching System (VSS)&lt;/em&gt; is used on the aggregation platforms such as Catalyst 4500/6500/6800. VSS is similar to Stackwise as there is one management plane and one control plane shared between connected switches. Typically with VSL, the links are going to be 2x10G LAG. VSS switches are udeployed in pairs and will usually have 1 active supervisor and 3 standby supervisors.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Virtual Port Channel (vPC)&lt;/em&gt; is very similar to VSS but it runs on the Data Center platforms such as Nexus 5000/7000/9000. The control plane is synchronized over a vPC Peer Link, which are typically 2x10GigE LAG. The biggest difference between vPC and VSS, is that vPC has &lt;em&gt;2&lt;/em&gt; independent control planes and &lt;em&gt;2&lt;/em&gt; independent management planes. vPC like VSS is deployed in pairs.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>EtherChannel Layer 3</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/27/EtherChannel-Layer-3/"/>
   <updated>2017-02-27T09:40:45-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/27/EtherChannel-Layer-3</id>
   <content type="html">&lt;p&gt;To configure Layer 3 EtherChannels, you have to ensure that the ports that are part of the EtherChannel are first set to &lt;code class=&quot;highlighter-rouge&quot;&gt;no switchport&lt;/code&gt; before adding them to the channel-group. An example LACP config follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; interface port-channel 1
  no switchport
  ip address 10.0.0.1 255.255.255.0

interface GigabitEthernet0/1
  no ip address
  no switchport
  channel-group 1 mode active
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>EtherChannel Load-Balancing</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/26/EtherChannel-Load-Balancing/"/>
   <updated>2017-02-26T10:40:45-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/26/EtherChannel-Load-Balancing</id>
   <content type="html">&lt;p&gt;The balancing method is locally significant and outbound. So it is OK for one side of a LAG to be src-MAC and the other side to be dest-IP.&lt;/p&gt;

&lt;p&gt;To configure the load-balancing method by using the&lt;code class=&quot;highlighter-rouge&quot;&gt;port-channel load-balance&lt;/code&gt; global configuration command. EtherChannel load-balancing can use MAC Address or IP address, source or destination address, or both source and destination address.&lt;/p&gt;

&lt;p&gt;The selected load balancing mode applies to all ether channels on a switch.&lt;/p&gt;

&lt;p&gt;With source-MAC address forwarding, packets are distributed across the ports based on the source-MAC of the &lt;em&gt;incoming&lt;/em&gt; packet. So packets from the same host use the same port in the channel.&lt;/p&gt;

&lt;p&gt;With destination-MAC address forwarding, packets are distributed across the ports of the channel based on the destination-MAC of the incoming packet. So packets destined to the same host use the same port in the channel.&lt;/p&gt;

&lt;p&gt;With source-and-destination MAC address forwarding, packets are distributed across the ports in a channel based on both the source and the destination MAC address. This is often used if it is not clear whether source-MAC or destination-MAC would be more appropriate.&lt;/p&gt;

&lt;p&gt;IP based forwarding has the same principles as the MAC based forwarding outlined above.&lt;/p&gt;

&lt;p&gt;To chose the appropriate load-balancing method, you must analyze the position of the EtherChannel in the network. For example, if you have 4 hosts going towards one router, you would be much better load-balancing based on source-MAC  than destination-MAC from the switch. On the router, you will be better off using destination-MAC.&lt;/p&gt;

&lt;p&gt;To configure EtherChannel load-balancing, in global config use the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`port-channel load-balance {dst-ip | dst-mac | src-dst-ip | src-dst-mac | src-ip | src-mac}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`
The default is src-mac.&lt;/p&gt;

&lt;p&gt;One negative of EtherChannel is that flows cannot exceed the bandwidth of an individual link. EtherChannel adds lanes to the highway but it doesn’t increase the speed limit.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>EtherChannel PaGP</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/26/EtherChannel-PAgP/"/>
   <updated>2017-02-26T09:40:45-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/26/EtherChannel-PAgP</id>
   <content type="html">&lt;p&gt;Port Aggregation Protocol (PAgP) is a Cisco proprietary protocol that is only supported on Cisco switches.&lt;/p&gt;

&lt;p&gt;The two modes of PAgP are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;auto: places a port into a passive negotiating state&lt;/li&gt;
  &lt;li&gt;desirable: places a port into active negotiating state&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For Layer 2 EtherChannels, the first port that comes up lends its MAC address to the EtherChannel.&lt;/p&gt;

&lt;p&gt;PAgP supports up to 8 Ethernet ports of the same type.&lt;/p&gt;

&lt;p&gt;For all EtherChannels (including on and PAgP), when a group is first created, all ports follow the parameters set for the first port to be added to the group. If you change the configuration of any of these parameters, you must also make changes to all ports in the group:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Allowed-VLAN list&lt;/li&gt;
  &lt;li&gt;Spanning-tree path cost for each VLAN&lt;/li&gt;
  &lt;li&gt;Spanning-tree port priority for each VLAN&lt;/li&gt;
  &lt;li&gt;Spanning-tree Port Fast setting&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For all Layer 2 EtherChannels, if the ports are access ports they must all be in the same VLAN.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>EtherChannel LACP</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/24/EtherChannel-LACP/"/>
   <updated>2017-02-24T00:00:00-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/24/EtherChannel-LACP</id>
   <content type="html">&lt;p&gt;LACP is the IEEE standard for establishing a single logical channel out of several physical ports. It is popular as it can be used in mixed-vendor switch environments. LACP ensures that when an EtherChannel is created, all physical members all have the same speed, duplex, link-type, and VLAN information. LACP is a control protocol for LAG. The official name is IEEE 802.3ad Link Aggregation (LAG).&lt;/p&gt;

&lt;p&gt;LACP supports up to 16 Ethernet ports of the same type. Up to eight ports can be active, and up to eight ports can be in standby mode.&lt;/p&gt;

&lt;p&gt;LACP assigns system priority, port priority, and and an administrative key.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;System priority&lt;/em&gt; and the MAC address form the System ID. Between two LACP neighbors, the switch with the lowest System ID will be the decision maker using the LACP Port Priority&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Port priority&lt;/em&gt; and the port number form the port identifier. The switch uses the port identifier to decide which ports to put in standby mode when a hardware limitation prevents all ports from aggregating. Port priority is also used when more than 8 physical ports are put into a channel group. Port priority will decide which 8 ports will be the active ports in the etherchannel.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Administrative key&lt;/em&gt; defines the capabilities of a port to aggregate with other ports, based on the port’s physical characteristics.&lt;/p&gt;

&lt;p&gt;Sample Configuration:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# interface range GigabitEthernet0/1-2
SW1# channel-group 1 mode active
SW1# exit
SW1# interface port-channel 1
SW1# switchport trunk encapsulation dot1q
SW1# switchport mode trunk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW2# interface range GigabitEthernet0/1-2
SW2# channel-group 1 mode active
SW2# exit
SW2# interface port-channel 1
SW2# switchport trunk encapsulation dot1q
SW2# switchport mode trunk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can also start with the &lt;code class=&quot;highlighter-rouge&quot;&gt;interface port-channel 1&lt;/code&gt; command and then define the channel group. For Layer 3 ether channel, you would want to define the port-channel first and then issue the &lt;code class=&quot;highlighter-rouge&quot;&gt;no switchport&lt;/code&gt; interface command.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;interface port-channel 1&lt;/code&gt; is the logical interface. The channel-group command binds the logical interface to a physical port. The port-channel interface (numbered 1 - 48) correspond to the one specified with the channel-group interface configuration command.&lt;/p&gt;

&lt;p&gt;A successful Layer 2 EtherChannel will show SU with the command &lt;code class=&quot;highlighter-rouge&quot;&gt;show etherchannel summary&lt;/code&gt;. An unsuccessful layer 2 will show SD.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>EtherChannel</title>
   <link href="http://bsrandall.github.io/etherchannel/2017/02/23/EtherChannel-General/"/>
   <updated>2017-02-23T09:40:45-05:00</updated>
   <id>http://bsrandall.github.io/etherchannel/2017/02/23/EtherChannel-General</id>
   <content type="html">&lt;p&gt;LAG goal is to trick our Spanning Tree Protocol into forwarding active/active across multiple links. The risk we take is an infinite loop in the data plane, as there is no TTL with Ethernet. The LAG negotiation protocols help to mitigate this risk. Static LAG is supported but not recommended, as a failure to LAG can cause an STP Loop. If you do deploy Static LAG, it is recommended to deploy EtherChannel Guard to help mitigate the chances of a loop.&lt;/p&gt;

&lt;p&gt;PAgP and LACP accomplish the exact same thing, just in different ways.&lt;/p&gt;

&lt;p&gt;Since both PAgP and LACP both require the member ports to have the same characteristics, a good command to start with is &lt;code class=&quot;highlighter-rouge&quot;&gt;show interfaces status&lt;/code&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MST IST-CIST</title>
   <link href="http://bsrandall.github.io/mst/2017/02/23/MST-IST-CIST/"/>
   <updated>2017-02-23T07:40:45-05:00</updated>
   <id>http://bsrandall.github.io/mst/2017/02/23/MST-IST-CIST</id>
   <content type="html">&lt;p&gt;IST is the Internal Spanning Tree, also known as instance 0. This instance is designated to carry all STP information, including information from other instances. MSTP does not send BPDUs for ever instance separately - these are all contained within the IST BPDU.&lt;/p&gt;

&lt;p&gt;To accommodate, the other instances information is carried within the IST BPDU using special M-Record fields - one for every active MSTI. These fields carry carry MSTP information such as bridge priority, root path cost, and port priority.&lt;/p&gt;

&lt;p&gt;IST also plays a huge role in multiple MSTP region configurations. When a switch receives a BPDU from another region, it marks the corresponding port as MSTP &lt;em&gt;boundary&lt;/em&gt;. The interconnected, different region switches then form a CIST spanning across the regions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.ine.com/wp-content/uploads/2010/02/mstp-3-multi-region-physical-topology.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Remember, an IST is internal to a region while a CIST is the IST spanning across multiple regions.&lt;/p&gt;

&lt;p&gt;Here is a sample MST BPDU:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.ine.com/wp-content/uploads/2010/02/mstp-3-multi-region-cst-mstp-packet-format.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The CIST Root is elected among all regions while the CIST Regional Root is elected in every region. The IST Root = CIST Regional Root in cases where multiple MST regions interoperate. The CIST Root is the bridge that has the lowest Bridge Id among all regions - the CIST Root could be a bridge inside a region or a boundary switch in a region. The CIST Regional Root is a &lt;em&gt;boundary switch&lt;/em&gt; elected for every region based on the shortest external path cost to reach the CIST Root. As mentioned above, it is important to remember that the CIST Regional Root becomes the root of the IST for the given region as well - the region changes its IST election process to make the CIST Regional Root the IST root.&lt;/p&gt;

&lt;p&gt;When an MST switch boots up, it declares itself the CIST Root and CIST Regional Root and announce that it its outgoing BPDUs on all internal ports. On boundary ports (those that have received BPDUs from another region), the switch will only advertise its CIST Root Bridge ID and CIST External Root Path Cost, hiding the details of the region’s inner topology.&lt;/p&gt;

&lt;p&gt;The region that contains the CIST Root automatically places all of its boundary ports in an unblocked state.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;CIST External Root Path Cost&lt;/em&gt; is the cost to reach the CIST Root across the links connecting the boundary ports. When a BPDU is received on an internal link, this cost is not changed.&lt;/p&gt;

&lt;p&gt;Only a boundary switch can be elected as the CIST Regional Root, and this is the switch with the lowest cost to reach the CIST Root. If a boundary switch receives a BPDU with a lower CIST External Root Path cost on one of its internal ports, it will stop announcing itself as the CIST Regional Root and start announcing the new metric out of its boundary ports.&lt;/p&gt;

&lt;p&gt;If a switch is a CIST Regional Root, it elects one of its boundary ports as the CIST Root port and blocks all other boundary ports. If a boundary switch is not the CIST Regional Root, it will mark its boundary ports as Designated or Alternate, Designate only if it has a better External Root Path cost or in case of a tie, lower CIST Regional Root Bridge ID.&lt;/p&gt;

&lt;p&gt;The regional MSTIs are constructed independently at every region, but they have to be mapped to the CIST at the boundary ports. This equates to the inability to load-balance VLAN traffic on the boundary links by mapping VLANs to different instances.&lt;/p&gt;

&lt;p&gt;A topology change in the CST could change all paths in the topology thus requiring massive MAC address relearning.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Multiple Spanning Tree</title>
   <link href="http://bsrandall.github.io/mst/2017/02/22/MST/"/>
   <updated>2017-02-22T10:40:45-05:00</updated>
   <id>http://bsrandall.github.io/mst/2017/02/22/MST</id>
   <content type="html">&lt;p&gt;Multiple Spanning Tree (MST) was developed to overcome the high resource requirements of PVST. In reality, there are only a few logical redundant design on a network, regardless of the number of VLANs or the number of physical links. With MST you can run several different logical topologies (instances), and map VLANs to those instances. You get the benefit of running a redundant, fully utilized network without the resource overhead on the switches.&lt;/p&gt;

&lt;p&gt;So the end result is that with PVST, a port is either forwarding or discarding for a VLAN, while with MST, a port is either forwarding or discarding for an instance which contains multiple VLANs.&lt;/p&gt;

&lt;p&gt;MST is defined by IEEE 802.1s. A special instance, instance 0 or the Internal Spanning Tree (IST), is designated to carry all STP information. The BPDUs for IST carry all the standard RSTP information, as well as the configuration name, revision number, and a &lt;em&gt;hash value&lt;/em&gt; calculated over the VLAN to instance mapping.&lt;/p&gt;

&lt;p&gt;You should not run MSTP on access ports.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>VTP Pruning</title>
   <link href="http://bsrandall.github.io/vtp/2017/02/22/VTP-Pruning/"/>
   <updated>2017-02-22T09:40:45-05:00</updated>
   <id>http://bsrandall.github.io/vtp/2017/02/22/VTP-Pruning</id>
   <content type="html">&lt;p&gt;The principal of VTP pruning is if a client sends a broadcast to its connected switch’s access port, that switch will flood the broadcast to all other connected switches in the VTP / Layer 2 domain. Because of VTP, all the other switches would be aware of the client VLAN, and would thus be required to flood the broadcast to all other switches.&lt;/p&gt;

&lt;p&gt;But what if the other switches do not have any clients connected to access ports in that VLAN? They are still having to process the request, and the network segment still has to bear the broadcast traffic.&lt;/p&gt;

&lt;p&gt;When you enable VTP pruning, you are enabling it for the entire VTP domain.&lt;/p&gt;

&lt;p&gt;VTP pruning is enabled on the VTP server(s) with the simple global configuration command &lt;code class=&quot;highlighter-rouge&quot;&gt;vtp pruning&lt;/code&gt;. To verify what VLANs have been pruned, you should use &lt;code class=&quot;highlighter-rouge&quot;&gt;show interface trunk&lt;/code&gt;. Note that the VLANs will still be seen in the output of &lt;code class=&quot;highlighter-rouge&quot;&gt;show vlan&lt;/code&gt;, but you will see they are pruned in the command as shown below.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;`SW4#sh int trunk

Port        Mode             Encapsulation  Status        Native vlan
Gi0/3       auto             802.1q         trunking      1
Gi1/0       auto             802.1q         trunking      1

Port        Vlans allowed on trunk
Gi0/3       1-4094
Gi1/0       1-4094

Port        Vlans allowed and active in management domain
Gi0/3       1,5,7-10,22,43,58,67,79,146
Gi1/0       1,5,7-10,22,43,58,67,79,146

Port        Vlans in spanning tree forwarding state and not pruned
Gi0/3       none
Gi1/0       none
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;`&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>VTP Versions</title>
   <link href="http://bsrandall.github.io/vtp/2017/02/21/VTP-Versions/"/>
   <updated>2017-02-21T14:40:45-05:00</updated>
   <id>http://bsrandall.github.io/vtp/2017/02/21/VTP-Versions</id>
   <content type="html">&lt;p&gt;VTP is a Cisco proprietary protocol that allows VLAN administration to be shared across switches. It gives an administrator the capability to centrally administer VLAN creation across one or two switches, and have those VLANs propagate across a VTP domain made up of any number of switches.&lt;/p&gt;

&lt;p&gt;There are 3 versions of VTP, versions 1, 2, and 3.  There are not many significant changes between versions 1 and 2, except version 2 introduced support for Token Ring VLANs.&lt;/p&gt;

&lt;p&gt;Version 3 introduced the following enhancements:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;hidden authentication (does not appear in plain text in the configuration file)&lt;/li&gt;
  &lt;li&gt;Extended VLAN support. Versions 1 and 2 only support VLANs 1 - 1000 only.&lt;/li&gt;
  &lt;li&gt;Support for private VLANs&lt;/li&gt;
  &lt;li&gt;Support for MST&lt;/li&gt;
  &lt;li&gt;primary and secondary servers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With version 3, there are two types of VTP servers - primary and secondary. There is only one primary server, and the rest of the secondary servers act as backups to the primary. To declare a server as primary, use the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SW1# vtp primary vlan
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Notice the command is done in privileged mode, not configure mode!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>VTP Messages</title>
   <link href="http://bsrandall.github.io/vtp/2017/02/21/VTP-Header/"/>
   <updated>2017-02-21T13:40:45-05:00</updated>
   <id>http://bsrandall.github.io/vtp/2017/02/21/VTP-Header</id>
   <content type="html">&lt;p&gt;All VTP packets contain these fields in the header:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;VTP version (1, 2, or 3)&lt;/li&gt;
  &lt;li&gt;VTP Message Type
    &lt;ul&gt;
      &lt;li&gt;Summary advertisements&lt;/li&gt;
      &lt;li&gt;Subset advertisement&lt;/li&gt;
      &lt;li&gt;Advertisement requests&lt;/li&gt;
      &lt;li&gt;VTP Join Messages&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Management domain length&lt;/li&gt;
  &lt;li&gt;Management domain name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most VTP packets contain the &lt;em&gt;configuration revision number&lt;/em&gt; of the sender. This is used to determine if the received information is more recent than the current version.&lt;/p&gt;

&lt;p&gt;By default, &lt;em&gt;summary advertisements&lt;/em&gt; are sent every 5 minutes. The summary advertisement contains the VTP domain name and the current configuration revision number. If the VTP domain matches the switch’s configured VTP domain, and the configuration revision number is higher than its own revision, the switch will send an &lt;em&gt;advertisement request&lt;/em&gt;. Otherwise, it ignores the packet.&lt;/p&gt;

&lt;h4 id=&quot;summary-advertisement-packet-format&quot;&gt;Summary Advertisement Packet Format&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cisco.com/c/dam/en/us/support/docs/lan-switching/vtp/10558-21c.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;subset advertisement&lt;/em&gt; will follow a summary advertisement - it is the message that actually contains a list (or a subset of a list) of the VLANs being advertised.&lt;/p&gt;

&lt;p&gt;A switch will send an &lt;em&gt;advertisement request&lt;/em&gt; in these situations:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;the switch has been reset&lt;/li&gt;
  &lt;li&gt;the VTP domain name has been changed on the switch&lt;/li&gt;
  &lt;li&gt;the switch has received a VTP summary advertisement with a higher configuration than its own&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Dynamic Trunking Protocol (DTP)</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/21/DTP/"/>
   <updated>2017-02-21T12:40:45-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/21/DTP</id>
   <content type="html">&lt;p&gt;Dynamic Trunking Protocol is a Cisco proprietary protocol that, when configured, attempts to negotiate trunking between two connected ports. It will try to negotiate trunking as well as the encapsulation type.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport mode dynamic auto&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;allows the interfaces to become a trunk if the neighboring trunk is set to trunk or desirable mode&lt;/li&gt;
  &lt;li&gt;this is the default setting for newer Cisco switches&lt;/li&gt;
  &lt;li&gt;if both ends of a trunk are set to dynamic auto, they will not form a trunk&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport mode dynamic desireable&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;makes the interface actively attempt to negotiate trunking&lt;/li&gt;
  &lt;li&gt;the link will become a trunk if the neighbor interface is set to trunk, auto, or desirable&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport nonegotiate&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;prevents the interface from sending DTP frames&lt;/li&gt;
  &lt;li&gt;can use this when the interface switch port mode is &lt;em&gt;access&lt;/em&gt; or &lt;em&gt;trunk&lt;/em&gt; only&lt;/li&gt;
  &lt;li&gt;if enabled, to establish a trunk the neighbor interface must be manually set to &lt;em&gt;trunk&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Dot1q</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/21/Dot1q/"/>
   <updated>2017-02-21T11:40:45-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/21/Dot1q</id>
   <content type="html">&lt;h4 id=&quot;trunks&quot;&gt;Trunks&lt;/h4&gt;
&lt;p&gt;Dot1q is the standard trunking protocol used for transporting multiple VLANs across a trunk port. A trunk is a point-to-point link that carries the traffic for multiple VLANs across a single trunk. Dot1q is a standard that tags VLANs for identification. The receiving switch will then strip the VLAN tag from the frame before passing it to the appropriate access port.&lt;/p&gt;

&lt;p&gt;The full name for Dot1q is IEEE 802.1Q.&lt;/p&gt;

&lt;p&gt;The 802.1Q Tagged frame looks like this:
&lt;img src=&quot;http://bsrandall.github.io/public/img/802.1q.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The PRI field is the 3-bit 802.1p priority field.&lt;/li&gt;
  &lt;li&gt;The CFI field is always set to 0 for Ethernet switches&lt;/li&gt;
  &lt;li&gt;VLAN ID is a 12-bit field&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because of the extra fields, an 802.1Q frame has an MTU of 1522 bytes.&lt;/p&gt;

&lt;p&gt;If a non-802.1Q enabled device or an access port receives a tagged frame, it simply ignores the frame and forwards it as usual.&lt;/p&gt;

&lt;h4 id=&quot;native-vlan&quot;&gt;Native VLAN&lt;/h4&gt;
&lt;p&gt;A Native VLAN on a trunk is the VLAN to which untagged traffic belongs. Across a trunk, the Native VLANs should match on each end.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# show interface trunk&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;will show the Native VLAN for each interface that has active trunking.&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>VLANs</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/21/Allowed-VLANs/"/>
   <updated>2017-02-21T10:40:45-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/21/Allowed-VLANs</id>
   <content type="html">&lt;p&gt;By default, all VLANs are allowed to traverse an 802.1Q trunk once it is active. To restrict which VLANs are allowed to cross a trunk, you must go into IOS and explicitly define the VLANs that are allowed.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk allow VLAN 15-20,22,25&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk allowed vlan add 27&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk allowed vlan remove 18&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You must remember that if an allowed VLAN list is already configured on a trunk, issuing the &lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk allowed vlan 16-20,2,25&lt;/code&gt; command will overwrite the previously defined VLANs. You must use the &lt;em&gt;add&lt;/em&gt; and &lt;em&gt;remove&lt;/em&gt; commands if there is already an allowed clan configuration in the running config.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Access Ports</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/21/Access-Ports/"/>
   <updated>2017-02-21T09:40:45-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/21/Access-Ports</id>
   <content type="html">&lt;p&gt;Access ports are those ports that are connected to end devices, not other switches. We define an access port on the command line with 
SW1# switchport mode access&lt;/p&gt;

&lt;p&gt;We will see later with Spanning Tree, that PortFast can and should be used on access ports. This does two things. First, it allows the port to skip the listening phase for faster availability. Second, it prevents the access port from sending TCNs (Topology Change Notifications) every time a user plugs or unplugs a device into the port.&lt;/p&gt;

&lt;p&gt;Another Spanning Tree feature which will relate to Access ports is BPDU Guard. With BPDU Guard, if the switch receives a BPDU on a port where BPDU Guard was enabled, the port will transition to the errdisabled state.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>IP SLA Overview</title>
   <link href="http://bsrandall.github.io/general%20routing/2017/02/20/IP-SLA-Overview/"/>
   <updated>2017-02-20T12:40:45-05:00</updated>
   <id>http://bsrandall.github.io/general%20routing/2017/02/20/IP-SLA-Overview</id>
   <content type="html">&lt;p&gt;Cisco IP SLA uses active traffic monitoring for measuring traffic performance. It performs this by generating traffic in a continuous, reliable, and predictable manner and then analyzing the results. The information collected includes response time, one-way latency, jitter, packet loss, voice quality scoring, network resource availability, application performance, and server response time.&lt;/p&gt;

&lt;p&gt;If configuring simple IP SLA Operations such as ICMP echo, the operation only has to be configured on the local router. But for the more advanced Operations, you must set up the remote router or device to &lt;em&gt;respond&lt;/em&gt; to your IP SLA traffic. The IP SLA Responder is a component embedded in the destination Cisco device that allows the system to anticipate and respond to IP SLA request packets. Only a Cisco device can be a source for a destination IP SLA Responder.&lt;/p&gt;

&lt;p&gt;To see the IP SLA Operation types, enter IP SLA configuration mode as follows:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1(config)#ip sla 1
R1(config-ip-sla)#?
IP SLAs entry configuration commands:
  dhcp         DHCP Operation
  dns          DNS Query Operation
  ethernet     Ethernet Operations
  exit         Exit Operation Configuration
  ftp          FTP Operation
  http         HTTP Operation
  icmp-echo    ICMP Echo Operation
  icmp-jitter  ICMP Jitter Operation
  mpls         MPLS Operation
  path-echo    Path Discovered ICMP Echo Operation
  path-jitter  Path Discovered ICMP Jitter Operation
  tcp-connect  TCP Connect Operation
  udp-echo     UDP Echo Operation
  udp-jitter   UDP Jitter Operation
  voip         Voice Over IP Operation
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To set up a Cisco routing device as an SLA responder, you would use the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1(config)# ip sla responder
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After an IP SLA Operation has been configured, you must schedule the operation to run:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1(config)# ip sla schedule 1 start-time now life forever
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To then see the results of the IP SLA configuration, use the following:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1# show ip sla statistics
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So starting from the top, a real quick example of an IP SLA configuration to ping an IP address every 30 seconds for 3 hours would look like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;R1(config)# ip sla 1
R1(config-ip-sla)# icmp-echo 150.1.3.3
R1(config-ip-sla-echo)# frequency 30
R1(config-ip-sla-echo)# exit
R1(config)# ip spa schedule 1 start-time now life 10800
R1(config)# exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>VLANs</title>
   <link href="http://bsrandall.github.io/vlan/2017/02/20/VLANs/"/>
   <updated>2017-02-20T10:40:45-05:00</updated>
   <id>http://bsrandall.github.io/vlan/2017/02/20/VLANs</id>
   <content type="html">&lt;h4 id=&quot;standard-vlans&quot;&gt;Standard VLANs&lt;/h4&gt;
&lt;p&gt;Cisco calls VLANS 1 - 1005 Normal VLANs. Of those, VLAN 1 is the Cisco default. You can use this VLAN, but your are not allowed to delete it. VLANs 1002 - 1005 are the Cisco defaults for FDDI and Token Ring. These also cannot be deleted.&lt;/p&gt;

&lt;p&gt;That leaves us VLANs 2 - 1001 as Normal VLANs that we can add or delete as we wish.&lt;/p&gt;

&lt;p&gt;VLANs 2 - 1001 are pruning eligible, while VLANs 1006 - 4094 are not.&lt;/p&gt;

&lt;p&gt;When you delete a VLAN, any LAN ports configured as access ports for that VLAN become inactive until you assign them to a new VLAN.&lt;/p&gt;

&lt;h4 id=&quot;extended-vlans&quot;&gt;Extended VLANs&lt;/h4&gt;
&lt;p&gt;Extended VLANs are in the range of 1006 - 4094. Extended range VLANs are not controlled by VTP and cannot be pruned. The router must be in VTP transparent mode in order to create extended VLANs.&lt;/p&gt;

&lt;p&gt;Extended range VLANs are not stored in vlan.dat&lt;/p&gt;

&lt;h4 id=&quot;vlan-database&quot;&gt;VLAN Database&lt;/h4&gt;
&lt;p&gt;Only applies to standard VLANs.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Git</title>
   <link href="http://bsrandall.github.io/general/2017/02/20/Git/"/>
   <updated>2017-02-20T09:40:45-05:00</updated>
   <id>http://bsrandall.github.io/general/2017/02/20/Git</id>
   <content type="html">&lt;p&gt;I am not a git master, nor do I strive to become one. But I do need to know some basic details to manage this blog as well as my INE VIRL configurations. There are probably better ways to do this, but for my purposes, these are the commands I am running to push my updates from my MacBook to by GitHub page:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/Dropbox/jekyll.bsrandall.github.io(master) &amp;gt;&amp;gt; git add --all&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt; ~/Dropbox/jekyll.bsrandall.github.io(master) &amp;gt;&amp;gt; git commit -m &quot;update notes&quot;&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;~/Dropbox/jekyll.bsrandall.github.io(master) &amp;gt;&amp;gt; git push -u origin master&lt;/code&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Hello World</title>
   <link href="http://bsrandall.github.io/general/2017/02/20/Hello-World/"/>
   <updated>2017-02-20T08:40:45-05:00</updated>
   <id>http://bsrandall.github.io/general/2017/02/20/Hello-World</id>
   <content type="html">&lt;p&gt;This is my first post in my newly launched blog. I decided to go with Jekyll and a GitHub page for my blog backend. I wanted my content to be in Markdown, as that seems to be the authoring flavor of the day. Jekyll and GitHub just made sense due to their support of Markdown.&lt;/p&gt;

&lt;p&gt;Our knowledge is at its pinnacle when we can fluidly explain topics to others. That is my main motivation for this blog. There most likely will not be any ground breaking content, but I hope to explain some of the topics in a way that makes sense.&lt;/p&gt;

&lt;p&gt;The other two benefits to my blog is hopefully improving on my Markdown and typing skills. It is sad that I still type as badly as I do, considering how much I type. I will use Markdown highlighting for code samples. TextExpander should make all of this a little easier.&lt;/p&gt;

&lt;p&gt;This is some sample IOS commands using Markdown:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport trunk encapsulation dot1q&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;SW1# switchport mode trunk&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Well I am off to the races. Or as most of those who have gone before me stress, off to start the marathon!&lt;/p&gt;
</content>
 </entry>
 

</feed>
